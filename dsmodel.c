#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model ElectricVehicle2.Main.stdMechEV
 Dymola Version 2021 (64-bit), 2020-05-13 translated this at Mon Mar 22 15:53:31 2021

   */

#include <matrixop.h>
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays1[5]={1.0, 100000.0, 3.0, 3.0, 0.1};
static double DymArrays0[5]={3.0, 2.0, 1.0, 0.0, -1.0};
#endif
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc0 {
  int  id_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(int   id_02) {
  struct DymStruc0 dummy_0;
  dummy_0.id_0member = id_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getNextTimeEvent_M(
  struct DymStruc0 tableID0_0, double  timeIn0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTimeTableTmax_M(
  struct DymStruc0 tableID0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTimeTableTmin_M(
  struct DymStruc0 tableID0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTimeTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  timeIn0_0, double  
  nextTimeEvent0_0, double  prex_0nextTimeEvent);
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTimeTable_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  double  startTime0_0, IntegerArray   columns0_0, int  smoothness0_0, int  
  extrapolation0_0, double  shiftTime0_0, int  timeEvents0_0, int  
  verboseRead0_0, int id_, int alwaysMakeNew_);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTimeTable_destructor_M(
  void* externalCombiTimeTable0_0);
struct Modelica_Math_Vectors_interpolate_struct {
  double   yi0_0_0member;
  int   iNew0_0_0member;
};
DYMOLA_STATIC struct Modelica_Math_Vectors_interpolate_struct Modelica_Math_Vectors_interpolate
  (RealArray   x0_0, RealArray   y0_0, double  xi0_0, int  iLast0_0);
DYMOLA_STATIC int   Modelica_Math_isEqual(double  s10_0, double  s20_0, double  
  eps0_0);
DYMOLA_STATIC int   Modelica_Utilities_Strings_isEmpty(const char*  string0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getNextTimeEvent
input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
discrete input Real timeIn;
discrete output Real nextTimeEvent "Next time event in table";

external "C" nextTimeEvent = ModelicaStandardTables_CombiTimeTable_nextTimeEvent(tableID, timeIn);
annotation(Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getNextTimeEvent;

  */
extern double (ModelicaStandardTables_CombiTimeTable_nextTimeEvent)(void*, 
  double );
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getNextTimeEvent_M(
  struct DymStruc0 tableID0_0, double  timeIn0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getNextTimeEvent")
  {
    /* Declare outputs and temporaries */
    double   nextTimeEvent0_0;
    nextTimeEvent0_0=0;
    /* Start of real code */
    {
      nextTimeEvent0_0 = (ModelicaStandardTables_CombiTimeTable_nextTimeEvent)(
        externalTable_[tableID0_0.id_0member].obj_, timeIn0_0);
      }
    /* Output section */
    PopContext()
    return nextTimeEvent0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTimeTableTmax
input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
discrete output Real timeMax "Maximum abscissa value in table";

external "C" timeMax = ModelicaStandardTables_CombiTimeTable_maximumTime(tableID);
annotation(Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getTimeTableTmax;

  */
extern double (ModelicaStandardTables_CombiTimeTable_maximumTime)(void*);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTimeTableTmax_M(
  struct DymStruc0 tableID0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTimeTableTmax")
  {
    /* Declare outputs and temporaries */
    double   timeMax0_0;
    timeMax0_0=0;
    /* Start of real code */
    {
      timeMax0_0 = (ModelicaStandardTables_CombiTimeTable_maximumTime)(
        externalTable_[tableID0_0.id_0member].obj_);
      }
    /* Output section */
    PopContext()
    return timeMax0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTimeTableTmin
input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
discrete output Real timeMin "Minimum abscissa value in table";

external "C" timeMin = ModelicaStandardTables_CombiTimeTable_minimumTime(tableID);
annotation(Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getTimeTableTmin;

  */
extern double (ModelicaStandardTables_CombiTimeTable_minimumTime)(void*);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTimeTableTmin_M(
  struct DymStruc0 tableID0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTimeTableTmin")
  {
    /* Declare outputs and temporaries */
    double   timeMin0_0;
    timeMin0_0=0;
    /* Start of real code */
    {
      timeMin0_0 = (ModelicaStandardTables_CombiTimeTable_minimumTime)(
        externalTable_[tableID0_0.id_0member].obj_);
      }
    /* Output section */
    PopContext()
    return timeMin0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTimeTableValue
input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
input Integer icol;
discrete input Real timeIn;
discrete input Real nextTimeEvent;
discrete input Real pre_nextTimeEvent;
discrete output Real y;

external "C" y = ModelicaStandardTables_CombiTimeTable_getValue(tableID, icol, timeIn, nextTimeEvent, pre_nextTimeEvent);
annotation(derivative(noDerivative=nextTimeEvent, noDerivative=pre_nextTimeEvent)=Modelica.Blocks.Tables.Internal.getDerTimeTableValue, Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getTimeTableValue;

  */
extern double (ModelicaStandardTables_CombiTimeTable_getValue)(void*, int , 
  double , double , double );
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTimeTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  timeIn0_0, double  
  nextTimeEvent0_0, double  prex_0nextTimeEvent) {
  PushContext("Modelica.Blocks.Tables.Internal.getTimeTableValue")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      y0_0 = (ModelicaStandardTables_CombiTimeTable_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, icol0_0, timeIn0_0, nextTimeEvent0_0, 
        prex_0nextTimeEvent);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function constructor
input String tableName "Table name";
input String fileName "File name";
discrete input Real table[:, :];
discrete input Real startTime(unit = "s");
input Integer columns[:];
input Modelica.Blocks.Types.Smoothness smoothness;
input Modelica.Blocks.Types.Extrapolation extrapolation;
discrete input Real shiftTime(start = 0.0, unit = "s");
input Modelica.Blocks.Types.TimeEvents timeEvents(start = Modelica.Blocks.Types.TimeEvents.Always);
input Boolean verboseRead(start = true) "= true: Print info message; = false: No info message";
output Modelica.Blocks.Types.ExternalCombiTimeTable externalCombiTimeTable;

external "C" externalCombiTimeTable = ModelicaStandardTables_CombiTimeTable_init2(fileName, tableName, table, size(table, 1), size(table, 2), startTime, columns, size(columns, 1), smoothness, extrapolation, shiftTime, timeEvents, verboseRead);
annotation(Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end constructor;

  */
extern void* (ModelicaStandardTables_CombiTimeTable_init2)(const char* , 
  const char* , double  const *, size_t, size_t, double , int  const *, size_t, 
  int , int , double , int , int );
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTimeTable_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  double  startTime0_0, IntegerArray   columns0_0, int  smoothness0_0, int  
  extrapolation0_0, double  shiftTime0_0, int  timeEvents0_0, int  
  verboseRead0_0, int id_, int alwaysMakeNew_) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTimeTable")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  externalCombiTimeTable0_0;
    externalCombiTimeTable0_0.id_0member=0;
    /* Start of real code */
    {
      externalCombiTimeTable0_0.id_0member=id_;
      if (externalTable_[id_].destructor_ && externalTable_[id_].obj_ && alwaysMakeNew_) {
      void*x_=externalTable_[id_].obj_;
      externalTable_[id_].obj_=0;
      (*(externalTable_[id_].destructor_))(x_);
      } else if (!externalTable_[id_].destructor_) {externalTable_[id_].obj_=0;}
      #if (defined(_OPENMP) && !defined(DISABLE_DYMOLA_OPENMP))
      if (!(externalTable_[id_].haveLock_)) {omp_init_lock(&(externalTable_[id_].lockExternal_));externalTable_[id_].haveLock_=1;}
      #endif
      externalTable_[id_].destructor_=Modelica_Blocks_Types_ExternalCombiTimeTable_destructor_M;

        if (!externalTable_[id_].obj_) externalTable_[id_].obj_ = (
        ModelicaStandardTables_CombiTimeTable_init2)(fileName0_0, tableName0_0, 
        table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], startTime0_0, 
        columns0_0.data, columns0_0.dims[1-1], smoothness0_0, extrapolation0_0, 
        shiftTime0_0, timeEvents0_0, verboseRead0_0);
      }
    /* Output section */
    PopContext()
    return externalCombiTimeTable0_0;
  }}

/* Flattened Modelica model:

function destructor
input Modelica.Blocks.Types.ExternalCombiTimeTable externalCombiTimeTable;

external "C" ModelicaStandardTables_CombiTimeTable_close(externalCombiTimeTable);
annotation(Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end destructor;

  */
extern void (ModelicaStandardTables_CombiTimeTable_close)(void*);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTimeTable_destructor_M(
  void* externalCombiTimeTable0_0) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTimeTable.destructor")
  {
    /* Declare outputs and temporaries */
    /* Start of real code */
    {
      (ModelicaStandardTables_CombiTimeTable_close)(externalCombiTimeTable0_0);
      }
    /* Output section */
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Math.Vectors.interpolate
discrete input Real x[:] "Abscissa table vector (strict monotonically increasing values required)";
discrete input Real y[size(x, 1)] "Ordinate table vector";
discrete input Real xi "Desired abscissa value";
input Integer iLast(start = 1) "Index used in last search";
discrete output Real yi "Ordinate value corresponding to xi";
output Integer iNew(start = 1) "xi is in the interval x[iNew] <= xi < x[iNew+1]";
protected 
Integer i;
Integer nx(start = size(x, 1));
discrete Real x1;
discrete Real x2;
discrete Real y1;
discrete Real y2;
public 
algorithm 
assert(nx > 0, "The table vectors must have at least 1 entry.");
if (nx == 1) then 
yi := y[1];
else
i := min(max(iLast, 1), nx-1);
if (xi >= x[i]) then 
while i < nx and xi >= x[i] loop
i := i+1;
end while;
i := i-1;
else
while i > 1 and xi < x[i] loop
i := i-1;
end while;
end if;
x1 := x[i];
x2 := x[i+1];
y1 := y[i];
y2 := y[i+1];
assert(x2 > x1, "Abscissa table vector values must be increasing");
yi := y1+(y2-y1)*(xi-x1)/(x2-x1);
iNew := i;
end if;
annotation(smoothOrder=100);
end Modelica.Math.Vectors.interpolate;

  */
DYMOLA_STATIC struct Modelica_Math_Vectors_interpolate_struct Modelica_Math_Vectors_interpolate
  (RealArray   x0_0, RealArray   y0_0, double  xi0_0, int  iLast0_0) {
  PushContext("Modelica.Math.Vectors.interpolate")
  AssertModelica(DYNSizeSimple(y0_0,1)==DYNSizeSimple(x0_0, 1),"size(y, 1) == size(x, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    double   yi0_0;
    int   iNew0_0;
    int   i0_0;
    int   nx0_0;
    double   x10_0;
    double   x20_0;
    double   y10_0;
    double   y20_0;
    yi0_0=0;
    iNew0_0 = 1;
    i0_0=0;
    nx0_0 = DYNSizeSimple(x0_0, 1);
    x10_0=0;
    x20_0=0;
    y10_0=0;
    y20_0=0;
    /* Start of real code */
      AssertModelica(nx0_0 > 0,"nx > 0", "The table vectors must have at least 1 entry.");
      if (nx0_0 == 1) {
        yi0_0 = RealElement( y0_0, (SizeType)(1));
      }
      else{
        i0_0 = IntegerBmin(IntegerBmax(iLast0_0, 1), nx0_0-1);
        if (xi0_0 >= RealElement( x0_0, (SizeType)(i0_0))) {
          while (i0_0 < nx0_0 AND xi0_0 >= RealElement( x0_0, (SizeType)(i0_0))) {
            i0_0 = i0_0+1;
          }
          i0_0 = i0_0-1;
        }
        else{
          while (i0_0 > 1 AND xi0_0 < RealElement( x0_0, (SizeType)(i0_0))) {
            i0_0 = i0_0-1;
          }
        }
        x10_0 = RealElement( x0_0, (SizeType)(i0_0));
        x20_0 = RealElement( x0_0, (SizeType)(i0_0+1));
        y10_0 = RealElement( y0_0, (SizeType)(i0_0));
        y20_0 = RealElement( y0_0, (SizeType)(i0_0+1));
        AssertModelica(x20_0 > x10_0,"x2 > x1", "Abscissa table vector values must be increasing");
        yi0_0 = y10_0+divGuarded((y20_0-y10_0)*(xi0_0-x10_0),"(y2-y1)*(xi-x1)",
          x20_0-x10_0,"x2-x1");
        iNew0_0 = i0_0;
      }
    /* Output section */
    PopContext()
    {
      struct Modelica_Math_Vectors_interpolate_struct out_;
      out_.yi0_0_0member = yi0_0;
      out_.iNew0_0_0member = iNew0_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Math.isEqual
discrete input Real s1 "First scalar";
discrete input Real s2 "Second scalar";
discrete input Real eps(start = 0, min = 0.0) "The two scalars are identical if abs(s1-s2) <= eps";
output Boolean result "= true, if scalars are identical";

algorithm 
result := abs(s1-s2) <= eps;
annotation(Inline=true);
end Modelica.Math.isEqual;

  */
DYMOLA_STATIC int   Modelica_Math_isEqual(double  s10_0, double  s20_0, double  
  eps0_0) {
  PushContext("Modelica.Math.isEqual")
  {
    /* Declare outputs and temporaries */
    int   result0_0;
    result0_0=0;
    /* Start of real code */
      result0_0 = fabs(s10_0-s20_0) <= eps0_0;
    /* Output section */
    PopContext()
    return result0_0;
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Strings.isEmpty
input String string;
output Boolean result "True, if string is empty";
protected 
Integer nextIndex;
Integer len;
public 
algorithm 
nextIndex := ModelicaStrings_skipWhiteSpace(string, 1);
len := ModelicaStrings_length(string);
if (len < 1 or nextIndex > len) then 
result := true;
else
result := false;
end if;
end Modelica.Utilities.Strings.isEmpty;

  */
DYMOLA_STATIC int   Modelica_Utilities_Strings_isEmpty(const char*  string0_0) {
  PushContext("Modelica.Utilities.Strings.isEmpty")
  {
    /* Declare outputs and temporaries */
    int   result0_0;
    int   nextIndex0_0;
    int   len0_0;
    result0_0=0;
    nextIndex0_0=0;
    len0_0=0;
    /* Start of real code */
      nextIndex0_0 = ModelicaStrings_skipWhiteSpace(string0_0, 1);
      len0_0 = ModelicaStrings_length(string0_0);
      if (len0_0 < 1 OR nextIndex0_0 > len0_0) {
        result0_0 = true;
      }
      else{
        result0_0 = false;
      }
    /* Output section */
    PopContext()
    return result0_0;
  }}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
#define NX_    3
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    372
#define NP_    109
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   2
#define MAXAuxStr_   12
#define MAXAuxStrLen_   500
#define NHash1_ 1352341431
#define NHash2_ -136761933
#define NHash3_ 0
#define NI_    0
#define NRelF_ 18
#define NRel_  19
#define NTim_  1
#define NSamp_ 0
#define NCons_ 0
#define NA_    661
#define SizePre_ 6
#define SizeEq_ 3
#define SizeDelay_ 0
#define QNLmax_ 4
#define MAXAux 5
#define NrDymolaTimers_ 0
#define NWhen_ 2
#define NCheckIf_ 0
#define NGlobalHelp_ 175
#define NGlobalHelpI_ 92
#ifndef NExternalObject_
#define NExternalObject_ 1
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="ElectricVehicle2.Main.stdMechEV";
#endif
DYMOLA_STATIC const char*usedLibraries[]={"ElectrifiedPTLib",0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/kunjs/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[8]={2 , 2 , 1 , 2 , 1 , 3 , 0 , 0};
static int QJacobianGrp0[4]={2, 2, 2, 0};
static int QJacobianGrp1[4]={0, 3, 3, 0};
DYMOLA_STATIC struct QJacobianTag_ QJacobianGC2_[3]={
{0, QJacobianGrp0},{0, QJacobianGrp1},{0,0}};
DYMOLA_STATIC double QJacobianCD_[4]={0  , 44 , 55 , 60};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1) = 1;
DYNX(W_,27) = false;
memcpy(&DYNX(W_,38), &DymArrays0, sizeof(double)*5);
DYNX(W_,44) = 1;
DYNX(W_,45) = 1;
DYNX(W_,46) = false;
DYNX(W_,55) = false;
DYNX(W_,56) = false;
DYNX(W_,63) = 3;
DYNX(W_,65) = 3;
DYNX(W_,71) = 0.0001;
DYNX(W_,72) = 4;
DYNX(W_,73) = false;
DYNX(W_,88) = false;
DYNX(W_,89) = false;
DYNX(W_,101) = 2;
DYNX(W_,106) = false;
DYNX(W_,111) = 1;
DYNX(W_,124) = true;
DYNX(W_,125) = false;
DYNX(W_,127) = false;
DYNX(W_,139) = false;
DYNX(W_,148) = true;
DYNX(W_,155) = false;
DYNX(W_,156) = false;
DYNX(W_,163) = true;
DYNX(W_,171) = false;
DYNX(W_,175) = false;
DYNX(W_,181) = true;
DYNX(W_,215) = true;
DYNX(W_,216) = true;
DYNX(W_,217) = true;
DYNX(W_,223) = true;
DYNX(W_,225) = true;
DYNX(W_,227) = true;
DYNX(W_,229) = false;
DYNX(W_,230) = false;
DYNX(W_,250) = false;
DYNX(W_,251) = false;
DYNX(W_,264) = false;
DYNX(W_,269) = false;
DYNX(W_,270) = false;
DYNX(W_,272) = true;
DYNX(W_,279) = false;
DYNX(W_,280) = false;
DYNX(W_,289) = false;
DYNX(W_,292) = 3;
DYNX(W_,302) = true;
DYNX(W_,310) = false;
DYNX(W_,314) = false;
DYNX(W_,320) = true;
DYNX(W_,356) = 3;
DYNX(W_,362) = false;
DYNX(W_,363) = false;
#endif
DYNSetAuxString(did_, "NoName", 0);
DYNSetAuxString(did_, "NoName", 1);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,4) = 2;
DYNX(W_,7) = 1;
DYNX(W_,22) = false;
DYNX(W_,23) = 2;
DYNX(W_,24) = true;
DYNX(W_,52) = false;
DYNX(W_,53) = 2;
DYNX(W_,54) = true;
DYNX(W_,107) = 5;
DYNX(W_,108) = 2;
DYNX(W_,109) = false;
DYNX(W_,110) = true;
DYNX(W_,120) = false;
DYNX(W_,121) = 2;
DYNX(W_,122) = true;
DYNX(W_,140) = true;
#endif
DYNSetAuxString(did_, "DC supply voltage of inverter is close to zero.", 2);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,146) = false;
#endif
DYNSetAuxString(did_, "DC supply voltage of inverter is close to zero.", 3);
DYNSetAuxString(did_, "Supply voltage is close to zero, demanded power is limited.",
   4);
DYNSetAuxString(did_, "Supply voltage is close to zero, demanded power is limited.",
   5);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,183) = true;
DYNX(W_,184) = 2;
DYNX(W_,188) = false;
DYNX(W_,224) = false;
DYNX(W_,226) = false;
DYNX(W_,228) = false;
DYNX(W_,254) = false;
DYNX(W_,255) = false;
DYNX(W_,256) = true;
#endif
DYNSetAuxString(did_, "Supply voltage of machine is close to zero.", 7);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,262) = false;
#endif
DYNSetAuxString(did_, "Supply voltage of machine is close to zero.", 8);
DYNSetAuxString(did_, "Supply voltage is close to zero, demanded power is limited.",
   9);
DYNSetAuxString(did_, "Supply voltage is close to zero, demanded power is limited.",
   10);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,322) = true;
DYNX(W_,323) = 2;
DYNX(W_,327) = false;
DYNX(W_,359) = false;
DYNX(W_,364) = 3;
DYNX(W_,3) = false;
DYNX(W_,5) = 1;
DYNX(W_,6) = 2;
DYNX(W_,9) = false;
memcpy(&DYNX(W_,141), &DymArrays1, sizeof(double)*5);
DYNX(W_,178) = true;
memcpy(&DYNX(W_,257), &DymArrays1, sizeof(double)*5);
DYNX(W_,317) = true;
DYNX(W_,244) = 0;
DYNX(W_,247) = 0;
DYNX(W_,295) = 0;
DYNX(W_,344) = 0;
DYNX(W_,61) = 0;
DYNX(W_,30) = 0;
DYNX(W_,76) = 0;
DYNX(W_,336) = 0;
DYNX(W_,232) = 0;
DYNX(W_,135) = 0;
DYNX(W_,197) = 0;
DYNX(W_,203) = 0;
DYNX(W_,131) = 0;
DYNX(W_,348) = 0;
DYNX(W_,199) = 0;
DYNX(W_,338) = 0;
DYNX(W_,234) = 0;
DYNX(W_,137) = 0;
DYNX(W_,205) = 0;
DYNX(W_,133) = 0;
DYNX(W_,350) = 0;
DYNX(W_,78) = 0;
DYNX(W_,80) = 0;
DYNX(W_,242) = 0.0;
DYNX(W_,290) = 0;
DYNX(W_,294) = 0.0;
DYNX(W_,368) = 0;
DYNX(W_,29) = 0.0;
DYNX(W_,67) = 0.0;
DYNX(W_,367) = false;
DYNX(W_,162) = 0.0;
DYNX(W_,180) = 0.0;
DYNX(W_,198) = 0.0;
DYNX(W_,209) = 0.0;
DYNX(W_,210) = 0.0;
DYNX(W_,204) = 0.0;
DYNX(W_,208) = 0.0;
DYNX(W_,207) = 0.0;
DYNX(W_,206) = 0.0;
DYNX(W_,132) = 0.0;
DYNX(W_,136) = 0.0;
DYNX(W_,128) = 0.0;
DYNX(W_,130) = 0.0;
DYNX(W_,245) = 0.0;
DYNX(W_,301) = 0.0;
DYNX(W_,319) = 0.0;
DYNX(W_,337) = 0.0;
DYNX(W_,339) = 0.0;
DYNX(W_,282) = 0.0;
DYNX(W_,296) = 0.0;
DYNX(W_,233) = 0.0;
DYNX(W_,238) = 0.0;
DYNX(W_,237) = 0.0;
DYNX(W_,236) = 0.0;
DYNX(W_,243) = 0.0;
DYNX(W_,231) = 0.0;
DYNX(W_,248) = 0.0;
DYNX(W_,91) = 0.0;
DYNX(W_,349) = 0.0;
DYNX(W_,354) = 0.0;
DYNX(W_,353) = 0.0;
DYNX(W_,352) = 0.0;
DYNX(W_,355) = 0.0;
DYNX(W_,85) = 0.0;
DYNX(W_,79) = 0.0;
DYNX(W_,84) = 0.0;
DYNX(W_,83) = 0.0;
DYNX(W_,82) = 0.0;
DYNX(W_,86) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
AssertModelica(DYNX(DP_,25) >= DYNX(DP_,26),"partial_Brakes.limiter.uMax >= partial_Brakes.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,25), true, 0)),") < uMin (="),Real2String2(DYNX(DP_,26),
   true, 0)),")"));
PopAllMarks();
BoundParameterSection
DYNX(W_,8) = DYNX(DP_,14);
InitialBoundSection
DYNX(DYNhelp,0) = (PushModelContext(1,"Modelica.Utilities.Strings.isEmpty(partial_Driver.combiTimeTable.fileName)")
  Modelica_Utilities_Strings_isEmpty("NoName"));
PopModelContext();
DYNX(DYNhelp,1) = divinvGuarded(DYNX(W_,7),"partial_Driver.combiTimeTable.timeScale");
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTimeTable((if partial_Driver.combiTimeTable.tableOnFile then partial_Driver.combiTimeTable.tableName else \"NoName\"), (if partial_Driver.combiTimeTable.tableOnFile and partial_Driver.combiTimeTable.fileName <> \"NoName\" and  not Modelica.Utilities.Strings.isEmpty(partial_Driver.combiTimeTable.fileName) then partial_Driver.combiTimeTable.fileName else \"NoName\"), ...")
    Modelica_Blocks_Types_ExternalCombiTimeTable_M(IF DYNX(W_,3) THEN "NoName"
     ELSE "NoName", IF DYNX(W_,3) AND (strcmp("NoName", "NoName")!=0) AND  NOT 
    DYNX(DYNhelp,0) THEN "NoName" ELSE "NoName", RealTemporaryDense( 
    &DYNX(DP_,0), 2, 6, 2), DYNX(DYNhelp,1)*DYNX(DP_,14), IntegerTemporaryDense( 
    &DYNX(W_,4), 1, 1), (Integer)(DYNX(W_,5)), (Integer)(DYNX(W_,6)), 
    DYNX(DYNhelp,1)*DYNX(W_,8), (Integer)(IF DYNX(W_,5) == 1 THEN DYNX(DP_,15)
     ELSE IF DYNX(W_,5) == 3 THEN 1 ELSE 3), (Integer)(IF DYNX(W_,3) THEN 
    DYNX(DP_,12) ELSE false), 0, 1));
  DYNX(W_,15) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
BoundParameterSection
DYNX(W_,12) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTimeTableTmin(\npartial_Driver.combiTimeTable.tableID)")
  Modelica_Blocks_Tables_Internal_getTimeTableTmin_M(DymStruc0_construct(
  (Integer)(DYNX(W_,15)))));
PopModelContext();
DYNX(W_,10) = DYNX(W_,12)*DYNX(W_,7);
DYNX(W_,13) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTimeTableTmax(\npartial_Driver.combiTimeTable.tableID)")
  Modelica_Blocks_Tables_Internal_getTimeTableTmax_M(DymStruc0_construct(
  (Integer)(DYNX(W_,15)))));
PopModelContext();
DYNX(W_,11) = DYNX(W_,13)*DYNX(W_,7);
DYNX(W_,14) = DYNX(DP_,13);
DYNX(W_,21) =  -DYNX(DP_,18);
AssertModelica(DYNX(DP_,18) >= DYNX(W_,21),"partial_Controller.limiter.uMax >= partial_Controller.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,18), true, 0)),") < uMin (="),Real2String2(DYNX(W_,21), 
  true, 0)),")"));
PopAllMarks();
DYNX(W_,94) = DYNX(DP_,41);
DYNX(W_,95) = DYNX(DP_,40);
DYNX(W_,96) = DYNX(DP_,36);
DYNX(W_,97) = DYNX(W_,94);
DYNX(W_,98) = DYNX(W_,95);
DYNX(W_,99) = DYNX(W_,96);
DYNX(W_,102) = DYNX(W_,97);
DYNX(W_,103) = DYNX(W_,98);
DYNX(W_,104) = DYNX(W_,99);
DYNX(W_,105) =  -DYNX(W_,104);
DYNX(W_,113) = DYNX(DP_,43);
DYNX(W_,115) = DYNX(W_,102);
DYNX(W_,118) = DYNX(W_,104);
DYNX(W_,119) = DYNX(W_,105);
AssertModelica(DYNX(W_,118) >= DYNX(W_,119),"partial_PMSM.eTraction.controller.coreElement.PID.limiter.uMax >= partial_PMSM.eTraction.controller.coreElement.PID.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(W_,118), true, 0)),") < uMin (="),Real2String2(DYNX(W_,119),
   true, 0)),")"));
PopAllMarks();
DYNX(W_,126) = DYNX(DP_,47);
DYNX(W_,147) = DYNX(DP_,60);
DYNX(W_,149) = DYNX(W_,141);
DYNX(W_,150) = DYNX(W_,142);
DYNX(W_,151) = DYNX(DP_,62);
DYNX(W_,152) = DYNX(W_,143);
DYNX(W_,153) = DYNX(W_,144);
DYNX(W_,154) = DYNX(W_,145);
DYNX(W_,157) = DYNX(DP_,59);
DYNX(W_,164) = DYNX(DP_,66);
DYNX(W_,165) = DYNX(W_,149);
DYNX(W_,166) = DYNX(W_,150);
DYNX(W_,167) = DYNX(W_,151);
DYNX(W_,168) = DYNX(W_,152);
DYNX(W_,169) = DYNX(W_,153);
DYNX(W_,170) = DYNX(W_,154);
DYNX(W_,172) = DYNX(DP_,67);
DYNX(W_,173) = DYNX(DP_,68);
DYNX(W_,174) = DYNX(DP_,69);
DYNX(W_,176) = DYNX(W_,157);
DYNX(W_,177) = DYNX(W_,170);
DYNX(W_,179) = DYNX(W_,169);
DYNX(DYNhelp,2) = ModelicaStrings_length("Supply voltage is close to zero, demanded power is limited.");
DYNSetAuxStringD(did_, IF ModelicaStrings_length("Supply voltage is close to zero, demanded power is limited.")
   > 0 THEN StringAdd(":\n  ","Supply voltage is close to zero, demanded power is limited.")
   ELSE "", 6, 0);
PopAllMarks();
AssertModelica(fabs(DYNX(DP_,35)) >= 0.1,"abs(simplePower.constantVoltage.V) >= 0.1",
   StringAdd("Division by zero occured in component stdMechEV.partial_PMSM.eTraction.inverter.coreElement.lossPower.divNoZero",
  IF ModelicaStrings_length("Supply voltage is close to zero, demanded power is limited.")
   > 0 THEN StringAdd(":\n  ","Supply voltage is close to zero, demanded power is limited.")
   ELSE ""));
PopAllMarks();
DYNX(W_,182) = DYNX(W_,164);
DYNX(W_,190) = 0.5*DYNX(W_,165);
DYNX(W_,191) = DYNX(W_,165);
DYNX(W_,192) = DYNX(W_,167);
DYNX(W_,194) = DYNX(W_,166);
DYNX(W_,195) = 1.1*DYNX(W_,166);
DYNX(W_,196) = DYNX(W_,167);
DYNX(DYNhelp,3) = divinvGuarded(DYNX(W_,147),"partial_PMSM.eTraction.inverter.coreElement.eta");
DYNX(W_,201) = 1-DYNX(DYNhelp,3);
DYNX(W_,221) = DYNX(DP_,76);
DYNX(W_,222) = DYNX(DP_,77);
DYNX(W_,252) = DYNX(DP_,37);
DYNX(W_,253) = DYNX(DP_,36);
DYNX(W_,263) = DYNX(DP_,80);
DYNX(W_,265) = DYNX(DP_,81);
DYNX(W_,266) = DYNX(DP_,82);
DYNX(W_,267) = DYNX(W_,252);
DYNX(W_,268) = DYNX(W_,253);
DYNX(W_,271) = DYNX(DP_,83);
DYNX(W_,273) = DYNX(W_,257);
DYNX(W_,274) = DYNX(W_,258);
DYNX(W_,275) = DYNX(DP_,85);
DYNX(W_,276) = DYNX(W_,259);
DYNX(W_,277) = DYNX(W_,260);
DYNX(W_,278) = DYNX(W_,261);
DYNX(W_,281) = DYNX(DP_,79);
DYNX(W_,284) = DYNX(W_,266);
DYNX(W_,285) = DYNX(W_,267);
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
DYNX(W_,286) = DYNX(W_,268);
DYNX(DYNhelp,4) = divinvGuarded(DYNX(W_,286),"partial_PMSM.eTraction.machine.coreElement.limitDesiredTorque.tau_max");
DYNX(W_,287) = DYNX(DYNhelp,4)*DYNX(W_,285);
DYNX(W_,291) = DYNX(W_,263);
DYNX(W_,303) = DYNX(DP_,89);
DYNX(W_,304) = DYNX(W_,273);
DYNX(W_,305) = DYNX(W_,274);
DYNX(W_,306) = DYNX(W_,275);
DYNX(W_,307) = DYNX(W_,276);
DYNX(W_,308) = DYNX(W_,277);
DYNX(W_,309) = DYNX(W_,278);
DYNX(W_,311) = DYNX(DP_,90);
DYNX(W_,312) = DYNX(DP_,91);
DYNX(W_,313) = DYNX(DP_,92);
DYNX(W_,315) = DYNX(W_,281);
DYNX(W_,316) = DYNX(W_,309);
DYNX(W_,318) = DYNX(W_,308);
DYNX(DYNhelp,5) = ModelicaStrings_length("Supply voltage is close to zero, demanded power is limited.");
DYNSetAuxStringD(did_, IF ModelicaStrings_length("Supply voltage is close to zero, demanded power is limited.")
   > 0 THEN StringAdd(":\n  ","Supply voltage is close to zero, demanded power is limited.")
   ELSE "", 11, 0);
PopAllMarks();
AssertModelica(fabs(DYNX(DP_,35)) >= 0.1,"abs(simplePower.constantVoltage.V) >= 0.1",
   StringAdd("Division by zero occured in component stdMechEV.partial_PMSM.eTraction.machine.coreElement.electricPowerSource.divNoZero",
  IF ModelicaStrings_length("Supply voltage is close to zero, demanded power is limited.")
   > 0 THEN StringAdd(":\n  ","Supply voltage is close to zero, demanded power is limited.")
   ELSE ""));
PopAllMarks();
DYNX(W_,321) = DYNX(W_,303);
DYNX(W_,329) = 0.5*DYNX(W_,304);
DYNX(W_,330) = DYNX(W_,304);
DYNX(W_,331) = DYNX(W_,306);
DYNX(W_,333) = DYNX(W_,305);
DYNX(W_,334) = 1.1*DYNX(W_,305);
DYNX(W_,335) = DYNX(W_,306);
DYNX(W_,340) = DYNX(W_,271);
DYNX(DYNhelp,6) = divinvGuarded(DYNX(W_,340),"partial_PMSM.eTraction.machine.coreElement.compute_P_el.eta");
DYNX(W_,342) =  -DYNX(DYNhelp,6)*(1-DYNX(W_,340));
DYNX(DYNhelp,7) = divinvGuarded(DYNX(W_,103),"partial_PMSM.eTraction.controller.coreElement.PID.Ti");
DYNX(W_,361) = DYNX(DYNhelp,7);
DYNX(W_,365) = DYNX(DP_,48);
DYNX(W_,371) = divinvGuarded(DYNX(W_,102)*DYNX(DP_,45),"partial_PMSM.eTraction.controller.coreElement.PID.k*partial_PMSM.eTraction.controller.coreElement.PID.Ni");
BoundParameterConstantSection
DYNX(W_,49) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({partial_Brakes.brake.mue_pos[1, 1]}, {partial_Brakes.brake.mue_pos[1, 2]}, 0, 1)")
  Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,19), 1, 1), 
  RealTemporaryDense( &DYNX(DP_,20), 1, 1), 0, 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,326) = IF DYNX(DP_,35) >= 0 THEN DYNX(DP_,35) ELSE  -DYNX(DP_,35);
DYNX(W_,328) = IF DYNX(W_,326) <= 0.5 THEN DYNX(DP_,96) ELSE IF DYNX(W_,326) > 
  0.5 AND DYNX(W_,326) < 1 THEN DYNX(DP_,96)+(DYNX(W_,331)-DYNX(DP_,96))*sqr(sin
  (3.141592653589793*(DYNX(W_,326)-0.5))) ELSE DYNX(W_,331);
DYNX(W_,332) = IF DYNX(W_,326) <= 100000.0 THEN DYNX(W_,335) ELSE IF 
  DYNX(W_,326) > 100000.0 AND DYNX(W_,326) < 110000.00000000001 THEN 
  DYNX(W_,335)+(DYNX(DP_,97)-DYNX(W_,335))*sqr(sin(0.00015707963267948944*(
  DYNX(W_,326)-100000.0))) ELSE DYNX(DP_,97);
DYNX(W_,299) = RealBmin(DYNX(W_,328), DYNX(W_,332));
AssertModelica((PushModelContext(1,"Modelica.Math.isEqual(partial_PMSM.eTraction.machine.coreElement.electricPowerSource.i_limit, partial_PMSM.eTraction.machine.coreElement.electricPowerSource.I_max, 0)")
  Modelica_Math_isEqual(DYNX(W_,299), DYNX(W_,306), 0)),"Modelica.Math.isEqual(partial_PMSM.eTraction.machine.coreElement.electricPowerSource.i_limit, partial_PMSM.eTraction.machine.coreElement.electricPowerSource.I_max, 0)",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd(StringAdd("In 'stdMechEV.partial_PMSM.eTraction.machine.coreElement.electricPowerSource':",
  IF (PushModelContext(1,"Modelica.Math.isEqual(partial_PMSM.eTraction.machine.coreElement.electricPowerSource.limI_minV.y, partial_PMSM.eTraction.machine.coreElement.electricPowerSource.I_max, 0)")
  Modelica_Math_isEqual(DYNX(W_,328), DYNX(W_,306), 0)) THEN StringAdd(
  StringAdd(StringAdd(StringAdd("\n  Applied voltage v=",Real2StringFormat(
  DYNX(DP_,35), ".15g")),"V is above V_max="),"100000"),"V") ELSE StringAdd(
  StringAdd(StringAdd(StringAdd("\n  Applied voltage v=",Real2StringFormat(
  DYNX(DP_,35), ".15g")),"V is below V_min="),"1"),"V")),"\n  Allowed current is reduced to "),
  Real2String2(DYNX(W_,299), true, 0)),"A (from I_max="),Real2String2(
  DYNX(W_,306), true, 0)),"A)"),""),"\n  Reasons can be low supply voltage or too strict limits 'V_min' or 'V_max'"),
  IF (PushModelContext(1,"Modelica.Math.isEqual(partial_PMSM.eTraction.machine.coreElement.electricPowerSource.limI_minV.y, partial_PMSM.eTraction.machine.coreElement.electricPowerSource.I_max, 0)")
  Modelica_Math_isEqual(DYNX(W_,328), DYNX(W_,306), 0)) THEN "\n  In case of numerical issues try decreasing 'V_max'"
   ELSE "\n  In case of numerical issues try increasing 'V_min'"));
PopAllMarks();
DYNX(W_,324) = fabs(DYNX(W_,299));
DYNX(W_,325) =  -DYNX(W_,324);
DYNX(W_,187) = IF DYNX(DP_,35) >= 0 THEN DYNX(DP_,35) ELSE  -DYNX(DP_,35);
DYNX(W_,189) = IF DYNX(W_,187) <= 0.5 THEN DYNX(DP_,71) ELSE IF DYNX(W_,187) > 
  0.5 AND DYNX(W_,187) < 1 THEN DYNX(DP_,71)+(DYNX(W_,192)-DYNX(DP_,71))*sqr(sin
  (3.141592653589793*(DYNX(W_,187)-0.5))) ELSE DYNX(W_,192);
DYNX(W_,193) = IF DYNX(W_,187) <= 100000.0 THEN DYNX(W_,196) ELSE IF 
  DYNX(W_,187) > 100000.0 AND DYNX(W_,187) < 110000.00000000001 THEN 
  DYNX(W_,196)+(DYNX(DP_,72)-DYNX(W_,196))*sqr(sin(0.00015707963267948944*(
  DYNX(W_,187)-100000.0))) ELSE DYNX(DP_,72);
DYNX(W_,160) = RealBmin(DYNX(W_,189), DYNX(W_,193));
AssertModelica((PushModelContext(1,"Modelica.Math.isEqual(partial_PMSM.eTraction.inverter.coreElement.lossPower.i_limit, partial_PMSM.eTraction.inverter.coreElement.lossPower.I_max, 0)")
  Modelica_Math_isEqual(DYNX(W_,160), DYNX(W_,167), 0)),"Modelica.Math.isEqual(partial_PMSM.eTraction.inverter.coreElement.lossPower.i_limit, partial_PMSM.eTraction.inverter.coreElement.lossPower.I_max, 0)",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd(StringAdd("In 'stdMechEV.partial_PMSM.eTraction.inverter.coreElement.lossPower':",
  IF (PushModelContext(1,"Modelica.Math.isEqual(partial_PMSM.eTraction.inverter.coreElement.lossPower.limI_minV.y, partial_PMSM.eTraction.inverter.coreElement.lossPower.I_max, 0)")
  Modelica_Math_isEqual(DYNX(W_,189), DYNX(W_,167), 0)) THEN StringAdd(
  StringAdd(StringAdd(StringAdd("\n  Applied voltage v=",Real2StringFormat(
  DYNX(DP_,35), ".15g")),"V is above V_max="),"100000"),"V") ELSE StringAdd(
  StringAdd(StringAdd(StringAdd("\n  Applied voltage v=",Real2StringFormat(
  DYNX(DP_,35), ".15g")),"V is below V_min="),"1"),"V")),"\n  Allowed current is reduced to "),
  Real2String2(DYNX(W_,160), true, 0)),"A (from I_max="),Real2String2(
  DYNX(W_,167), true, 0)),"A)"),""),"\n  Reasons can be low supply voltage or too strict limits 'V_min' or 'V_max'"),
  IF (PushModelContext(1,"Modelica.Math.isEqual(partial_PMSM.eTraction.inverter.coreElement.lossPower.limI_minV.y, partial_PMSM.eTraction.inverter.coreElement.lossPower.I_max, 0)")
  Modelica_Math_isEqual(DYNX(W_,189), DYNX(W_,167), 0)) THEN "\n  In case of numerical issues try decreasing 'V_max'"
   ELSE "\n  In case of numerical issues try increasing 'V_min'"));
PopAllMarks();
DYNX(W_,185) = fabs(DYNX(W_,160));
DYNX(W_,186) =  -DYNX(W_,185);
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,16) = 0;
DYNX(W_,17) = 0;
DYNX(W_,35) = false;
DYNX(W_,36) = false;
DYNX(W_,37) = false;
DYNX(W_,43) = 3;
DYNX(W_,64) = 0;
DYNX(W_,66) = 0;
DYNX(W_,68) = 0;
DYNX(W_,69) = 0;
DYNX(W_,343) = 0;
DYNX(F_,1) = 0;
#endif
InitialSection
InitialStartSection
InitialStartSection2
DYNX(X_,2) = DYNX(W_,365);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,43);
DYNX(Aux_,1) = DYNX(W_,36);
DYNX(Aux_,2) = DYNX(W_,35);
DYNX(Aux_,4) = DYNX(W_,17);
DYNX(Aux_,3) = DYNX(W_,16);
InitialSection
InitialSection2
DYNX(W_,18) = DYNTime;
InitialBoundSection
DYNX(W_,17) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getNextTimeEvent(\npartial_Driver.combiTimeTable.tableID, \npartial_Driver.combiTimeTable.timeScaled)")
  Modelica_Blocks_Tables_Internal_getNextTimeEvent_M(DymStruc0_construct(
  (Integer)(DYNX(W_,15))), DYNX(W_,18)));
PopModelContext();
InitialSection2
DYNX(W_,16) = IF Less(DYNX(W_,17),"partial_Driver.combiTimeTable.nextTimeEventScaled",
   1E+60,"1E+60", 0) THEN DYNX(W_,17) ELSE 1E+60;
DYNX(X_,1) = DYNX(W_,64);
DYNX(X_,2) = DYNX(W_,365);
DYNX(W_,239) =  -(IF DYNX(W_,284) THEN (IF Less(fabs(DYNX(X_,1)),
  "abs(partial_Chassis.damper.w_rel)", DYNX(W_,287),"partial_PMSM.eTraction.machine.coreElement.limitDesiredTorque.characteristicSpeed",
   1) THEN DYNX(W_,286) ELSE divGuarded(DYNX(W_,285),"partial_PMSM.eTraction.machine.coreElement.limitDesiredTorque.P_max",
  fabs(DYNX(X_,1)),"abs(partial_Chassis.damper.w_rel)")) ELSE 1E+60);
DYNX(W_,2) = DYNX(W_,14)+(PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTimeTableValue(\npartial_Driver.combiTimeTable.tableID, \n1, \npartial_Driver.combiTimeTable.timeScaled, \npartial_Driver.combiTimeTable.nextTimeEventScaled, \npartial_Driver.combiTimeTable.nextTimeEventScaled_.start)")
  Modelica_Blocks_Tables_Internal_getTimeTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,15))), 1, DYNX(W_,18), DYNX(W_,17), DYNX(Aux_,4)));
PopModelContext();
DYNX(W_,0) = DYNX(DP_,16)*DYNX(W_,2);
DYNX(W_,346) = DYNX(W_,0)-DYNX(X_,1);
DYNX(W_,92) = IF Greater(DYNX(W_,346),"partial_PMSM.motorSwitch.feedback", 0,"0",
   2) THEN DYNX(W_,0) ELSE DYNX(X_,1);
DYNX(W_,112) = DYNX(W_,113)*DYNX(W_,92)+DYNX(DP_,51)*DYNX(X_,1);
DYNX(W_,114) = DYNX(DP_,52)*DYNX(W_,112);
DYNX(W_,116) = DYNX(DP_,53)*DYNX(W_,114)+DYNX(DP_,54)*DYNX(DP_,56)+DYNX(DP_,55)*
  DYNX(X_,2);
DYNX(W_,117) = DYNX(W_,115)*DYNX(W_,116);
DYNX(W_,123) = DYNX(DP_,58)*DYNX(W_,117)+DYNX(W_,126)*DYNX(DP_,57);
DYNX(W_,93) = homotopy(IF GreaterS(DYNX(W_,123),"partial_PMSM.eTraction.controller.coreElement.PID.limiter.u",
   DYNX(W_,118),"partial_PMSM.eTraction.controller.coreElement.PID.limiter.uMax",
   3) THEN DYNX(W_,118) ELSE IF LessS(DYNX(W_,123),"partial_PMSM.eTraction.controller.coreElement.PID.limiter.u",
   DYNX(W_,119),"partial_PMSM.eTraction.controller.coreElement.PID.limiter.uMin",
   4) THEN DYNX(W_,119) ELSE DYNX(W_,123), DYNX(W_,123));
DYNX(W_,288) = RealBmin( -DYNX(W_,239), fabs(DYNX(W_,93)));
DYNX(W_,240) = DYNX(W_,288)*(IF DYNX(W_,93) > 0 THEN 1 ELSE IF DYNX(W_,93) < 0
   THEN -1 ELSE 0);
DYNX(W_,357) = DYNX(W_,0)-DYNX(X_,1);
DYNX(W_,358) = IF DYNX(W_,357) > 0 THEN 1 ELSE IF DYNX(W_,357) < 0 THEN -1 ELSE 0;
DYNX(W_,360) = DYNX(DP_,101)*DYNX(DP_,103)+DYNX(DP_,102)*DYNX(W_,358);
DYNX(W_,20) = DYNX(W_,360)*DYNX(W_,357);
DYNX(W_,19) = homotopy(IF GreaterS(DYNX(W_,20),"partial_Controller.brakeAllowance",
   DYNX(DP_,18),"partial_Controller.limiter.uMax", 5) THEN DYNX(DP_,18) ELSE IF 
  LessS(DYNX(W_,20),"partial_Controller.brakeAllowance", DYNX(W_,21),
  "partial_Controller.limiter.uMin", 6) THEN DYNX(W_,21) ELSE DYNX(W_,20), 
  DYNX(W_,20));
DYNX(W_,51) = homotopy(IF GreaterS(DYNX(W_,19),"partial_Controller.MechanicalBrakeRequest",
   DYNX(DP_,25),"partial_Brakes.limiter.uMax", 7) THEN DYNX(DP_,25) ELSE IF 
  LessS(DYNX(W_,19),"partial_Controller.MechanicalBrakeRequest", DYNX(DP_,26),
  "partial_Brakes.limiter.uMin", 8) THEN DYNX(DP_,26) ELSE DYNX(W_,19), 
  DYNX(W_,19));
DYNX(W_,293) = DYNX(W_,240)*DYNX(X_,1);
DYNX(W_,241) = DYNX(DP_,93)*DYNX(W_,293);

{ /* Non-linear system of equations to solve. */
/* Tag: initialization.nonlinear[1] */
const char*const varnames_[]={"partial_PMSM.eTraction.machine.coreElement.compute_P_el.losses.u"};
const double nominal_[]={1};
NonLinearSystemOfEquations(Jacobian__, residue__, x__, 1, 0, 0, 1, -2, 
  DYNX(DYNhelp,8), 35, DYNX(did_->helpvari_vec,0), 23);
SetInitVectorSimple(x__, 1, DYNX(W_,343), 0, 0);
Residues;
  DYNX(W_,341) = DYNX(W_,342)*DYNX(W_,343);
  DYNX(W_,283) = DYNX(DP_,98)*DYNX(W_,241)+DYNX(DP_,99)*DYNX(W_,341);
SetVector(residue__, 1, DYNX(W_,343)-RealBmin(DYNX(W_,241), DYNX(W_,283)));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
SetMatrixLeading(Jacobian__, 1, 1, 1, 1.0-DYNX(DP_,99)*(IF DYNX(W_,241) < 
  DYNX(W_,283) THEN 0.0 ELSE 1.0)*DYNX(W_,342));

SolveNonLinearSystemOfEquationsInit(Jacobian__, 0, 0, 0, residue__, x__,"Tag: initialization.nonlinear[1]");
DYNX(W_,343) = GetVector(x__, 1);
EndNonLinearSystemOfEquationsInit(residue__, x__, 1);
 /* End of Non-Linear Equation Block */ }



DYNX(W_,300) = IF fabs(DYNX(DP_,35)) < 0.1 THEN (IF DYNX(DP_,35) >= 0 THEN 10.0*
  DYNX(W_,283) ELSE (-10.0)*DYNX(W_,283)) ELSE divGuarded(DYNX(W_,283),
  "partial_PMSM.eTraction.machine.coreElement.P_el",DYNX(DP_,35),
  "simplePower.constantVoltage.V");
DYNX(W_,129) =  -homotopy(IF DYNX(W_,300) > DYNX(W_,324) THEN DYNX(W_,324) ELSE 
  IF DYNX(W_,300) < DYNX(W_,325) THEN DYNX(W_,325) ELSE DYNX(W_,300), 
  DYNX(W_,300));
DYNX(W_,211) = DYNX(DP_,35)*DYNX(W_,129);

{ /* Non-linear system of equations to solve. */
/* Tag: initialization.nonlinear[2] */
const char*const varnames_[]={"partial_PMSM.eTraction.inverter.coreElement.P_DC"};
const double nominal_[]={1};
NonLinearSystemOfEquations(Jacobian__, residue__, x__, 1, 0, 0, 2, -2, 
  DYNX(DYNhelp,43), 35, DYNX(did_->helpvari_vec,23), 23);
SetInitVectorSimple(x__, 1, DYNX(W_,212), 1, 0.0);
Residues;
  DYNX(W_,200) = RealBmin(DYNX(W_,211), DYNX(W_,212));
  DYNX(W_,202) = DYNX(W_,201)*DYNX(W_,200);
SetVector(residue__, 1, DYNX(W_,212)-(DYNX(DP_,73)*DYNX(W_,211)+DYNX(DP_,74)*
  DYNX(W_,202)));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
SetMatrixLeading(Jacobian__, 1, 1, 1, 1.0-DYNX(W_,201)*DYNX(DP_,74)*(IF 
  DYNX(W_,211) < DYNX(W_,212) THEN 0.0 ELSE 1.0));

SolveNonLinearSystemOfEquationsInit(Jacobian__, 0, 0, 0, residue__, x__,"Tag: initialization.nonlinear[2]");
DYNX(W_,212) = GetVector(x__, 1);
EndNonLinearSystemOfEquationsInit(residue__, x__, 2);
 /* End of Non-Linear Equation Block */ }



DYNX(W_,161) = IF fabs(DYNX(DP_,35)) < 0.1 THEN (IF DYNX(DP_,35) >= 0 THEN 10.0*
  DYNX(W_,202) ELSE (-10.0)*DYNX(W_,202)) ELSE divGuarded(DYNX(W_,202),
  "partial_PMSM.eTraction.inverter.coreElement.losses.y",DYNX(DP_,35),
  "simplePower.constantVoltage.V");
DYNX(W_,159) = homotopy(IF DYNX(W_,161) > DYNX(W_,185) THEN DYNX(W_,185) ELSE 
  IF DYNX(W_,161) < DYNX(W_,186) THEN DYNX(W_,186) ELSE DYNX(W_,161), 
  DYNX(W_,161));
InitialSection
InitialSection2
DYNX(W_,43) = DYNX(Aux_,0);
DYNX(W_,36) = DYNX(Aux_,1);
DYNX(W_,35) = DYNX(Aux_,2);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(F_,0) = DYNX(X_,1);
DYNX(W_,239) =  -(IF DYNX(W_,284) THEN (IF Less(fabs(DYNX(X_,1)),
  "abs(partial_Chassis.damper.w_rel)", DYNX(W_,287),"partial_PMSM.eTraction.machine.coreElement.limitDesiredTorque.characteristicSpeed",
   1) THEN DYNX(W_,286) ELSE divGuarded(DYNX(W_,285),"partial_PMSM.eTraction.machine.coreElement.limitDesiredTorque.P_max",
  fabs(DYNX(X_,1)),"abs(partial_Chassis.damper.w_rel)")) ELSE 1E+60);
DYNX(W_,18) = DYNTime;
beginwhenBlock
whenModelica(GreaterEqualTimeMinor(PRE(DYNX(W_,16), 3), 0), 0) 
  DYNX(W_,17) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getNextTimeEvent(\npartial_Driver.combiTimeTable.tableID, \npartial_Driver.combiTimeTable.timeScaled)")
    Modelica_Blocks_Tables_Internal_getNextTimeEvent_M(DymStruc0_construct(
    (Integer)(DYNX(W_,15))), DYNX(W_,18)));
  PopModelContext();
endwhenModelica()
endwhenBlock


DYNX(DYNhelp,78) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTimeTableValue(\npartial_Driver.combiTimeTable.tableID, \n1, \npartial_Driver.combiTimeTable.timeScaled, \npartial_Driver.combiTimeTable.nextTimeEventScaled, \npre(partial_Driver.combiTimeTable.nextTimeEventScaled))")
  Modelica_Blocks_Tables_Internal_getTimeTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,15))), 1, DYNX(W_,18), DYNX(W_,17), PRE(DYNX(W_,17), 2)));
PopModelContext();
DYNX(W_,2) = DYNX(W_,14)+DYNX(DYNhelp,78);
DYNX(W_,0) = DYNX(DP_,16)*DYNX(W_,2);
DYNX(W_,346) = DYNX(W_,0)-DYNX(X_,1);
DYNX(W_,92) = IF Greater(DYNX(W_,346),"partial_PMSM.motorSwitch.feedback", 0,"0",
   2) THEN DYNX(W_,0) ELSE DYNX(X_,1);
DYNX(W_,112) = DYNX(W_,113)*DYNX(W_,92)+DYNX(DP_,51)*DYNX(X_,1);
DYNX(W_,114) = DYNX(DP_,52)*DYNX(W_,112);
DYNX(W_,116) = DYNX(DP_,53)*DYNX(W_,114)+DYNX(DP_,54)*DYNX(DP_,56)+DYNX(DP_,55)*
  DYNX(X_,2);
DYNX(W_,117) = DYNX(W_,115)*DYNX(W_,116);
DYNX(W_,123) = DYNX(DP_,58)*DYNX(W_,117)+DYNX(W_,126)*DYNX(DP_,57);
DYNX(W_,93) = IF GreaterS(DYNX(W_,123),"partial_PMSM.eTraction.controller.coreElement.PID.limiter.u",
   DYNX(W_,118),"partial_PMSM.eTraction.controller.coreElement.PID.limiter.uMax",
   3) THEN DYNX(W_,118) ELSE IF LessS(DYNX(W_,123),"partial_PMSM.eTraction.controller.coreElement.PID.limiter.u",
   DYNX(W_,119),"partial_PMSM.eTraction.controller.coreElement.PID.limiter.uMin",
   4) THEN DYNX(W_,119) ELSE DYNX(W_,123);
DYNX(DYNhelp,79) = fabs(DYNX(W_,93));
DYNX(W_,288) = RealBmin( -DYNX(W_,239), DYNX(DYNhelp,79));
DYNX(W_,240) = DYNX(W_,288)*(IF DYNX(W_,93) > 0 THEN 1 ELSE IF DYNX(W_,93) < 0
   THEN -1 ELSE 0);
DYNX(W_,357) = DYNX(W_,0)-DYNX(X_,1);
DYNX(W_,358) = IF DYNX(W_,357) > 0 THEN 1 ELSE IF DYNX(W_,357) < 0 THEN -1 ELSE 0;
DYNX(W_,360) = DYNX(DP_,101)*DYNX(DP_,103)+DYNX(DP_,102)*DYNX(W_,358);
DYNX(W_,20) = DYNX(W_,360)*DYNX(W_,357);
DYNX(W_,19) = IF GreaterS(DYNX(W_,20),"partial_Controller.brakeAllowance", 
  DYNX(DP_,18),"partial_Controller.limiter.uMax", 5) THEN DYNX(DP_,18) ELSE IF 
  LessS(DYNX(W_,20),"partial_Controller.brakeAllowance", DYNX(W_,21),
  "partial_Controller.limiter.uMin", 6) THEN DYNX(W_,21) ELSE DYNX(W_,20);
DYNX(W_,51) = IF GreaterS(DYNX(W_,19),"partial_Controller.MechanicalBrakeRequest",
   DYNX(DP_,25),"partial_Brakes.limiter.uMax", 7) THEN DYNX(DP_,25) ELSE IF 
  LessS(DYNX(W_,19),"partial_Controller.MechanicalBrakeRequest", DYNX(DP_,26),
  "partial_Brakes.limiter.uMin", 8) THEN DYNX(DP_,26) ELSE DYNX(W_,19);
DYNX(W_,50) = DYNX(DP_,23)*DYNX(W_,51);
DYNX(W_,33) = LessEqual(DYNX(W_,50),"partial_Brakes.brake.fn", 0,"0", 9);
DYNX(W_,31) = DYNX(W_,49)*DYNX(DP_,22)*DYNX(W_,50);
DYNX(W_,32) = DYNX(DP_,21)*DYNX(W_,31);
DYNX(W_,70) = DYNX(DP_,34)*DYNX(X_,1);

MixedSystemOfEquations(10, DYNX(DYNhelp,80))

   /* Linear system of equations to solve. */
  /* Tag: simulation.linear[1] */
  /* Introducing 1 common subexpressions used in 1 expressions */
  /* Of the common subexpressions 1 are reals, 0 are integers, and 0
     are booleans. */
  DYNX(DYNhelp,90) = DYNX(W_,291)+DYNX(DP_,100)+DYNX(DP_,30)+DYNX(DP_,29)*
    DYNX(DP_,31)*DYNX(DP_,29);
  DYNX(W_,34) = RememberSimple_(DYNX(W_,34), 0);
  SolveScalarLinearMixed((IF DYNX(W_,37) THEN 1.0 ELSE 0.0)+DYNX(DYNhelp,90)*(
    IF DYNX(W_,37) THEN 0.0 ELSE 1.0),"(if partial_Brakes.brake.locked then 1.0 else 0.0)+(partial_PMSM.eTraction.machine.coreElement.rotorInertia.J+partial_PMSM.inertia.J+partial_Chassis.inertia.J+partial_Chassis.idealRollingWheel.radius*(partial_Chassis.mass.m*partial_Chassis.idealRollingWheel.radius))*(if partial_Brakes.brake.locked then 0.0 else 1.0)",
      -((IF DYNX(W_,37) THEN 0.0 ELSE IF DYNX(W_,33) THEN 0 ELSE DYNX(DP_,22)*
    DYNX(W_,50)*(IF DYNX(W_,35) THEN (PushModelContext(1,"Modelica.Math.Vectors.interpolate({partial_Brakes.brake.mue_pos[1, 1]}, {partial_Brakes.brake.mue_pos[1, 2]}, partial_Chassis.damper.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,19), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,20), 1, 1), DYNX(X_,1), 1).yi0_0_0member)
     ELSE IF DYNX(W_,36) THEN  -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({partial_Brakes.brake.mue_pos[1, 1]}, {partial_Brakes.brake.mue_pos[1, 2]},  -partial_Chassis.damper.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,19), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,20), 1, 1),  -DYNX(X_,1), 1).yi0_0_0member)
     ELSE IF PRE(DYNX(W_,43), 1) == 1 THEN (PushModelContext(1,"Modelica.Math.Vectors.interpolate({partial_Brakes.brake.mue_pos[1, 1]}, {partial_Brakes.brake.mue_pos[1, 2]}, partial_Chassis.damper.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,19), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,20), 1, 1), DYNX(X_,1), 1).yi0_0_0member)
     ELSE  -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({partial_Brakes.brake.mue_pos[1, 1]}, {partial_Brakes.brake.mue_pos[1, 2]},  -partial_Chassis.damper.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,19), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,20), 1, 1),  -DYNX(X_,1), 1).yi0_0_0member)))+
    DYNX(DYNhelp,90)*(IF DYNX(W_,37) THEN 0 ELSE IF DYNX(W_,33) THEN 0.0 ELSE 
    IF DYNX(W_,35) THEN  -DYNX(W_,32) ELSE IF DYNX(W_,36) THEN DYNX(W_,32) ELSE 
    IF PRE(DYNX(W_,43), 1) == 1 THEN  -DYNX(W_,32) ELSE DYNX(W_,32))-
    DYNX(W_,240)+DYNX(W_,70))," -((if partial_Brakes.brake.locked then 0.0 else (if partial_Brakes.brake.free then 0 else partial_Brakes.brake.cgeo*partial_Brakes.brake.fn*(if partial_Brakes.brake.startForward then Modelica.Math.Vectors.interpolate({partial_Brakes.brake.mue_pos[1, 1]}, {partial_Brakes.brake.mue_pos[1, 2]}, partial_Chassis.damper.w_rel, 1) else (if partial_Brakes.brake.startBackward then  -Modelica.Math.Vecto...",
     DYNX(W_,34),"partial_Brakes.brake.sa");
  DYNX(W_,28) = IF DYNX(W_,37) THEN DYNX(W_,34) ELSE IF DYNX(W_,33) THEN 0 ELSE 
    DYNX(DP_,22)*DYNX(W_,50)*(IF DYNX(W_,35) THEN (PushModelContext(1,
    "Modelica.Math.Vectors.interpolate({partial_Brakes.brake.mue_pos[1, 1]}, {partial_Brakes.brake.mue_pos[1, 2]}, partial_Chassis.damper.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,19), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,20), 1, 1), DYNX(X_,1), 1).yi0_0_0member)
     ELSE IF DYNX(W_,36) THEN  -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({partial_Brakes.brake.mue_pos[1, 1]}, {partial_Brakes.brake.mue_pos[1, 2]},  -partial_Chassis.damper.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,19), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,20), 1, 1),  -DYNX(X_,1), 1).yi0_0_0member)
     ELSE IF PRE(DYNX(W_,43), 1) == 1 THEN (PushModelContext(1,"Modelica.Math.Vectors.interpolate({partial_Brakes.brake.mue_pos[1, 1]}, {partial_Brakes.brake.mue_pos[1, 2]}, partial_Chassis.damper.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,19), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,20), 1, 1), DYNX(X_,1), 1).yi0_0_0member)
     ELSE  -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({partial_Brakes.brake.mue_pos[1, 1]}, {partial_Brakes.brake.mue_pos[1, 2]},  -partial_Chassis.damper.w_rel, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( &DYNX(DP_,19), 1, 1), 
    RealTemporaryDense( &DYNX(DP_,20), 1, 1),  -DYNX(X_,1), 1).yi0_0_0member));
  PopAllMarks();
  DYNX(F_,1) = IF DYNX(W_,37) THEN 0 ELSE IF DYNX(W_,33) THEN DYNX(W_,34) ELSE 
    IF DYNX(W_,35) THEN DYNX(W_,34)-DYNX(W_,32) ELSE IF DYNX(W_,36) THEN 
    DYNX(W_,34)+DYNX(W_,32) ELSE IF PRE(DYNX(W_,43), 1) == 1 THEN DYNX(W_,34)-
    DYNX(W_,32) ELSE DYNX(W_,34)+DYNX(W_,32);
  DYNX(W_,90) = DYNX(W_,291)*DYNX(F_,1)-DYNX(W_,240);
  DYNX(W_,25) =  -(DYNX(DP_,100)*DYNX(F_,1)+DYNX(W_,90));
  DYNX(W_,26) = DYNX(W_,28)-DYNX(W_,25);
  DYNX(W_,62) = DYNX(DP_,30)*DYNX(F_,1)+DYNX(W_,26);
  DYNX(W_,57) =  -(DYNX(W_,70)+DYNX(W_,62));
  DYNX(W_,69) = DYNX(F_,1)*DYNX(DP_,29);
  DYNX(W_,59) =  -DYNX(DP_,31)*DYNX(W_,69);
   /* End of Equation Block */ 


  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,35),"partial_Brakes.brake.startForward", PRE(
    DYNX(W_,43), 1) == 0 AND (Greater(DYNX(W_,34),"partial_Brakes.brake.sa", 
    DYNX(W_,32),"partial_Brakes.brake.tau0_max", 10) OR PRE(DYNX(W_,35), 4) AND 
    Greater(DYNX(W_,34),"partial_Brakes.brake.sa", DYNX(W_,31),"partial_Brakes.brake.tau0",
     11)) OR PRE(DYNX(W_,43), 1) == -1 AND Greater(DYNX(X_,1),"partial_Chassis.damper.w_rel",
     DYNX(DP_,24),"partial_Brakes.brake.w_small", 12) OR initial() AND Greater(
    DYNX(X_,1),"partial_Chassis.damper.w_rel", 0,"0", 13));
  UpdateVariableNamed(DYNX(W_,36),"partial_Brakes.brake.startBackward", PRE(
    DYNX(W_,43), 1) == 0 AND (Less(DYNX(W_,34),"partial_Brakes.brake.sa",  -
    DYNX(W_,32)," -partial_Brakes.brake.tau0_max", 14) OR PRE(DYNX(W_,36), 5)
     AND Less(DYNX(W_,34),"partial_Brakes.brake.sa",  -DYNX(W_,31),
    " -partial_Brakes.brake.tau0", 15)) OR PRE(DYNX(W_,43), 1) == 1 AND Less(
    DYNX(X_,1),"partial_Chassis.damper.w_rel",  -DYNX(DP_,24)," -partial_Brakes.brake.w_small",
     16) OR initial() AND Less(DYNX(X_,1),"partial_Chassis.damper.w_rel", 0,"0",
     17));
  UpdateVariableNamed(DYNX(W_,37),"partial_Brakes.brake.locked",  NOT 
    DYNX(W_,33) AND  NOT (PRE(DYNX(W_,43), 1) == 1 OR DYNX(W_,35) OR PRE(
    DYNX(W_,43), 1) == -1 OR DYNX(W_,36)));
  MixedModeInit(8, DYNX(DYNhelp,91))
  ThetaMixedCross(0,10)
  ThetaMixedCross(1,11)
  ThetaMixedCross(2,12)
  ThetaMixedCross(3,13)
  ThetaMixedCross(4,14)
  ThetaMixedCross(5,15)
  ThetaMixedCross(6,16)
  ThetaMixedCross(7,17)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,69), 1)
  UpdateReal(DYNX(W_,59), 2)
  UpdateReal(DYNX(W_,57), 3)
  UpdateReal(DYNX(W_,62), 4)
  UpdateReal(DYNX(W_,26), 5)
  UpdateReal(DYNX(W_,34), 6)
  UpdateReal(DYNX(W_,28), 7)
  UpdateReal(DYNX(W_,25), 8)
  UpdateReal(DYNX(W_,90), 9)
  UpdateReal(DYNX(F_,1), 10)
EndMixedSystemOfEquations

DYNX(W_,370) = DYNX(DP_,107)*DYNX(W_,93)+DYNX(DP_,108)*DYNX(W_,123);
DYNX(W_,369) = DYNX(W_,371)*DYNX(W_,370);
DYNX(W_,366) = DYNX(DP_,104)*DYNX(W_,92)+DYNX(DP_,105)*DYNX(X_,1)+DYNX(DP_,106)*
  DYNX(W_,369);
DYNX(F_,2) = DYNX(W_,361)*DYNX(W_,366);

AcceptedSection1
DYNX(W_,43) = IF DYNX(W_,33) THEN 2 ELSE IF (PRE(DYNX(W_,43), 1) == 1 OR PRE(
  DYNX(W_,43), 1) == 2 OR DYNX(W_,35)) AND Greater(DYNX(X_,1),"partial_Chassis.damper.w_rel",
   0,"0", 13) THEN 1 ELSE IF (PRE(DYNX(W_,43), 1) == -1 OR PRE(DYNX(W_,43), 1)
   == 2 OR DYNX(W_,36)) AND Less(DYNX(X_,1),"partial_Chassis.damper.w_rel", 0,
  "0", 17) THEN -1 ELSE 0;
DYNX(W_,293) = DYNX(W_,240)*DYNX(X_,1);
DYNX(W_,241) = DYNX(DP_,93)*DYNX(W_,293);

{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[1] */
/* Introducing 6 common subexpressions used in 0 expressions */
/* Of the common subexpressions 5 are reals, 0 are integers, and 1
   are booleans. */
const char*const varnames_[]={"partial_PMSM.eTraction.machine.coreElement.compute_P_el.losses.u"};
const double nominal_[]={1};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 1, 0, 0, 3, -2, 1, 
  DYNX(DYNhelp,99), 37, DYNX(did_->helpvari_vec,46), 23);
NonLinearSystemSave(DYNX(W_,241), 0);
SetInitVectorNH(x__, 1, DYNX(W_,343), Remember_(DYNX(W_,343), 1));
Residues;
  DYNX(W_,341) = DYNX(W_,342)*DYNX(W_,343);
  DYNX(W_,283) = DYNX(DP_,98)*DYNX(W_,241)+DYNX(DP_,99)*DYNX(W_,341);
DYNX(DYNhelp,136) = RealBmin(DYNX(W_,241), DYNX(W_,283));
SetVector(residue__, 1, DYNX(W_,343)-DYNX(DYNhelp,136));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
SetMatrixLeading(Jacobian__, 1, 1, 1, 1.0-DYNX(DP_,99)*(IF DYNX(W_,241) < 
  DYNX(W_,283) THEN 0.0 ELSE 1.0)*DYNX(W_,342));

SolveNonLinearSystemOfEquationsNH(Jacobian__, 0, 0, 0, residue__, x__, 3, 
  "Tag: simulation.nonlinear[1]");
DYNX(W_,343) = GetVector(x__, 1);
EndNonLinearSystemOfEquationsNH(residue__, x__, 3);
 /* End of Non-Linear Equation Block */ }



if (NewParameters_) {
DYNX(DYNhelp,137) = fabs(DYNX(DP_,35));
}
DYNX(W_,300) = IF DYNX(DYNhelp,137) < 0.1 THEN (IF DYNX(DP_,35) >= 0 THEN 10.0*
  DYNX(W_,283) ELSE (-10.0)*DYNX(W_,283)) ELSE divGuarded(DYNX(W_,283),
  "partial_PMSM.eTraction.machine.coreElement.P_el",DYNX(DP_,35),
  "simplePower.constantVoltage.V");
DYNX(W_,129) =  -(IF DYNX(W_,300) > DYNX(W_,324) THEN DYNX(W_,324) ELSE IF 
  DYNX(W_,300) < DYNX(W_,325) THEN DYNX(W_,325) ELSE DYNX(W_,300));
DYNX(W_,211) = DYNX(DP_,35)*DYNX(W_,129);

{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[2] */
/* Introducing 5 common subexpressions and reusing 1 variables totally used in 0
   expressions */
/* Of the common subexpressions 5 are reals, 0 are integers, and 1
   are booleans. */
const char*const varnames_[]={"partial_PMSM.eTraction.inverter.coreElement.P_DC"};
const double nominal_[]={1};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 1, 0, 0, 4, -2, 1, 
  DYNX(DYNhelp,138), 37, DYNX(did_->helpvari_vec,69), 23);
NonLinearSystemSave(DYNX(W_,211), 0);
SetInitVectorNH(x__, 1, DYNX(W_,212), Remember_(DYNX(W_,212), 2));
Residues;
  DYNX(W_,200) = RealBmin(DYNX(W_,211), DYNX(W_,212));
  DYNX(W_,202) = DYNX(W_,201)*DYNX(W_,200);
SetVector(residue__, 1, DYNX(W_,212)-(DYNX(DP_,73)*DYNX(W_,211)+DYNX(DP_,74)*
  DYNX(W_,202)));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
SetMatrixLeading(Jacobian__, 1, 1, 1, 1.0-DYNX(W_,201)*DYNX(DP_,74)*(IF 
  DYNX(W_,211) < DYNX(W_,212) THEN 0.0 ELSE 1.0));

SolveNonLinearSystemOfEquationsNH(Jacobian__, 0, 0, 0, residue__, x__, 4, 
  "Tag: simulation.nonlinear[2]");
DYNX(W_,212) = GetVector(x__, 1);
EndNonLinearSystemOfEquationsNH(residue__, x__, 4);
 /* End of Non-Linear Equation Block */ }



DYNX(W_,161) = IF DYNX(DYNhelp,137) < 0.1 THEN (IF DYNX(DP_,35) >= 0 THEN 10.0*
  DYNX(W_,202) ELSE (-10.0)*DYNX(W_,202)) ELSE divGuarded(DYNX(W_,202),
  "partial_PMSM.eTraction.inverter.coreElement.losses.y",DYNX(DP_,35),
  "simplePower.constantVoltage.V");
DYNX(W_,159) = IF DYNX(W_,161) > DYNX(W_,185) THEN DYNX(W_,185) ELSE IF 
  DYNX(W_,161) < DYNX(W_,186) THEN DYNX(W_,186) ELSE DYNX(W_,161);
DYNX(W_,158) = DYNX(W_,159)*DYNX(DP_,35);
DYNX(W_,298) =  -DYNX(W_,129)*DYNX(DP_,35);
beginwhenBlock
whenModelica(GreaterEqualTimeMinor(PRE(DYNX(W_,16), 3), 0), 1) 
  DYNX(W_,16) = IF DYNX(W_,17) < 1E+60 THEN DYNX(W_,17) ELSE 1E+60;
endwhenModelica()
endwhenBlock



AssertModelica((PushModelContext(1,"Modelica.Math.isEqual(partial_PMSM.eTraction.inverter.coreElement.lossPower.i_des, partial_PMSM.eTraction.inverter.coreElement.lossPower.i, 0)")
  Modelica_Math_isEqual(DYNX(W_,161), DYNX(W_,159), 0)) OR  NOT (PushModelContext(1,
  "Modelica.Math.isEqual(partial_PMSM.eTraction.inverter.coreElement.lossPower.i_limit, partial_PMSM.eTraction.inverter.coreElement.lossPower.I_max, 0)")
  Modelica_Math_isEqual(DYNX(W_,160), DYNX(W_,167), 0)),"noEvent(Modelica.Math.isEqual(partial_PMSM.eTraction.inverter.coreElement.lossPower.i_des, partial_PMSM.eTraction.inverter.coreElement.lossPower.i, 0) or  not Modelica.Math.isEqual(partial_PMSM.eTraction.inverter.coreElement.lossPower.i_limit, partial_PMSM.eTraction.inverter.coreElement.lossPower.I_max, 0))",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("In 'stdMechEV.partial_PMSM.eTraction.inverter.coreElement.lossPower':\n  Desired power of ",
  Real2String2(DYNX(W_,202), true, 0)),"W is reduced to "),Real2String2(
  DYNX(W_,158), true, 0)),"W"),"\n  as necessary current i_des="),
  Real2StringFormat(DYNX(W_,161), ".15g")),"A is above I_max="),Real2String2(
  DYNX(W_,167), true, 0)),"A"),""),"\n  Reasons can be low supply voltage or too strict limit 'I_max'"),
  "\n  In case of numerical issues try reducing 'I_max'"));
PopAllMarks();
AssertModelica((PushModelContext(1,"Modelica.Math.isEqual(partial_PMSM.eTraction.machine.coreElement.electricPowerSource.i_des,  -partial_PMSM.eTraction.inverter.p2.i, 0)")
  Modelica_Math_isEqual(DYNX(W_,300),  -DYNX(W_,129), 0)) OR  NOT 
  (PushModelContext(1,"Modelica.Math.isEqual(partial_PMSM.eTraction.machine.coreElement.electricPowerSource.i_limit, partial_PMSM.eTraction.machine.coreElement.electricPowerSource.I_max, 0)")
  Modelica_Math_isEqual(DYNX(W_,299), DYNX(W_,306), 0)),"noEvent(Modelica.Math.isEqual(partial_PMSM.eTraction.machine.coreElement.electricPowerSource.i_des,  -partial_PMSM.eTraction.inverter.p2.i, 0) or  not Modelica.Math.isEqual(partial_PMSM.eTraction.machine.coreElement.electricPowerSource.i_limit, partial_PMSM.eTraction.machine.coreElement.electricPowerSource.I_max, 0))",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("In 'stdMechEV.partial_PMSM.eTraction.machine.coreElement.electricPowerSource':\n  Desired power of ",
  Real2String2(DYNX(W_,283), true, 0)),"W is reduced to "),Real2String2(
  DYNX(W_,298), true, 0)),"W"),"\n  as necessary current i_des="),
  Real2StringFormat(DYNX(W_,300), ".15g")),"A is above I_max="),Real2String2(
  DYNX(W_,306), true, 0)),"A"),""),"\n  Reasons can be low supply voltage or too strict limit 'I_max'"),
  "\n  In case of numerical issues try reducing 'I_max'"));
PopAllMarks();
AcceptedSection2
DYNX(W_,64) = DYNX(X_,1);
DYNX(W_,48) = DYNX(X_,0)+DYNX(DP_,33);
DYNX(W_,58) = (DYNX(W_,48)-DYNX(DP_,27))*DYNX(DP_,29)+DYNX(DP_,28);
DYNX(W_,66) = DYNX(W_,58)+DYNX(DP_,32)/(double)(2);
DYNX(W_,297) = DYNX(W_,48)-DYNX(DP_,94);
DYNX(W_,60) = DYNX(W_,66)+DYNX(DP_,32)/(double)(2);
DYNX(W_,249) = DYNX(W_,48)-DYNX(DP_,78);
DYNX(W_,68) = DYNX(X_,1)*DYNX(DP_,29);
DYNX(W_,47) = DYNX(W_,28)*DYNX(X_,1);
DYNX(W_,74) = DYNX(W_,70)*DYNX(X_,1);
DYNX(W_,75) = DYNX(W_,129)-DYNX(W_,159);
DYNX(W_,77) = DYNX(W_,159)-DYNX(W_,129);
DYNX(W_,81) =  -DYNX(DP_,35)*DYNX(W_,75);
DYNX(W_,87) = DYNX(W_,77)+DYNX(W_,75);
DYNX(W_,100) = DYNX(W_,92)-DYNX(X_,1);
DYNX(W_,134) =  -DYNX(W_,75)*DYNX(DP_,35);
DYNX(W_,138) = DYNX(DP_,35)*DYNX(W_,129);
DYNX(W_,218) = IF DYNX(W_,138) >= 0 THEN DYNX(W_,138) ELSE  -DYNX(W_,138);
DYNX(W_,219) = IF DYNX(W_,134) >= 0 THEN DYNX(W_,134) ELSE  -DYNX(W_,134);
DYNX(W_,220) = DYNX(W_,221)*DYNX(W_,218)+DYNX(W_,222)*DYNX(W_,219);
DYNX(W_,213) = IF DYNX(W_,220) >= 0 THEN DYNX(W_,220) ELSE  -DYNX(W_,220);
DYNX(W_,214) = DYNX(DP_,75)*DYNX(W_,213);
DYNX(W_,235) =  -DYNX(DP_,35)*DYNX(W_,129);
DYNX(W_,246) = DYNX(W_,48)-DYNX(DP_,78);
DYNX(W_,345) =  -DYNX(W_,90)*DYNX(X_,1);
DYNX(W_,347) = IF Greater(DYNX(W_,346),"partial_PMSM.motorSwitch.feedback", 0,
  "0", 2) THEN DYNX(X_,1) ELSE IF Less(DYNX(W_,346),"partial_PMSM.motorSwitch.feedback",
   0,"0", 18) THEN DYNX(W_,0) ELSE DYNX(X_,1);
DYNX(W_,351) =  -DYNX(DP_,35)*DYNX(W_,75);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("partial_Driver.VelocityRequest", "[rad/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_Driver.combiTimeTable.nout", "Number of outputs [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("partial_Driver.combiTimeTable.y[1]", "Connector of Real output signals",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_Driver.combiTimeTable.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("partial_Driver.combiTimeTable.table[1, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 0, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_Driver.combiTimeTable.table[1, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 1, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_Driver.combiTimeTable.table[2, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 2, 20, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_Driver.combiTimeTable.table[2, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 3, 50, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_Driver.combiTimeTable.table[3, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 4, 30, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_Driver.combiTimeTable.table[3, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 5, 50, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_Driver.combiTimeTable.table[4, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 6, 50, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_Driver.combiTimeTable.table[4, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 7, 20, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_Driver.combiTimeTable.table[5, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 8, 51, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_Driver.combiTimeTable.table[5, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 9, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_Driver.combiTimeTable.table[6, 1]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 10, 100, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_Driver.combiTimeTable.table[6, 2]", "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 11, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_Driver.combiTimeTable.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 12, true, 0.0,0.0,0.0,0,562)
DeclareVariable("partial_Driver.combiTimeTable.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("partial_Driver.combiTimeTable.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 1, 1.0,5.0,0.0,0,517)
DeclareVariable("partial_Driver.combiTimeTable.extrapolation", "Extrapolation of data outside the definition range [:#(type=Modelica.Blocks.Types.Extrapolation)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("partial_Driver.combiTimeTable.timeScale", "Time scale of first table column [s]",\
 1, 1E-15,1E+100,0.0,0,513)
DeclareParameter("partial_Driver.combiTimeTable.offset[1]", "Offsets of output signals",\
 13, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_Driver.combiTimeTable.startTime", "Output = offset for time < startTime [s]",\
 14, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("partial_Driver.combiTimeTable.shiftTime", "Shift time of first table column [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("partial_Driver.combiTimeTable.timeEvents", "Time event handling of table interpolation [:#(type=Modelica.Blocks.Types.TimeEvents)]",\
 15, 1, 1.0,3.0,0.0,0,564)
DeclareVariable("partial_Driver.combiTimeTable.verboseExtrapolation", \
"= true, if warning messages are to be printed if time is outside the table definition range [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_Driver.combiTimeTable.t_min", "Minimum abscissa value defined in table [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_Driver.combiTimeTable.t_max", "Maximum abscissa value defined in table [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_Driver.combiTimeTable.t_minScaled", "Minimum (scaled) abscissa value defined in table [1]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_Driver.combiTimeTable.t_maxScaled", "Maximum (scaled) abscissa value defined in table [1]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_Driver.combiTimeTable.p_offset[1]", "Offsets of output signals",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("partial_Driver.combiTimeTable.tableID.id", "[:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("partial_Driver.combiTimeTable.nextTimeEvent", "Next time event instant [s]",\
 0, 0.0,0.0,0.0,0,2704)
DeclareVariable("partial_Driver.combiTimeTable.nextTimeEventScaled", \
"Next scaled time event instant [1]", 0, 0.0,0.0,0.0,0,2704)
DeclareVariable("partial_Driver.combiTimeTable.timeScaled", "Scaled time [1]", \
0.0, 0.0,0.0,0.0,0,2560)
DeclareParameter("partial_Driver.gain.k", "Gain value multiplied with input signal [1]",\
 16, 0.5, 0.0,0.0,0.0,0,560)
DeclareAlias2("partial_Driver.gain.u", "Input signal connector", \
"partial_Driver.combiTimeTable.y[1]", 1, 5, 2, 0)
DeclareAlias2("partial_Driver.gain.y", "Output signal connector [rad/s]", \
"partial_Driver.VelocityRequest", 1, 5, 0, 0)
DeclareParameter("partial_Driver.k", "Constant output value", 17, 0, 0.0,0.0,0.0,\
0,560)
DeclareAlias2("partial_Controller.velocityRequestFromDriver", "[rad/s]", \
"partial_Driver.VelocityRequest", 1, 5, 0, 0)
DeclareVariable("partial_Controller.MechanicalBrakeRequest", "", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("partial_Controller.velocityRequestToMotor", "[rad/s]", \
"partial_Driver.VelocityRequest", 1, 5, 0, 0)
DeclareVariable("partial_Controller.brakeAllowance", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("partial_Controller.limiter.uMax", "Upper limits of input signals",\
 18, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("partial_Controller.limiter.uMin", "Lower limits of input signals",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_Controller.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_Controller.limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("partial_Controller.limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("partial_Controller.limiter.u", "Connector of Real input signal", \
"partial_Controller.brakeAllowance", 1, 5, 20, 0)
DeclareAlias2("partial_Controller.limiter.y", "Connector of Real output signal",\
 "partial_Controller.MechanicalBrakeRequest", 1, 5, 19, 0)
DeclareAlias2("partial_Controller.limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "partial_Controller.brakeAllowance", 1, 5, 20, 1024)
DeclareAlias2("partial_Brakes.MechanicalBrakeRequest", "", "partial_Controller.MechanicalBrakeRequest", 1,\
 5, 19, 0)
DeclareAlias2("partial_Brakes.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 4)
DeclareVariable("partial_Brakes.flange_a.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("partial_Brakes.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 4)
DeclareVariable("partial_Brakes.flange_b.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("partial_Brakes.brake.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("partial_Brakes.brake.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 4)
DeclareVariable("partial_Brakes.brake.flange_a.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("partial_Brakes.brake.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 4)
DeclareVariable("partial_Brakes.brake.flange_b.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("partial_Brakes.brake.phi_support", "Absolute angle of support flange [rad|deg]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareParameter("partial_Brakes.brake.mue_pos[1, 1]", "[w,mue] positive sliding friction coefficient (w_rel>=0)",\
 19, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_Brakes.brake.mue_pos[1, 2]", "[w,mue] positive sliding friction coefficient (w_rel>=0)",\
 20, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_Brakes.brake.peak", "Peak for maximum value of mue at w==0 (mue0_max = peak*mue_pos[1,2]) [1]",\
 21, 1, 1.0,1E+100,0.0,0,560)
DeclareParameter("partial_Brakes.brake.cgeo", "Geometry constant containing friction distribution assumption",\
 22, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("partial_Brakes.brake.fn_max", "Maximum normal force [N]", 23, 2000,\
 0.0,1E+100,0.0,0,560)
DeclareParameter("partial_Brakes.brake.w_small", "Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur) [rad/s]",\
 24, 10000000000.0, 0.0,0.0,0.0,0,560)
DeclareAlias2("partial_Brakes.brake.w_relfric", "Relative angular velocity between frictional surfaces [rad/s]",\
 "partial_Chassis.inertia.w", 1, 5, 64, 0)
DeclareAlias2("partial_Brakes.brake.a_relfric", "Relative angular acceleration between frictional surfaces [rad/s2]",\
 "partial_Chassis.damper.der(w_rel)", 1, 6, 1, 0)
DeclareVariable("partial_Brakes.brake.tau0", "Friction torque for w_relfric=0 and forward sliding [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_Brakes.brake.tau0_max", "Maximum friction torque for w_relfric=0 and locked [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_Brakes.brake.free", "= true, if frictional element is not active [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("partial_Brakes.brake.sa", "Path parameter of friction characteristic tau = f(a_relfric) [1]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_Brakes.brake.startForward", "= true, if w_relfric=0 and start of forward sliding [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,722)
DeclareVariable("partial_Brakes.brake.startBackward", "= true, if w_relfric=0 and start of backward sliding [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,722)
DeclareVariable("partial_Brakes.brake.locked", "true, if w_rel=0 and not sliding [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,706)
DeclareVariable("partial_Brakes.brake.Unknown", "Value of mode is not known [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("partial_Brakes.brake.Free", "Element is not active [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("partial_Brakes.brake.Forward", "w_relfric > 0 (forward sliding) [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("partial_Brakes.brake.Stuck", "w_relfric = 0 (forward sliding, locked or backward sliding) [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,517)
DeclareVariable("partial_Brakes.brake.Backward", "w_relfric < 0 (backward sliding) [:#(type=Integer)]",\
 -1, 0.0,0.0,0.0,0,517)
DeclareVariable("partial_Brakes.brake.mode", "Mode of friction (-1: backward sliding, 0: stuck, 1: forward sliding, 2: inactive, 3: unknown) [:#(type=Integer)]",\
 3, -1.0,3.0,0.0,0,660)
DeclareVariable("partial_Brakes.brake.unitAngularAcceleration", "[rad/s2]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("partial_Brakes.brake.unitTorque", "[N.m]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("partial_Brakes.brake.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("partial_Brakes.brake.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_Brakes.brake.phi", "Angle between shaft flanges (flange_a, flange_b) and support [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_Brakes.brake.der(phi)", "der(Angle between shaft flanges (flange_a, flange_b) and support) [rad/s]",\
 "partial_Chassis.inertia.w", 1, 5, 64, 0)
DeclareAlias2("partial_Brakes.brake.tau", "Brake friction torque [N.m]", \
"partial_Brakes.brake.flange_a.tau", 1, 5, 28, 0)
DeclareAlias2("partial_Brakes.brake.w", "Absolute angular velocity of flange_a and flange_b [rad/s]",\
 "partial_Chassis.inertia.w", 1, 5, 64, 0)
DeclareAlias2("partial_Brakes.brake.der(w)", "der(Absolute angular velocity of flange_a and flange_b) [rad/s2]",\
 "partial_Chassis.damper.der(w_rel)", 1, 6, 1, 0)
DeclareAlias2("partial_Brakes.brake.a", "Absolute angular acceleration of flange_a and flange_b [rad/s2]",\
 "partial_Chassis.damper.der(w_rel)", 1, 6, 1, 0)
DeclareVariable("partial_Brakes.brake.mue0", "Friction coefficient for w=0 and forward sliding",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_Brakes.brake.fn", "Normal force (=fn_max*f_normalized) [N]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_Brakes.brake.f_normalized", "Normalized force signal 0..1 (normal force = fn_max*f_normalized; brake is active if > 0) [1]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("partial_Brakes.limiter.uMax", "Upper limits of input signals",\
 25, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_Brakes.limiter.uMin", "Lower limits of input signals",\
 26, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("partial_Brakes.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_Brakes.limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("partial_Brakes.limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("partial_Brakes.limiter.u", "Connector of Real input signal", \
"partial_Controller.MechanicalBrakeRequest", 1, 5, 19, 0)
DeclareAlias2("partial_Brakes.limiter.y", "Connector of Real output signal [1]",\
 "partial_Brakes.brake.f_normalized", 1, 5, 51, 0)
DeclareAlias2("partial_Brakes.limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "partial_Controller.MechanicalBrakeRequest", 1, 5, 19, 1024)
DeclareVariable("partial_Chassis.idealRollingWheel.useSupportR", \
"= true, if rotational support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("partial_Chassis.idealRollingWheel.useSupportT", \
"= true, if translational support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("partial_Chassis.idealRollingWheel.flangeR.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 4)
DeclareVariable("partial_Chassis.idealRollingWheel.flangeR.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("partial_Chassis.idealRollingWheel.flangeT.s", "Absolute position of flange [m]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("partial_Chassis.idealRollingWheel.flangeT.f", "Cut force directed into flange [N]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("partial_Chassis.idealRollingWheel.internalSupportR.tau", \
"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau) [N.m]",\
 "partial_Chassis.idealRollingWheel.flangeR.tau", -1, 5, 57, 1024)
DeclareAlias2("partial_Chassis.idealRollingWheel.internalSupportR.phi", \
"External support angle (= flange.phi) [rad|deg]", "partial_Chassis.idealRollingWheel.fixedR.phi0", 1,\
 7, 27, 1024)
DeclareAlias2("partial_Chassis.idealRollingWheel.internalSupportR.flange.phi", \
"Absolute rotation angle of flange [rad|deg]", "partial_Chassis.idealRollingWheel.fixedR.phi0", 1,\
 7, 27, 1028)
DeclareAlias2("partial_Chassis.idealRollingWheel.internalSupportR.flange.tau", \
"Cut torque in the flange [N.m]", "partial_Chassis.idealRollingWheel.flangeR.tau", -1,\
 5, 57, 1156)
DeclareAlias2("partial_Chassis.idealRollingWheel.internalSupportT.f", \
"External support force (must be computed via force balance in model where InternalSupport is used; = flange.f) [N]",\
 "partial_Chassis.idealRollingWheel.flangeT.f", -1, 5, 59, 1024)
DeclareAlias2("partial_Chassis.idealRollingWheel.internalSupportT.s", \
"External support position (= flange.s) [m]", "partial_Chassis.idealRollingWheel.fixedT.s0", 1,\
 7, 28, 1024)
DeclareAlias2("partial_Chassis.idealRollingWheel.internalSupportT.flange.s", \
"Absolute position of flange [m]", "partial_Chassis.idealRollingWheel.fixedT.s0", 1,\
 7, 28, 1028)
DeclareAlias2("partial_Chassis.idealRollingWheel.internalSupportT.flange.f", \
"Cut force directed into flange [N]", "partial_Chassis.idealRollingWheel.flangeT.f", -1,\
 5, 59, 1156)
DeclareParameter("partial_Chassis.idealRollingWheel.fixedR.phi0", \
"Fixed offset angle of housing [rad|deg]", 27, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("partial_Chassis.idealRollingWheel.fixedR.flange.phi", \
"Absolute rotation angle of flange [rad|deg]", "partial_Chassis.idealRollingWheel.fixedR.phi0", 1,\
 7, 27, 1028)
DeclareAlias2("partial_Chassis.idealRollingWheel.fixedR.flange.tau", \
"Cut torque in the flange [N.m]", "partial_Chassis.idealRollingWheel.flangeR.tau", 1,\
 5, 57, 1156)
DeclareParameter("partial_Chassis.idealRollingWheel.fixedT.s0", "Fixed offset position of housing [m]",\
 28, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("partial_Chassis.idealRollingWheel.fixedT.flange.s", \
"Absolute position of flange [m]", "partial_Chassis.idealRollingWheel.fixedT.s0", 1,\
 7, 28, 1028)
DeclareAlias2("partial_Chassis.idealRollingWheel.fixedT.flange.f", \
"Cut force directed into flange [N]", "partial_Chassis.idealRollingWheel.flangeT.f", 1,\
 5, 59, 1156)
DeclareParameter("partial_Chassis.idealRollingWheel.radius", "Wheel radius [m]",\
 29, 0.3, 0.0,1E+100,0.0,0,560)
DeclareVariable("partial_Chassis.speedSensor.flange.s", "Absolute position of flange [m]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("partial_Chassis.speedSensor.flange.der(s)", "der(Absolute position of flange) [m/s]",\
 "partial_Chassis.mass.v", 1, 5, 68, 4)
DeclareVariable("partial_Chassis.speedSensor.flange.f", "Cut force directed into flange [N]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("partial_Chassis.speedSensor.v", "Absolute velocity of flange as output signal [m/s]",\
 "partial_Chassis.mass.v", 1, 5, 68, 0)
DeclareAlias2("partial_Chassis.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 4)
DeclareAlias2("partial_Chassis.flange_a.tau", "Cut torque in the flange [N.m]", \
"partial_Brakes.flange_b.tau", -1, 5, 26, 132)
DeclareAlias2("partial_Chassis.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 4)
DeclareAlias2("partial_Chassis.inertia.flange_a.tau", "Cut torque in the flange [N.m]",\
 "partial_Brakes.flange_b.tau", -1, 5, 26, 132)
DeclareAlias2("partial_Chassis.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 4)
DeclareVariable("partial_Chassis.inertia.flange_b.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareParameter("partial_Chassis.inertia.J", "Moment of inertia [kg.m2]", 30, \
0.675, 0.0,1E+100,0.0,0,560)
DeclareVariable("partial_Chassis.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("partial_Chassis.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 0)
DeclareAlias2("partial_Chassis.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "partial_Chassis.inertia.w", 1, 5, 64, 0)
DeclareVariable("partial_Chassis.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 0, 0.0,0.0,0.0,0,528)
DeclareAlias2("partial_Chassis.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 "partial_Chassis.damper.der(w_rel)", 1, 6, 1, 0)
DeclareAlias2("partial_Chassis.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "partial_Chassis.damper.der(w_rel)", 1, 6, 1, 0)
DeclareParameter("partial_Chassis.mass.m", "Mass of the sliding mass [kg]", 31, 2000,\
 0.0,1E+100,0.0,0,560)
DeclareVariable("partial_Chassis.mass.stateSelect", "Priority to use s and v as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,517)
DeclareVariable("partial_Chassis.mass.s", "Absolute position of center of component (s = flange_a.s + L/2 = flange_b.s - L/2) [m]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_Chassis.mass.der(s)", "der(Absolute position of center of component (s = flange_a.s + L/2 = flange_b.s - L/2)) [m/s]",\
 "partial_Chassis.mass.v", 1, 5, 68, 0)
DeclareParameter("partial_Chassis.mass.L", "Length of component, from left flange to right flange (= flange_b.s - flange_a.s) [m]",\
 32, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("partial_Chassis.mass.flange_a.s", "Absolute position of flange [m]",\
 "partial_Chassis.idealRollingWheel.flangeT.s", 1, 5, 58, 4)
DeclareAlias2("partial_Chassis.mass.flange_a.f", "Cut force directed into flange [N]",\
 "partial_Chassis.idealRollingWheel.flangeT.f", -1, 5, 59, 132)
DeclareAlias2("partial_Chassis.mass.flange_b.s", "Absolute position of flange [m]",\
 "partial_Chassis.speedSensor.flange.s", 1, 5, 60, 4)
DeclareVariable("partial_Chassis.mass.flange_b.f", "Cut force directed into flange [N]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("partial_Chassis.mass.v", "Absolute velocity of component [m/s]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_Chassis.mass.der(v)", "der(Absolute velocity of component) [m/s2]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_Chassis.mass.a", "Absolute acceleration of component [m/s2]",\
 "partial_Chassis.mass.der(v)", 1, 5, 69, 0)
DeclareParameter("partial_Chassis.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 33, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("partial_Chassis.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Chassis.fixed.phi0", 1, 7, 33, 4)
DeclareVariable("partial_Chassis.fixed.flange.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareState("partial_Chassis.damper.phi_rel", "Relative rotation angle (= flange_b.phi - flange_a.phi) [rad|deg]",\
 0, 0, 0.0,0.0,0.0001,0,560)
DeclareDerivative("partial_Chassis.damper.der(phi_rel)", "der(Relative rotation angle (= flange_b.phi - flange_a.phi)) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("partial_Chassis.damper.w_rel", "Relative angular velocity (= der(phi_rel)) [rad/s]",\
 1, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("partial_Chassis.damper.der(w_rel)", "der(Relative angular velocity (= der(phi_rel))) [rad/s2]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_Chassis.damper.a_rel", "Relative angular acceleration (= der(w_rel)) [rad/s2]",\
 "partial_Chassis.damper.der(w_rel)", 1, 6, 1, 0)
DeclareAlias2("partial_Chassis.damper.tau", "Torque between flanges (= flange_b.tau) [N.m]",\
 "partial_Chassis.fixed.flange.tau", 1, 5, 70, 0)
DeclareAlias2("partial_Chassis.damper.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Chassis.fixed.phi0", 1, 7, 33, 4)
DeclareAlias2("partial_Chassis.damper.flange_a.tau", "Cut torque in the flange [N.m]",\
 "partial_Chassis.fixed.flange.tau", -1, 5, 70, 132)
DeclareAlias2("partial_Chassis.damper.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 4)
DeclareAlias2("partial_Chassis.damper.flange_b.tau", "Cut torque in the flange [N.m]",\
 "partial_Chassis.fixed.flange.tau", 1, 5, 70, 132)
DeclareVariable("partial_Chassis.damper.phi_nominal", "Nominal value of phi_rel (used for scaling) [rad|rad]",\
 0.0001, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_Chassis.damper.stateSelect", "Priority to use phi_rel and w_rel as states [:#(type=StateSelect)]",\
 4, 1.0,5.0,0.0,0,1541)
DeclareParameter("partial_Chassis.damper.d", "Damping constant [N.m.s/rad]", 34,\
 1, 0.0,1E+100,0.0,0,560)
DeclareVariable("partial_Chassis.damper.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("partial_Chassis.damper.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simplePower.pin_p.v", "Potential at the pin [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareVariable("simplePower.pin_p.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("simplePower.pin_n.v", "Potential at the pin [V]", 0, 0.0,0.0,\
0.0,0,521)
DeclareVariable("simplePower.pin_n.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareAlias2("simplePower.driveMotorPowerSensor2.pc.v", "Potential at the pin [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("simplePower.driveMotorPowerSensor2.pc.i", "Current flowing into the pin [A]",\
 "simplePower.pin_p.i", -1, 5, 75, 132)
DeclareAlias2("simplePower.driveMotorPowerSensor2.nc.v", "Potential at the pin [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("simplePower.driveMotorPowerSensor2.nc.i", "Current flowing into the pin [A]",\
 "simplePower.pin_p.i", 1, 5, 75, 132)
DeclareAlias2("simplePower.driveMotorPowerSensor2.pv.v", "Potential at the pin [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareVariable("simplePower.driveMotorPowerSensor2.pv.i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("simplePower.driveMotorPowerSensor2.nv.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("simplePower.driveMotorPowerSensor2.nv.i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("simplePower.driveMotorPowerSensor2.power", "Instantaneous power as output signal [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("simplePower.driveMotorPowerSensor2.voltageSensor.p.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareVariable("simplePower.driveMotorPowerSensor2.voltageSensor.p.i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("simplePower.driveMotorPowerSensor2.voltageSensor.n.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("simplePower.driveMotorPowerSensor2.voltageSensor.n.i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("simplePower.driveMotorPowerSensor2.voltageSensor.v", \
"Voltage between pin p and n (= p.v - n.v) as output signal [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 0)
DeclareAlias2("simplePower.driveMotorPowerSensor2.currentSensor.p.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("simplePower.driveMotorPowerSensor2.currentSensor.p.i", \
"Current flowing into the pin [A]", "simplePower.pin_p.i", -1, 5, 75, 132)
DeclareAlias2("simplePower.driveMotorPowerSensor2.currentSensor.n.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("simplePower.driveMotorPowerSensor2.currentSensor.n.i", \
"Current flowing into the pin [A]", "simplePower.pin_p.i", 1, 5, 75, 132)
DeclareAlias2("simplePower.driveMotorPowerSensor2.currentSensor.i", \
"Current in the branch from p to n as output signal [A]", "simplePower.pin_p.i", -1,\
 5, 75, 0)
DeclareAlias2("simplePower.driveMotorPowerSensor2.product.u1", "Connector of Real input signal 1 [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 0)
DeclareAlias2("simplePower.driveMotorPowerSensor2.product.u2", "Connector of Real input signal 2 [A]",\
 "simplePower.pin_p.i", -1, 5, 75, 0)
DeclareAlias2("simplePower.driveMotorPowerSensor2.product.y", "Connector of Real output signal [W]",\
 "simplePower.driveMotorPowerSensor2.power", 1, 5, 81, 0)
DeclareParameter("simplePower.constantVoltage.V", "Value of constant voltage [V]",\
 35, 370, 0.0,0.0,0.0,0,560)
DeclareAlias2("simplePower.constantVoltage.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 0)
DeclareAlias2("simplePower.constantVoltage.i", "Current flowing from pin p to pin n [A]",\
 "simplePower.pin_p.i", 1, 5, 75, 0)
DeclareAlias2("simplePower.constantVoltage.p.v", "Potential at the pin [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("simplePower.constantVoltage.p.i", "Current flowing into the pin [A]",\
 "simplePower.pin_p.i", 1, 5, 75, 132)
DeclareVariable("simplePower.constantVoltage.n.v", "Potential at the pin [V]", \
0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("simplePower.constantVoltage.n.i", "Current flowing into the pin [A]",\
 "simplePower.pin_p.i", -1, 5, 75, 132)
DeclareVariable("simplePower.ground.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("simplePower.ground.p.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,776)
DeclareParameter("partial_PMSM.tauMaxTraction", "[N.m]", 36, 100000.0, 0.0,0.0,\
0.0,0,560)
DeclareParameter("partial_PMSM.PMaxTraction", "[W]", 37, 100000.0, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.tauMaxRegen", "[N.m]", 38, 500, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.PMaxRegen", "[W]", 39, 500, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.Ti", "[s]", 40, 1000, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.k", "[1]", 41, 10000, 0.0,0.0,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.useSupport", "True: stator is able to rotate, false: stator is fixed internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.useThermalPort", "True: thermal connector is provided, false: temperature is fixed internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("partial_PMSM.eTraction.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 4)
DeclareVariable("partial_PMSM.eTraction.flange.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("partial_PMSM.eTraction.pin_p.v", "Potential at the pin [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.pin_p.i", "Current flowing into the pin [A]",\
 "simplePower.pin_p.i", -1, 5, 75, 132)
DeclareVariable("partial_PMSM.eTraction.pin_n.v", "Potential at the pin [V]", \
0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("partial_PMSM.eTraction.pin_n.i", "Current flowing into the pin [A]",\
 "simplePower.pin_n.i", -1, 5, 77, 132)
DeclareVariable("partial_PMSM.eTraction.desiredSpeed", "[rad/s|1/min]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTraction.controller.desiredSpeed", "[rad/s|1/min]",\
 "partial_PMSM.eTraction.desiredSpeed", 1, 5, 92, 0)
DeclareAlias2("partial_PMSM.eTraction.controller.actualSpeed", "[rad/s|1/min]", \
"partial_Chassis.inertia.w", 1, 5, 64, 0)
DeclareVariable("partial_PMSM.eTraction.controller.setTorque", "[N.m]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("partial_PMSM.eTraction.controller.data.k", "Gain of controller [1]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.controller.data.Ti", "Time constant of Integrator block [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.controller.data.tau_max", \
"Maximum allowed torque that is output to the machine [N.m]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.k", \
"Gain of controller [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.Ti", \
"Time constant of Integrator block [s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.yMax", \
"Upper limit of output [N.m]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.desiredValue", \
"Connector of setpoint input signal [rad/s]", "partial_PMSM.eTraction.desiredSpeed", 1,\
 5, 92, 0)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.measuredValue", \
"Connector of measurement input signal [rad/s]", "partial_Chassis.inertia.w", 1,\
 5, 64, 0)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.setValue", \
"Connector of actuator output signal [N.m]", "partial_PMSM.eTraction.controller.setTorque", 1,\
 5, 93, 0)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.u_s", \
"Connector of setpoint input signal [rad/s]", "partial_PMSM.eTraction.desiredSpeed", 1,\
 5, 92, 0)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.u_m", \
"Connector of measurement input signal [rad/s]", "partial_Chassis.inertia.w", 1,\
 5, 64, 0)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.y", \
"Connector of actuator output signal [N.m]", "partial_PMSM.eTraction.controller.setTorque", 1,\
 5, 93, 0)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.controlError",\
 "Control error (set point - measurement) [rad/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.controllerType",\
 "Type of controller [:#(type=Modelica.Blocks.Types.SimpleController)]", 2, 1.0,\
4.0,0.0,0,517)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.k", \
"Gain of controller [1]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.Ti", \
"Time constant of Integrator block [s]", 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.Td", \
"Time constant of Derivative block [s]", 42, 0.1, 0.0,1E+100,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.yMax", \
"Upper limit of output [N.m]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.yMin", \
"Lower limit of output [N.m]", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.wp", \
"Set-point weight for Proportional block (0..1)", 43, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.wd", \
"Set-point weight for Derivative block (0..1)", 44, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.Ni", \
"Ni*Ti is time constant of anti-windup compensation", 45, 0.9, 1E-13,1E+100,0.0,\
0,560)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.Nd", \
"The higher Nd, the more ideal the derivative block", 46, 10, 1E-13,1E+100,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.withFeedForward",\
 "Use feed-forward input? [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,515)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.kFF", \
"Gain of feed-forward input", 47, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.initType", \
"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.InitPID)]",\
 5, 1.0,5.0,0.0,0,517)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.xi_start", \
"Initial or guess value for integrator output (= integrator state)", 48, 0, \
0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.xd_start", \
"Initial or guess value for state of derivative block", 49, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.y_start", \
"Initial value of output", 50, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.homotopyType",\
 "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.strict", \
"= true, if strict limits with noEvent(..) [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.limitsAtInit",\
 "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.unitTime", \
"[s]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.addP.u1", \
"Connector of Real input signal 1 [rad/s]", "partial_PMSM.eTraction.desiredSpeed", 1,\
 5, 92, 0)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.addP.u2", \
"Connector of Real input signal 2 [rad/s]", "partial_Chassis.inertia.w", 1, 5, 64,\
 0)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.addP.y", \
"Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.addP.k1", \
"Gain of input signal 1", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.addP.k2", \
"Gain of input signal 2", 51, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.P.k", \
"Gain value multiplied with input signal [1]", 52, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.P.u", \
"Input signal connector", "partial_PMSM.eTraction.controller.coreElement.PID.addP.y", 1,\
 5, 112, 0)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.P.y", \
"Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.gainPID.k", \
"Gain value multiplied with input signal [1]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.gainPID.u", \
"Input signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.gainPID.y", \
"Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.addPID.k1", \
"Gain of input signal 1", 53, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.addPID.k2", \
"Gain of input signal 2", 54, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.addPID.k3", \
"Gain of input signal 3", 55, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.addPID.u1", \
"Connector of Real input signal 1", "partial_PMSM.eTraction.controller.coreElement.PID.P.y", 1,\
 5, 114, 0)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.addPID.u2", \
"Connector of Real input signal 2", "partial_PMSM.eTraction.controller.coreElement.PID.Dzero.k", 1,\
 7, 56, 0)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.addPID.u3", \
"Connector of Real input signal 3", "partial_PMSM.eTraction.controller.coreElement.PID.I.y", 1,\
 1, 2, 0)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.addPID.y", \
"Connector of Real output signal", "partial_PMSM.eTraction.controller.coreElement.PID.gainPID.u", 1,\
 5, 116, 0)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.limiter.uMax",\
 "Upper limits of input signals [N.m]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.limiter.uMin",\
 "Lower limits of input signals [N.m]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.limiter.strict",\
 "= true, if strict limits with noEvent(..) [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.limiter.homotopyType",\
 "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.limiter.limitsAtInit",\
 "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.limiter.u", \
"Connector of Real input signal [N.m]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.limiter.y", \
"Connector of Real output signal [N.m]", "partial_PMSM.eTraction.controller.setTorque", 1,\
 5, 93, 0)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.limiter.simplifiedExpr",\
 "Simplified expression for homotopy-based initialization [N.m]", \
"partial_PMSM.eTraction.controller.coreElement.PID.limiter.u", 1, 5, 123, 1024)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.with_I", \
"[:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.with_D", \
"[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.Dzero.k", \
"Constant output value", 56, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.Dzero.y", \
"Connector of Real output signal", "partial_PMSM.eTraction.controller.coreElement.PID.Dzero.k", 1,\
 7, 56, 0)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.FFzero.k", \
"Constant output value", 57, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.FFzero.y", \
"Connector of Real output signal", "partial_PMSM.eTraction.controller.coreElement.PID.FFzero.k", 1,\
 7, 57, 0)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.addFF.u1", \
"Connector of Real input signal 1", "partial_PMSM.eTraction.controller.coreElement.PID.gainPID.y", 1,\
 5, 117, 0)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.addFF.u2", \
"Connector of Real input signal 2", "partial_PMSM.eTraction.controller.coreElement.PID.FFzero.k", 1,\
 7, 57, 0)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.addFF.y", \
"Connector of Real output signal [N.m]", "partial_PMSM.eTraction.controller.coreElement.PID.limiter.u", 1,\
 5, 123, 0)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.addFF.k1", \
"Gain of input signal 1", 58, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.addFF.k2", \
"Gain of input signal 2", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.useThermalPort", \
"True: thermal connector is provided, false: temperature is fixed internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("partial_PMSM.eTraction.inverter.p1.v", "Potential at the pin [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.p1.i", "Current flowing into the pin [A]",\
 "simplePower.pin_p.i", -1, 5, 75, 132)
DeclareVariable("partial_PMSM.eTraction.inverter.n1.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("partial_PMSM.eTraction.inverter.n1.i", "Current flowing into the pin [A]",\
 "simplePower.pin_n.i", -1, 5, 77, 132)
DeclareAlias2("partial_PMSM.eTraction.inverter.p2.v", "Potential at the pin [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareVariable("partial_PMSM.eTraction.inverter.p2.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("partial_PMSM.eTraction.inverter.n2.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("partial_PMSM.eTraction.inverter.n2.i", "Current flowing into the pin [A]",\
 "partial_PMSM.eTraction.inverter.p2.i", -1, 5, 129, 132)
DeclareAlias2("partial_PMSM.eTraction.inverter.inputVoltageSensor1.p.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareVariable("partial_PMSM.eTraction.inverter.inputVoltageSensor1.p.i", \
"Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareVariable("partial_PMSM.eTraction.inverter.inputVoltageSensor1.n.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("partial_PMSM.eTraction.inverter.inputVoltageSensor1.n.i", \
"Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("partial_PMSM.eTraction.inverter.inputVoltageSensor1.v", \
"Voltage between pin p and n (= p.v - n.v) as output signal [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.product1.u1", "Connector of Real input signal 1 [A]",\
 "simplePower.pin_p.i", -1, 5, 75, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.product1.u2", "Connector of Real input signal 2 [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 0)
DeclareVariable("partial_PMSM.eTraction.inverter.product1.y", "Connector of Real output signal [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTraction.inverter.inputCurrentSensor1.p.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.inputCurrentSensor1.p.i", \
"Current flowing into the pin [A]", "simplePower.pin_p.i", -1, 5, 75, 132)
DeclareAlias2("partial_PMSM.eTraction.inverter.inputCurrentSensor1.n.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.inputCurrentSensor1.n.i", \
"Current flowing into the pin [A]", "simplePower.pin_p.i", 1, 5, 75, 132)
DeclareAlias2("partial_PMSM.eTraction.inverter.inputCurrentSensor1.i", \
"Current in the branch from p to n as output signal [A]", "simplePower.pin_p.i", -1,\
 5, 75, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.inputCurrentSensor2.p.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.inputCurrentSensor2.p.i", \
"Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.p2.i", 1, 5,\
 129, 132)
DeclareAlias2("partial_PMSM.eTraction.inverter.inputCurrentSensor2.n.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.inputCurrentSensor2.n.i", \
"Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.p2.i", -1, 5,\
 129, 132)
DeclareAlias2("partial_PMSM.eTraction.inverter.inputCurrentSensor2.i", \
"Current in the branch from p to n as output signal [A]", "partial_PMSM.eTraction.inverter.p2.i", 1,\
 5, 129, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.inputVoltageSensor2.p.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareVariable("partial_PMSM.eTraction.inverter.inputVoltageSensor2.p.i", \
"Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareVariable("partial_PMSM.eTraction.inverter.inputVoltageSensor2.n.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("partial_PMSM.eTraction.inverter.inputVoltageSensor2.n.i", \
"Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("partial_PMSM.eTraction.inverter.inputVoltageSensor2.v", \
"Voltage between pin p and n (= p.v - n.v) as output signal [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.product2.u1", "Connector of Real input signal 1 [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.product2.u2", "Connector of Real input signal 2 [A]",\
 "partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 0)
DeclareVariable("partial_PMSM.eTraction.inverter.product2.y", "Connector of Real output signal [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterVoltageDC.u", \
"DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterCurrentDC.u", \
"DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerAC.u", \
"AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerDC.u", \
"DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_currentAC_EA.u", \
"AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_voltageAC_EA.u", \
"AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 0)
DeclareVariable("partial_PMSM.eTraction.inverter.useVoltageGuess", \
"Use start value for iteration during initialization (setting 'start' with 'fixed=false') [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("partial_PMSM.eTraction.inverter.V_guess", "Start value for iteration during initialization [V]",\
 59, 400, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.inverter.data.eta", "[1]", 60, 1, 0.0,\
1E+100,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.inverter.data.variablePower", \
"Set power by parameter (true) or real input (false) [:#(type=Boolean)]", true, \
0.0,0.0,0.0,0,515)
DeclareParameter("partial_PMSM.eTraction.inverter.data.P_constant", \
"Desired power: postive is consumed, negative is generated [W]", 61, 1, 0.0,0.0,\
0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.inverter.data.V_min", "For lower voltages, power will be limited [V]",\
 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.data.V_max", "For higher voltages, power will be limited [V]",\
 100000.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("partial_PMSM.eTraction.inverter.data.I_max", "Maximum possible DC current (-I_max < I < I_max) [A]",\
 62, 100000.0, 0.0,1E+100,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.inverter.data.actionLim", \
"Optionally warn or stop when power is limited [:#(type=DymolaModels.Blocks.Choices.AssertActions)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareVariable("partial_PMSM.eTraction.inverter.data.actionDiv0", \
"Optionally warn or stop when preventing divisions by zero [:#(type=DymolaModels.Blocks.Choices.AssertActions)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareVariable("partial_PMSM.eTraction.inverter.data.V_eps", "Threshold for minimum voltage, values between +eps/-eps will be treated as eps [V]",\
 0.1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.data.useDynamics", \
"Use PT1 dynamics to filter the load's demanded power [:#(type=Boolean)]", false,\
 0.0,0.0,0.0,0,515)
DeclareParameter("partial_PMSM.eTraction.inverter.data.T_PT1", "Time constant of optional PT1 [s]",\
 63, 0.001, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.inverter.data.initType", \
"Type of initialization (1: no init, 2: steady state, 3/4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 64, 1, 1.0,4.0,0.0,0,564)
DeclareParameter("partial_PMSM.eTraction.inverter.data.initialCurrent", \
"Initial current through the power source [A]", 65, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.eta", \
"Efficiency of the inverter [1]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.variablePower", \
"Set power by parameter (true) or real input (false) [:#(type=Boolean)]", true, \
0.0,0.0,0.0,0,515)
DeclareParameter("partial_PMSM.eTraction.inverter.coreElement.P_constant", \
"Desired power: postive is consumed, negative is generated [W]", 66, 1, 0.0,0.0,\
0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.V_min", \
"For lower voltages, power will be limited [V]", 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.V_max", \
"For higher voltages, power will be limited [V]", 100000.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.I_max", \
"Maximum possible DC current (-I_max < I < I_max) [A]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.actionLim", \
"Optionally warn or stop when power is limited [:#(type=DymolaModels.Blocks.Choices.AssertActions)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.actionDiv0", \
"Optionally warn or stop when preventing divisions by zero [:#(type=DymolaModels.Blocks.Choices.AssertActions)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.V_eps", \
"Threshold for minimum voltage, values between +eps/-eps will be treated as eps [V]",\
 0.1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.useDynamics", \
"Use PT1 dynamics to filter the load's demanded power [:#(type=Boolean)]", false,\
 0.0,0.0,0.0,0,515)
DeclareParameter("partial_PMSM.eTraction.inverter.coreElement.T_PT1", \
"Time constant of optional PT1 [s]", 67, 0.001, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.inverter.coreElement.initType", \
"Type of initialization (1: no init, 2: steady state, 3/4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 68, 1, 1.0,4.0,0.0,0,564)
DeclareParameter("partial_PMSM.eTraction.inverter.coreElement.initialCurrent", \
"Initial current through the power source [A]", 69, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.useVoltageGuess", \
"Use start value for iteration during initialization (setting 'start' with 'fixed=false') [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.V_guess", \
"Start value for iteration during initialization [V]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.P_actual",\
 "Instantaneous power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.i", \
"Current through the load [A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.i_limit",\
 "Instantaneous current limit [A]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.i_des", \
"Instantaneous current limit [A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", "simplePower.constantVoltage.V", 1,\
 7, 35, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.p.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.p.i", \
"Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.coreElement.lossPower.i", 1,\
 5, 159, 132)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.n.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.n.i", \
"Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.coreElement.lossPower.i", -1,\
 5, 159, 132)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.variablePower",\
 "Set power by parameter (true) or real input (false) [:#(type=Boolean)]", true,\
 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.P_constant",\
 "Desired power: postive is consumed, negative is generated [W]", 1, 0.0,0.0,0.0,\
0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.V_min", \
"For lower voltages, power will be limited [V]", 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.V_max", \
"For higher voltages, power will be limited [V]", 100000.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.I_max", \
"Maximum possible DC current (-I_max < I < I_max) [A]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.actionLim",\
 "Optionally warn or stop when power is limited [:#(type=DymolaModels.Blocks.Choices.AssertActions)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.actionDiv0",\
 "Optionally warn or stop when preventing divisions by zero [:#(type=DymolaModels.Blocks.Choices.AssertActions)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.V_eps", \
"Threshold for minimum voltage, values between +eps/-eps will be treated as eps [V]",\
 0.1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.useDynamics",\
 "Use PT1 dynamics to filter the load's demanded power [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.T_PT1", \
"Time constant of optional PT1 [s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.initType",\
 "Type of initialization (1: no init, 2: steady state, 3/4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.initialCurrent",\
 "Initial current through the power source [A]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.useVoltageGuess",\
 "Use start value for iteration during initialization (setting 'start' with 'fixed=false') [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.V_guess",\
 "Start value for iteration during initialization [V]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.P_variable",\
 "Desired power input, postive is consumed, negative is generated power [W]", \
"partial_PMSM.eTraction.inverter.coreElement.losses.y", 1, 5, 202, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.divNoZero.u1",\
 "Connector of Real input signal 1 [W]", "partial_PMSM.eTraction.inverter.coreElement.losses.y", 1,\
 5, 202, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.divNoZero.u2",\
 "Connector of Real input signal 2 [V]", "simplePower.constantVoltage.V", 1, 7, 35,\
 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.divNoZero.y",\
 "Connector of Real output signal [A]", "partial_PMSM.eTraction.inverter.coreElement.lossPower.i_des", 1,\
 5, 161, 0)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.divNoZero.eps",\
 "Smallest value used for division [V]", 0.1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.divNoZero.considerSign",\
 "True: sign is considered in case of 'b' < 'eps' [:#(type=Boolean)]", true, \
0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.divNoZero.action",\
 "Optionally inform about divisions by zero with asserts [:#(type=DymolaModels.Blocks.Choices.AssertActions)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.signalCurrent.p.v",\
 "Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.signalCurrent.p.i",\
 "Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.coreElement.lossPower.i", 1,\
 5, 159, 132)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.signalCurrent.n.v",\
 "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.signalCurrent.n.i",\
 "Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.coreElement.lossPower.i", -1,\
 5, 159, 132)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.signalCurrent.v",\
 "Voltage drop between the two pins (= p.v - n.v) [V]", "simplePower.constantVoltage.V", 1,\
 7, 35, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.signalCurrent.i",\
 "Current flowing from pin p to pin n as input signal [A]", "partial_PMSM.eTraction.inverter.coreElement.lossPower.i", 1,\
 5, 159, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.desiredPower.y",\
 "Connector of Real output signal [W]", "partial_PMSM.eTraction.inverter.coreElement.losses.y", 1,\
 5, 202, 0)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.desiredPower.variableOutput",\
 "If true the input signal u is used as output, otherwise the parameter p [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.desiredPower.p",\
 "Constant output value [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.desiredPower.u",\
 "Variable output value [W]", "partial_PMSM.eTraction.inverter.coreElement.losses.y", 1,\
 5, 202, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.currentLimiter.u",\
 "Connector of Real input signal [A]", "partial_PMSM.eTraction.inverter.coreElement.lossPower.i_des", 1,\
 5, 161, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.currentLimiter.y",\
 "Connector of Real output signal [A]", "partial_PMSM.eTraction.inverter.coreElement.lossPower.i", 1,\
 5, 159, 0)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.currentLimiter.strict",\
 "= true, if strict limits with noEvent(..) [:#(type=Boolean)]", true, 0.0,0.0,\
0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.currentLimiter.homotopyType",\
 "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.VariableLimiterHomotopy)]",\
 2, 1.0,3.0,0.0,0,517)
DeclareParameter("partial_PMSM.eTraction.inverter.coreElement.lossPower.currentLimiter.ySimplified",\
 "Fixed value of output in simplified model [A]", 70, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.currentLimiter.limit",\
 "Value used for maximum and minimum of input u [A]", "partial_PMSM.eTraction.inverter.coreElement.lossPower.i_limit", 1,\
 5, 160, 0)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.currentLimiter.limit1",\
 "Upper limit [A]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.currentLimiter.limit2",\
 "Lower limit [A]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.currentLimiter.simplifiedExpr",\
 "Simplified expression for homotopy-based initialization [A]", "partial_PMSM.eTraction.inverter.coreElement.lossPower.i_des", 1,\
 5, 161, 1024)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.positiveVoltage.u",\
 "Connector of Real input signal [V]", "simplePower.constantVoltage.V", 1, 7, 35,\
 0)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.positiveVoltage.y",\
 "Connector of Real output signal [V]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.positiveVoltage.generateEvent",\
 "Choose whether events shall be generated [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.limI_minV.u",\
 "Connector of Real input signal [V]", "partial_PMSM.eTraction.inverter.coreElement.lossPower.positiveVoltage.y", 1,\
 5, 187, 0)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.limI_minV.y",\
 "Connector of Real output signal [A]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.limI_minV.u1",\
 "Lower boundary of input u, switching from constant value y1 to sin^2 interpolation [V]",\
 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.limI_minV.u2",\
 "Upper boundary of input u, switching from sin^2 interpolation to constant value y2 [V]",\
 1, 0.0,0.0,0.0,0,513)
DeclareParameter("partial_PMSM.eTraction.inverter.coreElement.lossPower.limI_minV.y1",\
 "Minimum value for y [A]", 71, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.limI_minV.y2",\
 "Maximum value for y [A]", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.limI_maxV.u",\
 "Connector of Real input signal [V]", "partial_PMSM.eTraction.inverter.coreElement.lossPower.positiveVoltage.y", 1,\
 5, 187, 0)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.limI_maxV.y",\
 "Connector of Real output signal [A]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.limI_maxV.u1",\
 "Lower boundary of input u, switching from constant value y1 to sin^2 interpolation [V]",\
 100000.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.limI_maxV.u2",\
 "Upper boundary of input u, switching from sin^2 interpolation to constant value y2 [V]",\
 110000.00000000001, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.limI_maxV.y1",\
 "Minimum value for y [A]", 0, 0.0,0.0,0.0,0,513)
DeclareParameter("partial_PMSM.eTraction.inverter.coreElement.lossPower.limI_maxV.y2",\
 "Maximum value for y [A]", 72, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.voltageLimit.u1",\
 "Connector of Real input signal 1 [A]", "partial_PMSM.eTraction.inverter.coreElement.lossPower.limI_minV.y", 1,\
 5, 189, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.voltageLimit.u2",\
 "Connector of Real input signal 2 [A]", "partial_PMSM.eTraction.inverter.coreElement.lossPower.limI_maxV.y", 1,\
 5, 193, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.voltageLimit.y",\
 "Connector of Real output signal [A]", "partial_PMSM.eTraction.inverter.coreElement.lossPower.i_limit", 1,\
 5, 160, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.noFirstOrder.u",\
 "Connector of Real input signal [A]", "partial_PMSM.eTraction.inverter.coreElement.lossPower.i", 1,\
 5, 159, 1024)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.noFirstOrder.y",\
 "Connector of Real output signal [A]", "partial_PMSM.eTraction.inverter.coreElement.lossPower.i", 1,\
 5, 159, 1024)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.voltageSensor.p.v",\
 "Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 1028)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.voltageSensor.p.i",\
 "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,2825)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.voltageSensor.n.v",\
 "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,2569)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.lossPower.voltageSensor.n.i",\
 "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,2825)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.lossPower.voltageSensor.v",\
 "Voltage between pin p and n (= p.v - n.v) as output signal [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 1024)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.providedPower.u1", \
"Connector of Real input signal 1 [W]", "partial_PMSM.eTraction.inverter.coreElement.P_AC", 1,\
 5, 211, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.providedPower.u2", \
"Connector of Real input signal 2 [W]", "partial_PMSM.eTraction.inverter.coreElement.P_DC", 1,\
 5, 212, 0)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.providedPower.y", \
"Connector of Real output signal [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.losses.k", \
"Gain value multiplied with input signal [1]", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.losses.u", \
"Input signal connector [W]", "partial_PMSM.eTraction.inverter.coreElement.providedPower.y", 1,\
 5, 200, 0)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.losses.y", \
"Output signal connector [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.computePowerDC.u1", \
"Connector of Real input signal 1 [W]", "partial_PMSM.eTraction.inverter.coreElement.P_AC", 1,\
 5, 211, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.computePowerDC.u2", \
"Connector of Real input signal 2 [W]", "partial_PMSM.eTraction.inverter.coreElement.losses.y", 1,\
 5, 202, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.computePowerDC.y", \
"Connector of Real output signal [W]", "partial_PMSM.eTraction.inverter.coreElement.P_DC", 1,\
 5, 212, 0)
DeclareParameter("partial_PMSM.eTraction.inverter.coreElement.computePowerDC.k1",\
 "Gain of input signal 1 [1]", 73, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.inverter.coreElement.computePowerDC.k2",\
 "Gain of input signal 2 [1]", 74, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.pc.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.pc.i", \
"Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.p2.i", 1, 5,\
 129, 132)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.nc.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.nc.i", \
"Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.p2.i", -1, 5,\
 129, 132)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.pv.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.pv.i",\
 "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.nv.v",\
 "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.nv.i",\
 "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.power",\
 "Instantaneous power as output signal [W]", "partial_PMSM.eTraction.inverter.coreElement.P_AC", 1,\
 5, 211, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.voltageSensor.p.v",\
 "Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.voltageSensor.p.i",\
 "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.voltageSensor.n.v",\
 "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.voltageSensor.n.i",\
 "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.voltageSensor.v",\
 "Voltage between pin p and n (= p.v - n.v) as output signal [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.currentSensor.p.v",\
 "Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.currentSensor.p.i",\
 "Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.p2.i", 1, 5,\
 129, 132)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.currentSensor.n.v",\
 "Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.currentSensor.n.i",\
 "Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.p2.i", -1,\
 5, 129, 132)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.currentSensor.i",\
 "Current in the branch from p to n as output signal [A]", "partial_PMSM.eTraction.inverter.p2.i", 1,\
 5, 129, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.product.u1",\
 "Connector of Real input signal 1 [V]", "simplePower.constantVoltage.V", 1, 7, 35,\
 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.product.u2",\
 "Connector of Real input signal 2 [A]", "partial_PMSM.eTraction.inverter.p2.i", 1,\
 5, 129, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.powerSensorAC.product.y",\
 "Connector of Real output signal [W]", "partial_PMSM.eTraction.inverter.coreElement.P_AC", 1,\
 5, 211, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.p1.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.p1.i", \
"Current flowing into the pin [A]", "simplePower.pin_p.i", -1, 5, 75, 132)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.n1.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.n1.i", \
"Current flowing into the pin [A]", "simplePower.pin_n.i", -1, 5, 77, 132)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.p2.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.p2.i", \
"Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.p2.i", 1, 5,\
 129, 132)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.n2.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("partial_PMSM.eTraction.inverter.coreElement.n2.i", \
"Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.p2.i", -1, 5,\
 129, 132)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.P_AC", "[W]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("partial_PMSM.eTraction.inverter.coreElement.P_DC", "[W]", 0.0, \
0.0,0.0,0.0,0,576)
DeclareParameter("partial_PMSM.eTraction.inverter.gain.k", "Gain value multiplied with input signal [1]",\
 75, 0.5, 0.0,0.0,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.inverter.gain.u", "Input signal connector [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_PMSM.eTraction.inverter.gain.y", "Output signal connector [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTraction.inverter.addAbs.u1", "Connector of Real input signal 1 [W]",\
 "partial_PMSM.eTraction.inverter.product2.y", 1, 5, 138, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.addAbs.u2", "Connector of Real input signal 2 [W]",\
 "partial_PMSM.eTraction.inverter.product1.y", 1, 5, 134, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.addAbs.y", "Connector of Real output signal [W]",\
 "partial_PMSM.eTraction.inverter.gain.u", 1, 5, 213, 0)
DeclareVariable("partial_PMSM.eTraction.inverter.addAbs.u1_absActive", \
"Apply abs on u1 [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.inverter.addAbs.u2_absActive", \
"Apply abs on u2 [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.inverter.addAbs.y_absActive", \
"Apply abs on y [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,515)
DeclareParameter("partial_PMSM.eTraction.inverter.addAbs.k1", "Gain of upper input u1 [1]",\
 76, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.inverter.addAbs.k2", "Gain of lower input u2 [1]",\
 77, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.inverter.addAbs.add.u1", \
"Connector of Real input signal 1 [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_PMSM.eTraction.inverter.addAbs.add.u2", \
"Connector of Real input signal 2 [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_PMSM.eTraction.inverter.addAbs.add.y", "Connector of Real output signal [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_PMSM.eTraction.inverter.addAbs.add.k1", \
"Gain of input signal 1 [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.inverter.addAbs.add.k2", \
"Gain of input signal 2 [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("partial_PMSM.eTraction.inverter.addAbs.conditionalAbs_u1.u", \
"Connector of Real input signal [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.addAbs.conditionalAbs_u1.y", \
"Connector of Real output signal [W]", "partial_PMSM.eTraction.inverter.addAbs.add.u1", 1,\
 5, 218, 0)
DeclareVariable("partial_PMSM.eTraction.inverter.addAbs.conditionalAbs_u1.absActive",\
 "If true, then y = abs(u), if not y = u [:#(type=Boolean)]", true, 0.0,0.0,0.0,\
0,515)
DeclareAlias2("partial_PMSM.eTraction.inverter.addAbs.conditionalAbs_u1.abs.u", \
"Connector of Real input signal [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.addAbs.conditionalAbs_u1.abs.y", \
"Connector of Real output signal [W]", "partial_PMSM.eTraction.inverter.addAbs.add.u1", 1,\
 5, 218, 0)
DeclareVariable("partial_PMSM.eTraction.inverter.addAbs.conditionalAbs_u1.abs.generateEvent",\
 "Choose whether events shall be generated [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareAlias2("partial_PMSM.eTraction.inverter.addAbs.conditionalAbs_u2.u", \
"Connector of Real input signal [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.addAbs.conditionalAbs_u2.y", \
"Connector of Real output signal [W]", "partial_PMSM.eTraction.inverter.addAbs.add.u2", 1,\
 5, 219, 0)
DeclareVariable("partial_PMSM.eTraction.inverter.addAbs.conditionalAbs_u2.absActive",\
 "If true, then y = abs(u), if not y = u [:#(type=Boolean)]", true, 0.0,0.0,0.0,\
0,515)
DeclareAlias2("partial_PMSM.eTraction.inverter.addAbs.conditionalAbs_u2.abs.u", \
"Connector of Real input signal [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.addAbs.conditionalAbs_u2.abs.y", \
"Connector of Real output signal [W]", "partial_PMSM.eTraction.inverter.addAbs.add.u2", 1,\
 5, 219, 0)
DeclareVariable("partial_PMSM.eTraction.inverter.addAbs.conditionalAbs_u2.abs.generateEvent",\
 "Choose whether events shall be generated [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareAlias2("partial_PMSM.eTraction.inverter.addAbs.conditionalAbs_y.u", \
"Connector of Real input signal [W]", "partial_PMSM.eTraction.inverter.addAbs.add.y", 1,\
 5, 220, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.addAbs.conditionalAbs_y.y", \
"Connector of Real output signal [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 0)
DeclareVariable("partial_PMSM.eTraction.inverter.addAbs.conditionalAbs_y.absActive",\
 "If true, then y = abs(u), if not y = u [:#(type=Boolean)]", true, 0.0,0.0,0.0,\
0,515)
DeclareAlias2("partial_PMSM.eTraction.inverter.addAbs.conditionalAbs_y.abs.u", \
"Connector of Real input signal [W]", "partial_PMSM.eTraction.inverter.addAbs.add.y", 1,\
 5, 220, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.addAbs.conditionalAbs_y.abs.y", \
"Connector of Real output signal [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 0)
DeclareVariable("partial_PMSM.eTraction.inverter.addAbs.conditionalAbs_y.abs.generateEvent",\
 "Choose whether events shall be generated [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_lossesInverter.u", \
"Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 0)
DeclareVariable("partial_PMSM.eTraction.machine.useSupport", "true: stator is able to rotate, false: stator is fixed internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.machine.useThermalPort", \
"true: thermal connector is provided, false: temperature is fixed internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("partial_PMSM.eTraction.machine.pin_p.v", "Potential at the pin [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.pin_p.i", "Current flowing into the pin [A]",\
 "partial_PMSM.eTraction.inverter.p2.i", -1, 5, 129, 132)
DeclareVariable("partial_PMSM.eTraction.machine.pin_n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("partial_PMSM.eTraction.machine.pin_n.i", "Current flowing into the pin [A]",\
 "partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 132)
DeclareAlias2("partial_PMSM.eTraction.machine.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.flange.tau", "Cut torque in the flange [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 132)
DeclareAlias2("partial_PMSM.eTraction.machine.desiredTorque", "[N.m]", \
"partial_PMSM.eTraction.controller.setTorque", 1, 5, 93, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.electricPowerDC.pc.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricPowerDC.pc.i", \
"Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.p2.i", -1, 5,\
 129, 132)
DeclareAlias2("partial_PMSM.eTraction.machine.electricPowerDC.nc.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricPowerDC.nc.i", \
"Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.p2.i", 1, 5,\
 129, 132)
DeclareAlias2("partial_PMSM.eTraction.machine.electricPowerDC.pv.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareVariable("partial_PMSM.eTraction.machine.electricPowerDC.pv.i", \
"Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareVariable("partial_PMSM.eTraction.machine.electricPowerDC.nv.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("partial_PMSM.eTraction.machine.electricPowerDC.nv.i", \
"Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareVariable("partial_PMSM.eTraction.machine.electricPowerDC.power", \
"Instantaneous power as output signal [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTraction.machine.electricPowerDC.voltageSensor.p.v",\
 "Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareVariable("partial_PMSM.eTraction.machine.electricPowerDC.voltageSensor.p.i",\
 "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("partial_PMSM.eTraction.machine.electricPowerDC.voltageSensor.n.v",\
 "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("partial_PMSM.eTraction.machine.electricPowerDC.voltageSensor.n.i",\
 "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("partial_PMSM.eTraction.machine.electricPowerDC.voltageSensor.v", \
"Voltage between pin p and n (= p.v - n.v) as output signal [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.electricPowerDC.currentSensor.p.v",\
 "Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricPowerDC.currentSensor.p.i",\
 "Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.p2.i", -1,\
 5, 129, 132)
DeclareAlias2("partial_PMSM.eTraction.machine.electricPowerDC.currentSensor.n.v",\
 "Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricPowerDC.currentSensor.n.i",\
 "Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.p2.i", 1, 5,\
 129, 132)
DeclareAlias2("partial_PMSM.eTraction.machine.electricPowerDC.currentSensor.i", \
"Current in the branch from p to n as output signal [A]", "partial_PMSM.eTraction.inverter.p2.i", -1,\
 5, 129, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.electricPowerDC.product.u1", \
"Connector of Real input signal 1 [V]", "simplePower.constantVoltage.V", 1, 7, 35,\
 0)
DeclareAlias2("partial_PMSM.eTraction.machine.electricPowerDC.product.u2", \
"Connector of Real input signal 2 [A]", "partial_PMSM.eTraction.inverter.p2.i", -1,\
 5, 129, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.electricPowerDC.product.y", \
"Connector of Real output signal [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.torqueSensor.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", "partial_Brakes.brake.phi", 1, 5,\
 48, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.torqueSensor.flange_a.tau", \
"Cut torque in the flange [N.m]", "partial_PMSM.eTraction.flange.tau", 1, 5, 90,\
 132)
DeclareAlias2("partial_PMSM.eTraction.machine.torqueSensor.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", "partial_Brakes.brake.phi", 1, 5,\
 48, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.torqueSensor.flange_b.tau", \
"Cut torque in the flange [N.m]", "partial_PMSM.eTraction.flange.tau", -1, 5, 90,\
 132)
DeclareAlias2("partial_PMSM.eTraction.machine.torqueSensor.tau", \
"Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_electricPower.u", \
"Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 0)
DeclareVariable("partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", \
"Current min available torque [N.m]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_maxAvailableTorque.u", \
"Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_outerTorque.u", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 0)
DeclareVariable("partial_PMSM.eTraction.machine.toBus_innerTorque.u", \
"Electrical torque inside the machine [N.m]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_PMSM.eTraction.machine.toBus_mechanicPower.u", \
"Mechanic power at the machine's shaft [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("partial_PMSM.eTraction.machine.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 78, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("partial_PMSM.eTraction.machine.fixed.flange.phi", \
"Absolute rotation angle of flange [rad|deg]", "partial_PMSM.eTraction.machine.fixed.phi0", 1,\
 7, 78, 4)
DeclareVariable("partial_PMSM.eTraction.machine.fixed.flange.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("partial_PMSM.eTraction.machine.internalSupport.phi", \
"Absolute rotation angle of flange [rad|deg]", "partial_PMSM.eTraction.machine.fixed.phi0", 1,\
 7, 78, 1028)
DeclareVariable("partial_PMSM.eTraction.machine.internalSupport.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,2825)
DeclareAlias2("partial_PMSM.eTraction.machine.angleSensor.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", "partial_PMSM.eTraction.machine.fixed.phi0", 1,\
 7, 78, 4)
DeclareVariable("partial_PMSM.eTraction.machine.angleSensor.flange_a.tau", \
"Cut torque in the flange [N.m]", 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("partial_PMSM.eTraction.machine.angleSensor.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", "partial_Brakes.brake.phi", 1, 5,\
 48, 4)
DeclareVariable("partial_PMSM.eTraction.machine.angleSensor.flange_b.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("partial_PMSM.eTraction.machine.angleSensor.phi_rel", \
"Relative angle between two flanges (= flange_b.phi - flange_a.phi) as output signal [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTraction.machine.speedSensor.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", "partial_PMSM.eTraction.machine.fixed.phi0", 1,\
 7, 78, 4)
DeclareVariable("partial_PMSM.eTraction.machine.speedSensor.flange_a.tau", \
"Cut torque in the flange [N.m]", 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("partial_PMSM.eTraction.machine.speedSensor.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", "partial_Brakes.brake.phi", 1, 5,\
 48, 4)
DeclareVariable("partial_PMSM.eTraction.machine.speedSensor.flange_b.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("partial_PMSM.eTraction.machine.speedSensor.phi_rel", \
"Relative angle between two flanges (flange_b.phi - flange_a.phi) [rad|deg]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTraction.machine.speedSensor.der(phi_rel)", \
"der(Relative angle between two flanges (flange_b.phi - flange_a.phi)) [rad/s]",\
 "partial_Chassis.inertia.w", 1, 5, 64, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.speedSensor.w_rel", \
"Relative angular velocity between two flanges (= der(flange_b.phi) - der(flange_a.phi)) as output signal [rad/s]",\
 "partial_Chassis.inertia.w", 1, 5, 64, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftSpeed.u", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftAngle.u", \
"Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 0)
DeclareVariable("partial_PMSM.eTraction.machine.useVoltageGuess", \
"Use start value for iteration during initialization (setting 'start' with 'fixed=false') [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("partial_PMSM.eTraction.machine.V_guess", "Start value for iteration during initialization [V]",\
 79, 400, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.machine.data.J_r", "Ineratia of the machine's rotor [kg.m2]",\
 80, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.machine.data.enableFirstOrder", \
"Use a first order element to approximate the behaviour of the stator current and hence the inner torque [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("partial_PMSM.eTraction.machine.data.T", "Time constant of the first order element [s]",\
 81, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.machine.data.enableTorqueLimitation", \
"false: Torque limits will be set to inf [:#(type=Boolean)]", 82, true, 0.0,0.0,\
0.0,0,562)
DeclareVariable("partial_PMSM.eTraction.machine.data.P_max", "Maximium power provided by the machine (above nominal speed) [W]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.data.tau_max", "Maximum torque provided by the machine (up to nominal speed) [N.m]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.data.useSupport", \
"true: stator is able to rotate, false: stator is fixed internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.machine.data.useThermalPort", \
"true: thermal connector is provided, false: temperature is fixed internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("partial_PMSM.eTraction.machine.data.eta", "Total efficiency [1]",\
 83, 1, 0.0,1E+100,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.machine.data.variablePower", \
"Set power by parameter (true) or real input (false) [:#(type=Boolean)]", true, \
0.0,0.0,0.0,0,515)
DeclareParameter("partial_PMSM.eTraction.machine.data.P_constant", \
"Desired power: postive is consumed, negative is generated [W]", 84, 1, 0.0,0.0,\
0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.machine.data.V_min", "For lower voltages, power will be limited [V]",\
 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.data.V_max", "For higher voltages, power will be limited [V]",\
 100000.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("partial_PMSM.eTraction.machine.data.I_max", "Maximum possible DC current (-I_max < I < I_max) [A]",\
 85, 100000.0, 0.0,1E+100,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.machine.data.actionLim", \
"Optionally warn or stop when power is limited [:#(type=DymolaModels.Blocks.Choices.AssertActions)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareVariable("partial_PMSM.eTraction.machine.data.actionDiv0", \
"Optionally warn or stop when preventing divisions by zero [:#(type=DymolaModels.Blocks.Choices.AssertActions)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareVariable("partial_PMSM.eTraction.machine.data.V_eps", "Threshold for minimum voltage, values between +eps/-eps will be treated as eps [V]",\
 0.1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.data.useDynamics", \
"Use PT1 dynamics to filter the load's demanded power [:#(type=Boolean)]", false,\
 0.0,0.0,0.0,0,515)
DeclareParameter("partial_PMSM.eTraction.machine.data.T_PT1", "Time constant of optional PT1 [s]",\
 86, 0.001, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.machine.data.initType", \
"Type of initialization (1: no init, 2: steady state, 3/4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 87, 1, 1.0,4.0,0.0,0,564)
DeclareParameter("partial_PMSM.eTraction.machine.data.initialCurrent", \
"Initial current through the power source [A]", 88, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.J_r", \
"Ineratia of the machine's rotor [kg.m2]", 0.05, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.enableFirstOrder", \
"Use a first order element to approximate the behaviour of the stator current and hence the inner torque [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.T", "Time constant of the first order element [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.enableTorqueLimitation",\
 "false: Torque limits will be set to inf [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.P_max", \
"Maximium power provided by the machine (above nominal speed) [W]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.tau_max", \
"Maximum torque provided by the machine (up to nominal speed) [N.m]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.useSupport", \
"true: stator is able to rotate, false: stator is fixed internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.useThermalPort", \
"true: thermal connector is provided, false: temperature is fixed internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.eta", \
"Total efficiency [1]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.variablePower", \
"Set power by parameter (true) or real input (false) [:#(type=Boolean)]", true, \
0.0,0.0,0.0,0,515)
DeclareParameter("partial_PMSM.eTraction.machine.coreElement.P_constant", \
"Desired power: postive is consumed, negative is generated [W]", 89, 1, 0.0,0.0,\
0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.V_min", \
"For lower voltages, power will be limited [V]", 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.V_max", \
"For higher voltages, power will be limited [V]", 100000.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.I_max", \
"Maximum possible DC current (-I_max < I < I_max) [A]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.actionLim", \
"Optionally warn or stop when power is limited [:#(type=DymolaModels.Blocks.Choices.AssertActions)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.actionDiv0", \
"Optionally warn or stop when preventing divisions by zero [:#(type=DymolaModels.Blocks.Choices.AssertActions)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.V_eps", \
"Threshold for minimum voltage, values between +eps/-eps will be treated as eps [V]",\
 0.1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.useDynamics", \
"Use PT1 dynamics to filter the load's demanded power [:#(type=Boolean)]", false,\
 0.0,0.0,0.0,0,515)
DeclareParameter("partial_PMSM.eTraction.machine.coreElement.T_PT1", \
"Time constant of optional PT1 [s]", 90, 0.001, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.machine.coreElement.initType", \
"Type of initialization (1: no init, 2: steady state, 3/4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 91, 1, 1.0,4.0,0.0,0,564)
DeclareParameter("partial_PMSM.eTraction.machine.coreElement.initialCurrent", \
"Initial current through the power source [A]", 92, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.useVoltageGuess", \
"Use start value for iteration during initialization (setting 'start' with 'fixed=false') [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.V_guess", \
"Start value for iteration during initialization [V]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.pin_p.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.pin_p.i", \
"Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.p2.i", -1, 5,\
 129, 132)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.pin_n.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.pin_n.i", \
"Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.p2.i", 1, 5,\
 129, 132)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.flange.phi", \
"Absolute rotation angle of flange [rad|deg]", "partial_Brakes.brake.phi", 1, 5,\
 48, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.flange.tau", \
"Cut torque in the flange [N.m]", "partial_PMSM.eTraction.flange.tau", 1, 5, 90,\
 132)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.desiredTorque", \
"[N.m]", "partial_PMSM.eTraction.controller.setTorque", 1, 5, 93, 0)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.P_el", \
"Electric power of drive as output signal [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.P_mec", \
"Mechanic power of drive as output signal [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.speed", \
"Speed of drive as output signal [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.innerTorque", \
"Inner torque of drive as output signal [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.minAvailableTorque", \
"minimum available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.maxAvailableTorque", \
"maximum available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.limitDesiredTorque.desiredTorque",\
 "[N.m]", "partial_PMSM.eTraction.controller.setTorque", 1, 5, 93, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.limitDesiredTorque.speed",\
 "[rad/s|1/min]", "partial_Chassis.inertia.w", 1, 5, 64, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.limitDesiredTorque.setTorque",\
 "[N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1, 5, 240, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.limitDesiredTorque.maximumTorque",\
 "[N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1, 5, 239,\
 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.limitDesiredTorque.minimumTorque",\
 "[N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1, 5, 239,\
 0)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.limitDesiredTorque.enableTorqueLimitation",\
 "false: Torque limits will be set to inf [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.limitDesiredTorque.P_max",\
 "Maximium power provided by the machine (above nominal speed) [W]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.limitDesiredTorque.tau_max",\
 "Maximum torque provided by the machine (up to nominal speed) [N.m]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.limitDesiredTorque.characteristicSpeed",\
 "[rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.limitDesiredTorque.actualTorque",\
 "[N.m]", 0.0, 0.0,1E+100,0.0,0,2560)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.torque.useSupport", \
"= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.torque.flange.phi", \
"Absolute rotation angle of flange [rad|deg]", "partial_Brakes.brake.phi", 1, 5,\
 48, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.torque.flange.tau", \
"Cut torque in the flange [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", -1,\
 5, 240, 132)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.torque.phi_support",\
 "Absolute angle of support flange [rad|deg]", 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.torque.tau", \
"Accelerating torque acting at flange (= -flange.tau) [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.rotorInertia.flange_a.phi",\
 "Absolute rotation angle of flange [rad|deg]", "partial_Brakes.brake.phi", 1, 5,\
 48, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.rotorInertia.flange_a.tau",\
 "Cut torque in the flange [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 132)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.rotorInertia.flange_b.phi",\
 "Absolute rotation angle of flange [rad|deg]", "partial_Brakes.brake.phi", 1, 5,\
 48, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.rotorInertia.flange_b.tau",\
 "Cut torque in the flange [N.m]", "partial_PMSM.eTraction.flange.tau", 1, 5, 90,\
 132)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.rotorInertia.J", \
"Moment of inertia [kg.m2]", 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.rotorInertia.stateSelect",\
 "Priority to use phi and w as states [:#(type=StateSelect)]", 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.rotorInertia.phi", \
"Absolute rotation angle of component [rad|deg]", "partial_Brakes.brake.phi", 1,\
 5, 48, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.rotorInertia.der(phi)",\
 "der(Absolute rotation angle of component) [rad/s]", "partial_Chassis.inertia.w", 1,\
 5, 64, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.rotorInertia.w", \
"Absolute angular velocity of component (= der(phi)) [rad/s]", "partial_Chassis.inertia.w", 1,\
 5, 64, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.rotorInertia.der(w)", \
"der(Absolute angular velocity of component (= der(phi))) [rad/s2]", \
"partial_Chassis.damper.der(w_rel)", 1, 6, 1, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.rotorInertia.a", \
"Absolute angular acceleration of component (= der(w)) [rad/s2]", \
"partial_Chassis.damper.der(w_rel)", 1, 6, 1, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.noFirstOrder.u", \
"Connector of Real input signal [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.noFirstOrder.y", \
"Connector of Real output signal [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.multiSensor.flange_a.phi",\
 "Absolute rotation angle of flange [rad|deg]", "partial_Brakes.brake.phi", 1, 5,\
 48, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.multiSensor.flange_a.der(phi)",\
 "der(Absolute rotation angle of flange) [rad/s]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.multiSensor.flange_a.tau",\
 "Cut torque in the flange [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 132)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.multiSensor.flange_b.phi",\
 "Absolute rotation angle of flange [rad|deg]", "partial_Brakes.brake.phi", 1, 5,\
 48, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.multiSensor.flange_b.tau",\
 "Cut torque in the flange [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", -1,\
 5, 240, 132)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.multiSensor.power", \
"Power in flange flange_a as output signal [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.multiSensor.w", \
"Absolute angular velocity of flange_a as output signal [rad/s]", \
"partial_Chassis.inertia.w", 1, 5, 64, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.multiSensor.tau", \
"Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1, 5, 240, 0)
DeclareParameter("partial_PMSM.eTraction.machine.coreElement.signChange.k", \
"Gain value multiplied with input signal [1]", 93, -1, 0.0,0.0,0.0,0,560)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.signChange.u", \
"Input signal connector [W]", "partial_PMSM.eTraction.machine.coreElement.multiSensor.power", 1,\
 5, 293, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.signChange.y", \
"Output signal connector [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 0)
DeclareParameter("partial_PMSM.eTraction.machine.coreElement.fixed.phi0", \
"Fixed offset angle of housing [rad|deg]", 94, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.fixed.flange.phi", \
"Absolute rotation angle of flange [rad|deg]", "partial_PMSM.eTraction.machine.coreElement.fixed.phi0", 1,\
 7, 94, 4)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.fixed.flange.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.relSpeedSensor.flange_a.phi",\
 "Absolute rotation angle of flange [rad|deg]", "partial_PMSM.eTraction.machine.coreElement.fixed.phi0", 1,\
 7, 94, 4)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.relSpeedSensor.flange_a.tau",\
 "Cut torque in the flange [N.m]", 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.relSpeedSensor.flange_b.phi",\
 "Absolute rotation angle of flange [rad|deg]", "partial_Brakes.brake.phi", 1, 5,\
 48, 4)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.relSpeedSensor.flange_b.tau",\
 "Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.relSpeedSensor.phi_rel",\
 "Relative angle between two flanges (flange_b.phi - flange_a.phi) [rad|deg]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.relSpeedSensor.der(phi_rel)",\
 "der(Relative angle between two flanges (flange_b.phi - flange_a.phi)) [rad/s]",\
 "partial_Chassis.inertia.w", 1, 5, 64, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.relSpeedSensor.w_rel",\
 "Relative angular velocity between two flanges (= der(flange_b.phi) - der(flange_a.phi)) as output signal [rad/s]",\
 "partial_Chassis.inertia.w", 1, 5, 64, 0)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.P_actual",\
 "Instantaneous power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.i",\
 "Current through the load [A]", "partial_PMSM.eTraction.inverter.p2.i", -1, 5, 129,\
 0)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.i_limit",\
 "Instantaneous current limit [A]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.i_des",\
 "Instantaneous current limit [A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.v",\
 "Voltage drop of the two pins (= p.v - n.v) [V]", "simplePower.constantVoltage.V", 1,\
 7, 35, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.p.v",\
 "Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.p.i",\
 "Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.p2.i", -1,\
 5, 129, 132)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.n.v",\
 "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.n.i",\
 "Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.p2.i", 1, 5,\
 129, 132)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.variablePower",\
 "Set power by parameter (true) or real input (false) [:#(type=Boolean)]", true,\
 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.P_constant",\
 "Desired power: postive is consumed, negative is generated [W]", 1, 0.0,0.0,0.0,\
0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.V_min",\
 "For lower voltages, power will be limited [V]", 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.V_max",\
 "For higher voltages, power will be limited [V]", 100000.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.I_max",\
 "Maximum possible DC current (-I_max < I < I_max) [A]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.actionLim",\
 "Optionally warn or stop when power is limited [:#(type=DymolaModels.Blocks.Choices.AssertActions)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.actionDiv0",\
 "Optionally warn or stop when preventing divisions by zero [:#(type=DymolaModels.Blocks.Choices.AssertActions)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.V_eps",\
 "Threshold for minimum voltage, values between +eps/-eps will be treated as eps [V]",\
 0.1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.useDynamics",\
 "Use PT1 dynamics to filter the load's demanded power [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.T_PT1",\
 "Time constant of optional PT1 [s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.initType",\
 "Type of initialization (1: no init, 2: steady state, 3/4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.initialCurrent",\
 "Initial current through the power source [A]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.useVoltageGuess",\
 "Use start value for iteration during initialization (setting 'start' with 'fixed=false') [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.V_guess",\
 "Start value for iteration during initialization [V]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.P_variable",\
 "Desired power input, postive is consumed, negative is generated power [W]", \
"partial_PMSM.eTraction.machine.coreElement.P_el", 1, 5, 283, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.divNoZero.u1",\
 "Connector of Real input signal 1 [W]", "partial_PMSM.eTraction.machine.coreElement.P_el", 1,\
 5, 283, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.divNoZero.u2",\
 "Connector of Real input signal 2 [V]", "simplePower.constantVoltage.V", 1, 7, 35,\
 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.divNoZero.y",\
 "Connector of Real output signal [A]", "partial_PMSM.eTraction.machine.coreElement.electricPowerSource.i_des", 1,\
 5, 300, 0)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.divNoZero.eps",\
 "Smallest value used for division [V]", 0.1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.divNoZero.considerSign",\
 "True: sign is considered in case of 'b' < 'eps' [:#(type=Boolean)]", true, \
0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.divNoZero.action",\
 "Optionally inform about divisions by zero with asserts [:#(type=DymolaModels.Blocks.Choices.AssertActions)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.signalCurrent.p.v",\
 "Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.signalCurrent.p.i",\
 "Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.p2.i", -1,\
 5, 129, 132)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.signalCurrent.n.v",\
 "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.signalCurrent.n.i",\
 "Current flowing into the pin [A]", "partial_PMSM.eTraction.inverter.p2.i", 1, 5,\
 129, 132)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.signalCurrent.v",\
 "Voltage drop between the two pins (= p.v - n.v) [V]", "simplePower.constantVoltage.V", 1,\
 7, 35, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.signalCurrent.i",\
 "Current flowing from pin p to pin n as input signal [A]", "partial_PMSM.eTraction.inverter.p2.i", -1,\
 5, 129, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.desiredPower.y",\
 "Connector of Real output signal [W]", "partial_PMSM.eTraction.machine.coreElement.P_el", 1,\
 5, 283, 0)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.desiredPower.variableOutput",\
 "If true the input signal u is used as output, otherwise the parameter p [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.desiredPower.p",\
 "Constant output value [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.desiredPower.u",\
 "Variable output value [W]", "partial_PMSM.eTraction.machine.coreElement.P_el", 1,\
 5, 283, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.currentLimiter.u",\
 "Connector of Real input signal [A]", "partial_PMSM.eTraction.machine.coreElement.electricPowerSource.i_des", 1,\
 5, 300, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.currentLimiter.y",\
 "Connector of Real output signal [A]", "partial_PMSM.eTraction.inverter.p2.i", -1,\
 5, 129, 0)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.currentLimiter.strict",\
 "= true, if strict limits with noEvent(..) [:#(type=Boolean)]", true, 0.0,0.0,\
0.0,0,515)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.currentLimiter.homotopyType",\
 "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.VariableLimiterHomotopy)]",\
 2, 1.0,3.0,0.0,0,517)
DeclareParameter("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.currentLimiter.ySimplified",\
 "Fixed value of output in simplified model [A]", 95, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.currentLimiter.limit",\
 "Value used for maximum and minimum of input u [A]", "partial_PMSM.eTraction.machine.coreElement.electricPowerSource.i_limit", 1,\
 5, 299, 0)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.currentLimiter.limit1",\
 "Upper limit [A]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.currentLimiter.limit2",\
 "Lower limit [A]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.currentLimiter.simplifiedExpr",\
 "Simplified expression for homotopy-based initialization [A]", "partial_PMSM.eTraction.machine.coreElement.electricPowerSource.i_des", 1,\
 5, 300, 1024)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.positiveVoltage.u",\
 "Connector of Real input signal [V]", "simplePower.constantVoltage.V", 1, 7, 35,\
 0)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.positiveVoltage.y",\
 "Connector of Real output signal [V]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.positiveVoltage.generateEvent",\
 "Choose whether events shall be generated [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.limI_minV.u",\
 "Connector of Real input signal [V]", "partial_PMSM.eTraction.machine.coreElement.electricPowerSource.positiveVoltage.y", 1,\
 5, 326, 0)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.limI_minV.y",\
 "Connector of Real output signal [A]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.limI_minV.u1",\
 "Lower boundary of input u, switching from constant value y1 to sin^2 interpolation [V]",\
 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.limI_minV.u2",\
 "Upper boundary of input u, switching from sin^2 interpolation to constant value y2 [V]",\
 1, 0.0,0.0,0.0,0,513)
DeclareParameter("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.limI_minV.y1",\
 "Minimum value for y [A]", 96, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.limI_minV.y2",\
 "Maximum value for y [A]", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.limI_maxV.u",\
 "Connector of Real input signal [V]", "partial_PMSM.eTraction.machine.coreElement.electricPowerSource.positiveVoltage.y", 1,\
 5, 326, 0)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.limI_maxV.y",\
 "Connector of Real output signal [A]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.limI_maxV.u1",\
 "Lower boundary of input u, switching from constant value y1 to sin^2 interpolation [V]",\
 100000.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.limI_maxV.u2",\
 "Upper boundary of input u, switching from sin^2 interpolation to constant value y2 [V]",\
 110000.00000000001, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.limI_maxV.y1",\
 "Minimum value for y [A]", 0, 0.0,0.0,0.0,0,513)
DeclareParameter("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.limI_maxV.y2",\
 "Maximum value for y [A]", 97, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.voltageLimit.u1",\
 "Connector of Real input signal 1 [A]", "partial_PMSM.eTraction.machine.coreElement.electricPowerSource.limI_minV.y", 1,\
 5, 328, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.voltageLimit.u2",\
 "Connector of Real input signal 2 [A]", "partial_PMSM.eTraction.machine.coreElement.electricPowerSource.limI_maxV.y", 1,\
 5, 332, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.voltageLimit.y",\
 "Connector of Real output signal [A]", "partial_PMSM.eTraction.machine.coreElement.electricPowerSource.i_limit", 1,\
 5, 299, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.noFirstOrder.u",\
 "Connector of Real input signal [A]", "partial_PMSM.eTraction.inverter.p2.i", -1,\
 5, 129, 1024)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.noFirstOrder.y",\
 "Connector of Real output signal [A]", "partial_PMSM.eTraction.inverter.p2.i", -1,\
 5, 129, 1024)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.voltageSensor.p.v",\
 "Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 1028)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.voltageSensor.p.i",\
 "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,2825)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.voltageSensor.n.v",\
 "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,2569)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.voltageSensor.n.i",\
 "Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,2825)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.electricPowerSource.voltageSensor.v",\
 "Voltage between pin p and n (= p.v - n.v) as output signal [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 1024)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.internalSupport.phi", \
"Absolute rotation angle of flange [rad|deg]", "partial_PMSM.eTraction.machine.coreElement.fixed.phi0", 1,\
 7, 94, 1028)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.internalSupport.tau",\
 "Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,2825)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.compute_P_el.eta", \
"Efficiency [1]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.compute_P_el.resultingPower.u1",\
 "Connector of Real input signal 1 [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 0)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.compute_P_el.resultingPower.u2",\
 "Connector of Real input signal 2 [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.compute_P_el.resultingPower.y",\
 "Connector of Real output signal [W]", "partial_PMSM.eTraction.machine.coreElement.P_el", 1,\
 5, 283, 0)
DeclareParameter("partial_PMSM.eTraction.machine.coreElement.compute_P_el.resultingPower.k1",\
 "Gain of input signal 1 [1]", 98, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.machine.coreElement.compute_P_el.resultingPower.k2",\
 "Gain of input signal 2 [1]", 99, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.compute_P_el.losses.k",\
 "Gain value multiplied with input signal [1]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.machine.coreElement.compute_P_el.losses.u",\
 "Input signal connector [W]", 0, 0.0,0.0,0.0,0,576)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.compute_P_el.losses.y",\
 "Output signal connector [W]", "partial_PMSM.eTraction.machine.coreElement.compute_P_el.resultingPower.u2", 1,\
 5, 341, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.compute_P_el.providedPower.u1",\
 "Connector of Real input signal 1 [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.compute_P_el.providedPower.u2",\
 "Connector of Real input signal 2 [W]", "partial_PMSM.eTraction.machine.coreElement.P_el", 1,\
 5, 283, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.compute_P_el.providedPower.y",\
 "Connector of Real output signal [W]", "partial_PMSM.eTraction.machine.coreElement.compute_P_el.losses.u", 1,\
 5, 343, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.compute_P_el.u", "[W]",\
 "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1, 5, 241, 0)
DeclareAlias2("partial_PMSM.eTraction.machine.coreElement.compute_P_el.y", "[W]",\
 "partial_PMSM.eTraction.machine.coreElement.P_el", 1, 5, 283, 0)
DeclareAlias2("partial_PMSM.eTraction.speedSensor.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 4)
DeclareAlias2("partial_PMSM.eTraction.speedSensor.flange.der(phi)", \
"der(Absolute rotation angle of flange) [rad/s]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareVariable("partial_PMSM.eTraction.speedSensor.flange.tau", \
"Cut torque in the flange [N.m]", 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("partial_PMSM.eTraction.speedSensor.w", "Absolute angular velocity of flange as output signal [rad/s]",\
 "partial_Chassis.inertia.w", 1, 5, 64, 0)
DeclareAlias2("partial_PMSM.multiSensor.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 4)
DeclareAlias2("partial_PMSM.multiSensor.flange_a.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "partial_Chassis.inertia.w", 1, 5, 64, 4)
DeclareAlias2("partial_PMSM.multiSensor.flange_a.tau", "Cut torque in the flange [N.m]",\
 "partial_PMSM.eTraction.flange.tau", -1, 5, 90, 132)
DeclareAlias2("partial_PMSM.multiSensor.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 4)
DeclareAlias2("partial_PMSM.multiSensor.flange_b.tau", "Cut torque in the flange [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 132)
DeclareVariable("partial_PMSM.multiSensor.power", "Power in flange flange_a as output signal [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.multiSensor.w", "Absolute angular velocity of flange_a as output signal [rad/s]",\
 "partial_Chassis.inertia.w", 1, 5, 64, 0)
DeclareAlias2("partial_PMSM.multiSensor.tau", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 "partial_PMSM.eTraction.flange.tau", -1, 5, 90, 0)
DeclareVariable("partial_PMSM.motorSwitch.feedback", "[rad/s]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareAlias2("partial_PMSM.motorSwitch.u", "[rad/s]", "partial_Driver.VelocityRequest", 1,\
 5, 0, 0)
DeclareAlias2("partial_PMSM.motorSwitch.y", "[rad/s]", "partial_Chassis.inertia.w", 1,\
 5, 64, 0)
DeclareVariable("partial_PMSM.motorSwitch.regenReference", "[rad/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.motorSwitch.tractionReference", "[rad/s]", \
"partial_PMSM.eTraction.desiredSpeed", 1, 5, 92, 0)
DeclareAlias2("partial_PMSM.eTractionPowerSensor.pc.v", "Potential at the pin [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTractionPowerSensor.pc.i", "Current flowing into the pin [A]",\
 "simplePower.pin_p.i", -1, 5, 75, 132)
DeclareAlias2("partial_PMSM.eTractionPowerSensor.nc.v", "Potential at the pin [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTractionPowerSensor.nc.i", "Current flowing into the pin [A]",\
 "simplePower.pin_p.i", 1, 5, 75, 132)
DeclareAlias2("partial_PMSM.eTractionPowerSensor.pv.v", "Potential at the pin [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareVariable("partial_PMSM.eTractionPowerSensor.pv.i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("partial_PMSM.eTractionPowerSensor.nv.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("partial_PMSM.eTractionPowerSensor.nv.i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("partial_PMSM.eTractionPowerSensor.power", "Instantaneous power as output signal [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTractionPowerSensor.voltageSensor.p.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareVariable("partial_PMSM.eTractionPowerSensor.voltageSensor.p.i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("partial_PMSM.eTractionPowerSensor.voltageSensor.n.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("partial_PMSM.eTractionPowerSensor.voltageSensor.n.i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("partial_PMSM.eTractionPowerSensor.voltageSensor.v", \
"Voltage between pin p and n (= p.v - n.v) as output signal [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 0)
DeclareAlias2("partial_PMSM.eTractionPowerSensor.currentSensor.p.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTractionPowerSensor.currentSensor.p.i", \
"Current flowing into the pin [A]", "simplePower.pin_p.i", -1, 5, 75, 132)
DeclareAlias2("partial_PMSM.eTractionPowerSensor.currentSensor.n.v", \
"Potential at the pin [V]", "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTractionPowerSensor.currentSensor.n.i", \
"Current flowing into the pin [A]", "simplePower.pin_p.i", 1, 5, 75, 132)
DeclareAlias2("partial_PMSM.eTractionPowerSensor.currentSensor.i", \
"Current in the branch from p to n as output signal [A]", "simplePower.pin_p.i", -1,\
 5, 75, 0)
DeclareAlias2("partial_PMSM.eTractionPowerSensor.product.u1", "Connector of Real input signal 1 [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 0)
DeclareAlias2("partial_PMSM.eTractionPowerSensor.product.u2", "Connector of Real input signal 2 [A]",\
 "simplePower.pin_p.i", -1, 5, 75, 0)
DeclareAlias2("partial_PMSM.eTractionPowerSensor.product.y", "Connector of Real output signal [W]",\
 "partial_PMSM.eTractionPowerSensor.power", 1, 5, 351, 0)
DeclareAlias2("partial_PMSM.pin_p.v", "Potential at the pin [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.pin_p.i", "Current flowing into the pin [A]", \
"simplePower.pin_p.i", -1, 5, 75, 132)
DeclareVariable("partial_PMSM.pin_n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("partial_PMSM.pin_n.i", "Current flowing into the pin [A]", \
"simplePower.pin_n.i", -1, 5, 77, 132)
DeclareAlias2("partial_PMSM.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 4)
DeclareAlias2("partial_PMSM.flange_a.tau", "Cut torque in the flange [N.m]", \
"partial_Brakes.flange_a.tau", -1, 5, 25, 132)
DeclareAlias2("partial_PMSM.velocityRequest", "[rad/s]", "partial_Driver.VelocityRequest", 1,\
 5, 0, 0)
DeclareAlias2("partial_PMSM.brakeRequest", "", "partial_Controller.brakeAllowance", 1,\
 5, 20, 0)
DeclareAlias2("partial_PMSM.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 4)
DeclareAlias2("partial_PMSM.inertia.flange_a.tau", "Cut torque in the flange [N.m]",\
 "partial_PMSM.eTraction.flange.tau", -1, 5, 90, 132)
DeclareAlias2("partial_PMSM.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 4)
DeclareAlias2("partial_PMSM.inertia.flange_b.tau", "Cut torque in the flange [N.m]",\
 "partial_Brakes.flange_a.tau", -1, 5, 25, 132)
DeclareParameter("partial_PMSM.inertia.J", "Moment of inertia [kg.m2]", 100, 1, \
0.0,1E+100,0.0,0,560)
DeclareVariable("partial_PMSM.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("partial_PMSM.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 "partial_Brakes.brake.phi", 1, 5, 48, 0)
DeclareAlias2("partial_PMSM.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "partial_Chassis.inertia.w", 1, 5, 64, 0)
DeclareAlias2("partial_PMSM.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 "partial_Chassis.inertia.w", 1, 5, 64, 0)
DeclareAlias2("partial_PMSM.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 "partial_Chassis.damper.der(w_rel)", 1, 6, 1, 0)
DeclareAlias2("partial_PMSM.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "partial_Chassis.damper.der(w_rel)", 1, 6, 1, 0)
DeclareAlias2("partial_PMSM.feedback.u1", "[rad/s]", "partial_Driver.VelocityRequest", 1,\
 5, 0, 0)
DeclareAlias2("partial_PMSM.feedback.u2", "[rad/s]", "partial_Chassis.inertia.w", 1,\
 5, 64, 0)
DeclareVariable("partial_PMSM.feedback.y", "[rad/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.negative.u", "[rad/s]", "partial_PMSM.feedback.y", 1,\
 5, 357, 0)
DeclareAlias2("partial_PMSM.negative.y", "", "partial_Controller.brakeAllowance", 1,\
 5, 20, 0)
DeclareAlias2("partial_PMSM.negative.sign1.u", "Connector of Real input signal [rad/s]",\
 "partial_PMSM.feedback.y", 1, 5, 357, 0)
DeclareVariable("partial_PMSM.negative.sign1.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_PMSM.negative.sign1.generateEvent", "Choose whether events shall be generated [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("partial_PMSM.negative.add.u1", "Connector of Real input signal 1",\
 "partial_PMSM.negative.const.k", 1, 7, 103, 0)
DeclareAlias2("partial_PMSM.negative.add.u2", "Connector of Real input signal 2",\
 "partial_PMSM.negative.sign1.y", 1, 5, 358, 0)
DeclareVariable("partial_PMSM.negative.add.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("partial_PMSM.negative.add.k1", "Gain of input signal 1", 101, 1,\
 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.negative.add.k2", "Gain of input signal 2", 102, \
0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.negative.const.k", "Constant output value", 103, \
-0.5, 0.0,0.0,0.0,0,560)
DeclareAlias2("partial_PMSM.negative.const.y", "Connector of Real output signal",\
 "partial_PMSM.negative.const.k", 1, 7, 103, 0)
DeclareAlias2("partial_PMSM.negative.product1.u1", "Connector of Real input signal 1",\
 "partial_PMSM.negative.add.y", 1, 5, 360, 0)
DeclareAlias2("partial_PMSM.negative.product1.u2", "Connector of Real input signal 2 [rad/s]",\
 "partial_PMSM.feedback.y", 1, 5, 357, 0)
DeclareAlias2("partial_PMSM.negative.product1.y", "Connector of Real output signal",\
 "partial_Controller.brakeAllowance", 1, 5, 20, 0)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.I.k", \
"Integrator gain [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.I.use_reset",\
 "=true, if reset port enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.I.use_set", \
"=true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.I.initType", \
"Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.I.y_start", \
"Initial or guess value of output (= state)", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.I.u", \
"Connector of Real input signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("partial_PMSM.eTraction.controller.coreElement.PID.I.y", \
"Connector of Real output signal", 2, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("partial_PMSM.eTraction.controller.coreElement.PID.I.der(y)", \
"der(Connector of Real output signal)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.I.local_reset",\
 "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.I.local_set",\
 "", 0, 0.0,0.0,0.0,0,1537)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.addI.k1", \
"Gain of input signal 1", 104, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.addI.k2", \
"Gain of input signal 2", 105, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.addI.k3", \
"Gain of input signal 3", 106, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.addI.u1", \
"Connector of Real input signal 1 [rad/s]", "partial_PMSM.eTraction.desiredSpeed", 1,\
 5, 92, 0)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.addI.u2", \
"Connector of Real input signal 2 [rad/s]", "partial_Chassis.inertia.w", 1, 5, 64,\
 0)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.addI.u3", \
"Connector of Real input signal 3", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.addI.y", \
"Connector of Real output signal", "partial_PMSM.eTraction.controller.coreElement.PID.I.u", 1,\
 5, 366, 0)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.addSat.u1", \
"Connector of Real input signal 1 [N.m]", "partial_PMSM.eTraction.controller.setTorque", 1,\
 5, 93, 0)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.addSat.u2", \
"Connector of Real input signal 2 [N.m]", "partial_PMSM.eTraction.controller.coreElement.PID.limiter.u", 1,\
 5, 123, 0)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.addSat.y", \
"Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.addSat.k1", \
"Gain of input signal 1", 107, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("partial_PMSM.eTraction.controller.coreElement.PID.addSat.k2", \
"Gain of input signal 2", 108, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("partial_PMSM.eTraction.controller.coreElement.PID.gainTrack.k",\
 "Gain value multiplied with input signal [1]", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.gainTrack.u", \
"Input signal connector", "partial_PMSM.eTraction.controller.coreElement.PID.addSat.y", 1,\
 5, 370, 0)
DeclareAlias2("partial_PMSM.eTraction.controller.coreElement.PID.gainTrack.y", \
"Output signal connector", "partial_PMSM.eTraction.controller.coreElement.PID.addI.u3", 1,\
 5, 369, 0)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterVoltageDC.electricDriveBus.voltageDC",\
 "DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterCurrentDC.electricDriveBus.currentDC",\
 "DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerAC.electricDriveBus.powerAC",\
 "AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerDC.electricDriveBus.powerDC",\
 "DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_currentAC_EA.electricDriveBus.currentAC_EA",\
 "AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_voltageAC_EA.electricDriveBus.voltageAC_EA",\
 "AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_lossesInverter.electricDriveBus.lossesInverter",\
 "Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_electricPower.electricDriveBus.electricPower",\
 "Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_minAvailableTorque.electricDriveBus.minAvailableTorque",\
 "Current min available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_maxAvailableTorque.electricDriveBus.maxAvailableTorque",\
 "Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_outerTorque.electricDriveBus.outerTorque",\
 "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_innerTorque.electricDriveBus.innerTorque",\
 "Electrical torque inside the machine [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_mechanicPower.electricDriveBus.mechanicPower",\
 "Mechanic power at the machine's shaft [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftSpeed.electricDriveBus.rotorSpeed",\
 "Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftAngle.electricDriveBus.rotorAngle",\
 "Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 4)
DeclareAlias2("partial_PMSM.eTraction.electricDriveBus.currentAC_EA", \
"AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 4)
DeclareAlias2("partial_PMSM.eTraction.electricDriveBus.currentDC", \
"DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 4)
DeclareAlias2("partial_PMSM.eTraction.electricDriveBus.electricPower", \
"Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 4)
DeclareAlias2("partial_PMSM.eTraction.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 4)
DeclareAlias2("partial_PMSM.eTraction.electricDriveBus.lossesInverter", \
"Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 4)
DeclareAlias2("partial_PMSM.eTraction.electricDriveBus.maxAvailableTorque", \
"Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.electricDriveBus.mechanicPower", \
"Mechanic power at the machine's shaft [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 4)
DeclareAlias2("partial_PMSM.eTraction.electricDriveBus.minAvailableTorque", \
"Current min available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 4)
DeclareAlias2("partial_PMSM.eTraction.electricDriveBus.powerAC", \
"AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 4)
DeclareAlias2("partial_PMSM.eTraction.electricDriveBus.powerDC", \
"DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 4)
DeclareAlias2("partial_PMSM.eTraction.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 4)
DeclareAlias2("partial_PMSM.eTraction.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.electricDriveBus.voltageAC_EA", \
"AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.electricDriveBus.voltageDC", \
"DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.electricDriveBus.currentAC_EA", \
"AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.electricDriveBus.currentDC", \
"DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.electricDriveBus.electricPower", \
"Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.electricDriveBus.lossesInverter",\
 "Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.electricDriveBus.maxAvailableTorque",\
 "Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.electricDriveBus.mechanicPower", \
"Mechanic power at the machine's shaft [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.electricDriveBus.minAvailableTorque",\
 "Current min available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.electricDriveBus.powerAC", \
"AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.electricDriveBus.powerDC", \
"DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.electricDriveBus.voltageAC_EA", \
"AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.electricDriveBus.voltageDC", \
"DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_currentAC_EA.electricDriveBus.currentDC",\
 "DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_currentAC_EA.electricDriveBus.electricPower",\
 "Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_currentAC_EA.electricDriveBus.innerTorque",\
 "Electrical torque inside the machine [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_currentAC_EA.electricDriveBus.lossesInverter",\
 "Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_currentAC_EA.electricDriveBus.maxAvailableTorque",\
 "Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_currentAC_EA.electricDriveBus.mechanicPower",\
 "Mechanic power at the machine's shaft [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_currentAC_EA.electricDriveBus.minAvailableTorque",\
 "Current min available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_currentAC_EA.electricDriveBus.outerTorque",\
 "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_currentAC_EA.electricDriveBus.powerAC",\
 "AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_currentAC_EA.electricDriveBus.powerDC",\
 "DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_currentAC_EA.electricDriveBus.rotorAngle",\
 "Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_currentAC_EA.electricDriveBus.rotorSpeed",\
 "Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_currentAC_EA.electricDriveBus.voltageAC_EA",\
 "AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_currentAC_EA.electricDriveBus.voltageDC",\
 "DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterCurrentDC.electricDriveBus.currentAC_EA",\
 "AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterCurrentDC.electricDriveBus.electricPower",\
 "Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterCurrentDC.electricDriveBus.innerTorque",\
 "Electrical torque inside the machine [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterCurrentDC.electricDriveBus.lossesInverter",\
 "Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterCurrentDC.electricDriveBus.maxAvailableTorque",\
 "Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterCurrentDC.electricDriveBus.mechanicPower",\
 "Mechanic power at the machine's shaft [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterCurrentDC.electricDriveBus.minAvailableTorque",\
 "Current min available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterCurrentDC.electricDriveBus.outerTorque",\
 "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterCurrentDC.electricDriveBus.powerAC",\
 "AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterCurrentDC.electricDriveBus.powerDC",\
 "DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterCurrentDC.electricDriveBus.rotorAngle",\
 "Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterCurrentDC.electricDriveBus.rotorSpeed",\
 "Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterCurrentDC.electricDriveBus.voltageAC_EA",\
 "AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterCurrentDC.electricDriveBus.voltageDC",\
 "DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerAC.electricDriveBus.currentAC_EA",\
 "AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerAC.electricDriveBus.currentDC",\
 "DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerAC.electricDriveBus.electricPower",\
 "Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerAC.electricDriveBus.innerTorque",\
 "Electrical torque inside the machine [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerAC.electricDriveBus.lossesInverter",\
 "Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerAC.electricDriveBus.maxAvailableTorque",\
 "Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerAC.electricDriveBus.mechanicPower",\
 "Mechanic power at the machine's shaft [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerAC.electricDriveBus.minAvailableTorque",\
 "Current min available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerAC.electricDriveBus.outerTorque",\
 "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerAC.electricDriveBus.powerDC",\
 "DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerAC.electricDriveBus.rotorAngle",\
 "Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerAC.electricDriveBus.rotorSpeed",\
 "Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerAC.electricDriveBus.voltageAC_EA",\
 "AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerAC.electricDriveBus.voltageDC",\
 "DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerDC.electricDriveBus.currentAC_EA",\
 "AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerDC.electricDriveBus.currentDC",\
 "DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerDC.electricDriveBus.electricPower",\
 "Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerDC.electricDriveBus.innerTorque",\
 "Electrical torque inside the machine [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerDC.electricDriveBus.lossesInverter",\
 "Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerDC.electricDriveBus.maxAvailableTorque",\
 "Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerDC.electricDriveBus.mechanicPower",\
 "Mechanic power at the machine's shaft [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerDC.electricDriveBus.minAvailableTorque",\
 "Current min available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerDC.electricDriveBus.outerTorque",\
 "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerDC.electricDriveBus.powerAC",\
 "AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerDC.electricDriveBus.rotorAngle",\
 "Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerDC.electricDriveBus.rotorSpeed",\
 "Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerDC.electricDriveBus.voltageAC_EA",\
 "AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterPowerDC.electricDriveBus.voltageDC",\
 "DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterVoltageDC.electricDriveBus.currentAC_EA",\
 "AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterVoltageDC.electricDriveBus.currentDC",\
 "DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterVoltageDC.electricDriveBus.electricPower",\
 "Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterVoltageDC.electricDriveBus.innerTorque",\
 "Electrical torque inside the machine [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterVoltageDC.electricDriveBus.lossesInverter",\
 "Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterVoltageDC.electricDriveBus.maxAvailableTorque",\
 "Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterVoltageDC.electricDriveBus.mechanicPower",\
 "Mechanic power at the machine's shaft [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterVoltageDC.electricDriveBus.minAvailableTorque",\
 "Current min available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterVoltageDC.electricDriveBus.outerTorque",\
 "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterVoltageDC.electricDriveBus.powerAC",\
 "AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterVoltageDC.electricDriveBus.powerDC",\
 "DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterVoltageDC.electricDriveBus.rotorAngle",\
 "Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterVoltageDC.electricDriveBus.rotorSpeed",\
 "Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_inverterVoltageDC.electricDriveBus.voltageAC_EA",\
 "AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_lossesInverter.electricDriveBus.currentAC_EA",\
 "AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_lossesInverter.electricDriveBus.currentDC",\
 "DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_lossesInverter.electricDriveBus.electricPower",\
 "Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_lossesInverter.electricDriveBus.innerTorque",\
 "Electrical torque inside the machine [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_lossesInverter.electricDriveBus.maxAvailableTorque",\
 "Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_lossesInverter.electricDriveBus.mechanicPower",\
 "Mechanic power at the machine's shaft [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_lossesInverter.electricDriveBus.minAvailableTorque",\
 "Current min available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_lossesInverter.electricDriveBus.outerTorque",\
 "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_lossesInverter.electricDriveBus.powerAC",\
 "AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_lossesInverter.electricDriveBus.powerDC",\
 "DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_lossesInverter.electricDriveBus.rotorAngle",\
 "Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_lossesInverter.electricDriveBus.rotorSpeed",\
 "Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_lossesInverter.electricDriveBus.voltageAC_EA",\
 "AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_lossesInverter.electricDriveBus.voltageDC",\
 "DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_voltageAC_EA.electricDriveBus.currentAC_EA",\
 "AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_voltageAC_EA.electricDriveBus.currentDC",\
 "DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_voltageAC_EA.electricDriveBus.electricPower",\
 "Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_voltageAC_EA.electricDriveBus.innerTorque",\
 "Electrical torque inside the machine [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_voltageAC_EA.electricDriveBus.lossesInverter",\
 "Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_voltageAC_EA.electricDriveBus.maxAvailableTorque",\
 "Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_voltageAC_EA.electricDriveBus.mechanicPower",\
 "Mechanic power at the machine's shaft [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_voltageAC_EA.electricDriveBus.minAvailableTorque",\
 "Current min available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_voltageAC_EA.electricDriveBus.outerTorque",\
 "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_voltageAC_EA.electricDriveBus.powerAC",\
 "AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_voltageAC_EA.electricDriveBus.powerDC",\
 "DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_voltageAC_EA.electricDriveBus.rotorAngle",\
 "Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_voltageAC_EA.electricDriveBus.rotorSpeed",\
 "Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.inverter.toBus_voltageAC_EA.electricDriveBus.voltageDC",\
 "DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricDriveBus.currentAC_EA", \
"AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricDriveBus.currentDC", \
"DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricDriveBus.electricPower", \
"Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricDriveBus.lossesInverter", \
"Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricDriveBus.maxAvailableTorque",\
 "Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricDriveBus.mechanicPower", \
"Mechanic power at the machine's shaft [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricDriveBus.minAvailableTorque",\
 "Current min available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricDriveBus.powerAC", \
"AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricDriveBus.powerDC", \
"DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricDriveBus.voltageAC_EA", \
"AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.electricDriveBus.voltageDC", \
"DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_electricPower.electricDriveBus.currentAC_EA",\
 "AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_electricPower.electricDriveBus.currentDC",\
 "DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_electricPower.electricDriveBus.innerTorque",\
 "Electrical torque inside the machine [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_electricPower.electricDriveBus.lossesInverter",\
 "Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_electricPower.electricDriveBus.maxAvailableTorque",\
 "Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_electricPower.electricDriveBus.mechanicPower",\
 "Mechanic power at the machine's shaft [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_electricPower.electricDriveBus.minAvailableTorque",\
 "Current min available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_electricPower.electricDriveBus.outerTorque",\
 "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_electricPower.electricDriveBus.powerAC",\
 "AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_electricPower.electricDriveBus.powerDC",\
 "DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_electricPower.electricDriveBus.rotorAngle",\
 "Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_electricPower.electricDriveBus.rotorSpeed",\
 "Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_electricPower.electricDriveBus.voltageAC_EA",\
 "AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_electricPower.electricDriveBus.voltageDC",\
 "DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_innerTorque.electricDriveBus.currentAC_EA",\
 "AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_innerTorque.electricDriveBus.currentDC",\
 "DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_innerTorque.electricDriveBus.electricPower",\
 "Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_innerTorque.electricDriveBus.lossesInverter",\
 "Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_innerTorque.electricDriveBus.maxAvailableTorque",\
 "Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_innerTorque.electricDriveBus.mechanicPower",\
 "Mechanic power at the machine's shaft [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_innerTorque.electricDriveBus.minAvailableTorque",\
 "Current min available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_innerTorque.electricDriveBus.outerTorque",\
 "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_innerTorque.electricDriveBus.powerAC",\
 "AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_innerTorque.electricDriveBus.powerDC",\
 "DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_innerTorque.electricDriveBus.rotorAngle",\
 "Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_innerTorque.electricDriveBus.rotorSpeed",\
 "Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_innerTorque.electricDriveBus.voltageAC_EA",\
 "AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_innerTorque.electricDriveBus.voltageDC",\
 "DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_maxAvailableTorque.electricDriveBus.currentAC_EA",\
 "AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_maxAvailableTorque.electricDriveBus.currentDC",\
 "DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_maxAvailableTorque.electricDriveBus.electricPower",\
 "Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_maxAvailableTorque.electricDriveBus.innerTorque",\
 "Electrical torque inside the machine [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_maxAvailableTorque.electricDriveBus.lossesInverter",\
 "Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_maxAvailableTorque.electricDriveBus.mechanicPower",\
 "Mechanic power at the machine's shaft [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_maxAvailableTorque.electricDriveBus.minAvailableTorque",\
 "Current min available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_maxAvailableTorque.electricDriveBus.outerTorque",\
 "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_maxAvailableTorque.electricDriveBus.powerAC",\
 "AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_maxAvailableTorque.electricDriveBus.powerDC",\
 "DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_maxAvailableTorque.electricDriveBus.rotorAngle",\
 "Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_maxAvailableTorque.electricDriveBus.rotorSpeed",\
 "Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_maxAvailableTorque.electricDriveBus.voltageAC_EA",\
 "AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_maxAvailableTorque.electricDriveBus.voltageDC",\
 "DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_mechanicPower.electricDriveBus.currentAC_EA",\
 "AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_mechanicPower.electricDriveBus.currentDC",\
 "DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_mechanicPower.electricDriveBus.electricPower",\
 "Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_mechanicPower.electricDriveBus.innerTorque",\
 "Electrical torque inside the machine [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_mechanicPower.electricDriveBus.lossesInverter",\
 "Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_mechanicPower.electricDriveBus.maxAvailableTorque",\
 "Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_mechanicPower.electricDriveBus.minAvailableTorque",\
 "Current min available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_mechanicPower.electricDriveBus.outerTorque",\
 "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_mechanicPower.electricDriveBus.powerAC",\
 "AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_mechanicPower.electricDriveBus.powerDC",\
 "DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_mechanicPower.electricDriveBus.rotorAngle",\
 "Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_mechanicPower.electricDriveBus.rotorSpeed",\
 "Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_mechanicPower.electricDriveBus.voltageAC_EA",\
 "AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_mechanicPower.electricDriveBus.voltageDC",\
 "DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_minAvailableTorque.electricDriveBus.currentAC_EA",\
 "AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_minAvailableTorque.electricDriveBus.currentDC",\
 "DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_minAvailableTorque.electricDriveBus.electricPower",\
 "Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_minAvailableTorque.electricDriveBus.innerTorque",\
 "Electrical torque inside the machine [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_minAvailableTorque.electricDriveBus.lossesInverter",\
 "Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_minAvailableTorque.electricDriveBus.maxAvailableTorque",\
 "Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_minAvailableTorque.electricDriveBus.mechanicPower",\
 "Mechanic power at the machine's shaft [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_minAvailableTorque.electricDriveBus.outerTorque",\
 "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_minAvailableTorque.electricDriveBus.powerAC",\
 "AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_minAvailableTorque.electricDriveBus.powerDC",\
 "DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_minAvailableTorque.electricDriveBus.rotorAngle",\
 "Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_minAvailableTorque.electricDriveBus.rotorSpeed",\
 "Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_minAvailableTorque.electricDriveBus.voltageAC_EA",\
 "AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_minAvailableTorque.electricDriveBus.voltageDC",\
 "DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_outerTorque.electricDriveBus.currentAC_EA",\
 "AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_outerTorque.electricDriveBus.currentDC",\
 "DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_outerTorque.electricDriveBus.electricPower",\
 "Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_outerTorque.electricDriveBus.innerTorque",\
 "Electrical torque inside the machine [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_outerTorque.electricDriveBus.lossesInverter",\
 "Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_outerTorque.electricDriveBus.maxAvailableTorque",\
 "Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_outerTorque.electricDriveBus.mechanicPower",\
 "Mechanic power at the machine's shaft [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_outerTorque.electricDriveBus.minAvailableTorque",\
 "Current min available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_outerTorque.electricDriveBus.powerAC",\
 "AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_outerTorque.electricDriveBus.powerDC",\
 "DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_outerTorque.electricDriveBus.rotorAngle",\
 "Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_outerTorque.electricDriveBus.rotorSpeed",\
 "Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_outerTorque.electricDriveBus.voltageAC_EA",\
 "AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_outerTorque.electricDriveBus.voltageDC",\
 "DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftAngle.electricDriveBus.currentAC_EA",\
 "AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftAngle.electricDriveBus.currentDC",\
 "DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftAngle.electricDriveBus.electricPower",\
 "Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftAngle.electricDriveBus.innerTorque",\
 "Electrical torque inside the machine [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftAngle.electricDriveBus.lossesInverter",\
 "Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftAngle.electricDriveBus.maxAvailableTorque",\
 "Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftAngle.electricDriveBus.mechanicPower",\
 "Mechanic power at the machine's shaft [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftAngle.electricDriveBus.minAvailableTorque",\
 "Current min available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftAngle.electricDriveBus.outerTorque",\
 "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftAngle.electricDriveBus.powerAC",\
 "AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftAngle.electricDriveBus.powerDC",\
 "DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftAngle.electricDriveBus.rotorSpeed",\
 "Mechanic rotational speed of machine's shaft [rad/s|1/min]", "partial_Chassis.inertia.w", 1,\
 5, 64, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftAngle.electricDriveBus.voltageAC_EA",\
 "AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftAngle.electricDriveBus.voltageDC",\
 "DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftSpeed.electricDriveBus.currentAC_EA",\
 "AC current of the inverter used for energy analysis (EA) models [A]", \
"partial_PMSM.eTraction.inverter.p2.i", 1, 5, 129, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftSpeed.electricDriveBus.currentDC",\
 "DC current of the inverter [A]", "simplePower.pin_p.i", -1, 5, 75, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftSpeed.electricDriveBus.electricPower",\
 "Electric power of the machine [W]", "partial_PMSM.eTraction.machine.electricPowerDC.power", 1,\
 5, 235, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftSpeed.electricDriveBus.innerTorque",\
 "Electrical torque inside the machine [N.m]", "partial_PMSM.eTraction.machine.toBus_innerTorque.u", 1,\
 5, 240, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftSpeed.electricDriveBus.lossesInverter",\
 "Sum of Diode and Switch losses: Inverter losses [W]", "partial_PMSM.eTraction.inverter.gain.u", 1,\
 5, 213, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftSpeed.electricDriveBus.maxAvailableTorque",\
 "Current max available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", -1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftSpeed.electricDriveBus.mechanicPower",\
 "Mechanic power at the machine's shaft [W]", "partial_PMSM.eTraction.machine.toBus_mechanicPower.u", 1,\
 5, 241, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftSpeed.electricDriveBus.minAvailableTorque",\
 "Current min available torque [N.m]", "partial_PMSM.eTraction.machine.toBus_minAvailableTorque.u", 1,\
 5, 239, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftSpeed.electricDriveBus.outerTorque",\
 "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "partial_PMSM.eTraction.flange.tau", 1, 5, 90, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftSpeed.electricDriveBus.powerAC",\
 "AC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product2.y", 1,\
 5, 138, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftSpeed.electricDriveBus.powerDC",\
 "DC Power of the inverter [W]", "partial_PMSM.eTraction.inverter.product1.y", 1,\
 5, 134, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftSpeed.electricDriveBus.rotorAngle",\
 "Mechanic angle of machine's shaft [rad|deg]", "partial_PMSM.eTraction.machine.angleSensor.phi_rel", 1,\
 5, 246, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftSpeed.electricDriveBus.voltageAC_EA",\
 "AC voltage of the inverter used for energy analysis (EA) models [V]", \
"simplePower.constantVoltage.V", 1, 7, 35, 4)
DeclareAlias2("partial_PMSM.eTraction.machine.toBus_shaftSpeed.electricDriveBus.voltageDC",\
 "DC voltage of the inverter, if battery and inverter are ideally connected it is equal to the battery voltage [V]",\
 "simplePower.constantVoltage.V", 1, 7, 35, 4)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
if (initialCall) DYNX(did_->xInitial_var, 1)=DYNX(W_,212);
else if (DYNHReject) DYNX(W_,212)=did_->xInitial_var2[1]; else did_->xInitial_var2[1]=
  DYNX(W_,212);
if (initialCall) DYNX(did_->xInitial_var, 0)=DYNX(W_,343);
else if (DYNHReject) DYNX(W_,343)=did_->xInitial_var2[0]; else did_->xInitial_var2[0]=
  DYNX(W_,343);
}
StartDataBlock
StartPreBlock
preWD(DYNX(W_,33),"partial_Brakes.brake.free", false, 0);
preD(DYNX(W_,43),"partial_Brakes.brake.mode", 3, 1);
pre(DYNX(W_,36),"partial_Brakes.brake.startBackward", false, 5);
pre(DYNX(W_,35),"partial_Brakes.brake.startForward", false, 4);
pre(DYNX(W_,16),"partial_Driver.combiTimeTable.nextTimeEvent", 0, 3);
preI(DYNX(W_,17),"partial_Driver.combiTimeTable.nextTimeEventScaled", 0, 2);
EndPreBlock
StartEqBlock
DoRemember_(DYNX(W_,34), 0.0, 0);
DoRememAcc_(DYNX(W_,212), 0.0, 2);
DoRememAcc_(DYNX(W_,343), 0, 1);
EndEqBlock
UpdateQEvaluate(2)
EndDataBlock

BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionEnd()
