#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model ElectricVehicle2.Motors.SpeedControlled
 Dymola Version 2021 (64-bit), 2020-05-13 translated this at Wed Feb 24 15:40:54 2021

   */

#include <matrixop.h>
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays6[3]={0.0, 0.0, 0.0};
static double DymArrays3[3]={2E-05, 0.00013, 0.00028};
static double DymArrays2[3]={0.00013, 0.00028, 2E-05};
static double DymArrays5[3]={0.00015, 0.0003, 3.0};
static double DymArrays0[3]={3.0, 3.0, 3.0};
static double DymArrays7[3]={293.15, 293.15, 293.15};
static double DymArrays8[6]={0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
static double DymArrays1[7]={3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0};
static double DymArrays4[12]={0.6666666666666666, -0.33333333333333315, 
  -0.3333333333333336, 0.0, 0.5773502691896257, -0.5773502691896256, 1.0, 0.0, 
  -0.4999999999999998, 0.8660254037844387, -0.5000000000000004, -0.8660254037844385};
#endif
/* Declaration of C-structs */
/* Prototypes for functions used in model */
DYMOLA_STATIC double   DymolaModels_Functions_Math_divNoZero(double  a0_0, 
  double  b0_0, double  eps0_0, int  considerSign0_0);
struct Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor_struct {
  RealArray    y0_0_0member;
  double   y00_0_0member;
};
DYMOLA_STATIC struct Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor_struct
   Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor(RealArray  
   x0_0);
DYMOLA_STATIC double   Modelica_Electrical_Machines_SpacePhasors_Functions_activePower
  (RealArray   v0_0, RealArray   i0_0);
DYMOLA_STATIC RealArray    Modelica_Electrical_MultiPhase_Functions_symmetricOrientation
  (int  m0_0);
DYMOLA_STATIC RealArray    cos_For_1_0(RealArray   u0_0);
DYMOLA_STATIC RealArray    sin_For_1_0(RealArray   u0_0);
/* Codes used in model */

/* Flattened Modelica model:

function DymolaModels.Functions.Math.divNoZero
discrete input Real a "Dividend";
discrete input Real b "Divisor";
discrete input Real eps(start = 1E-60) "Smallest value used for division";
input Boolean considerSign(start = true) "True: sign is considered in case of 'b' < 'eps'";
discrete output Real c "Quotient";

algorithm 
if (abs(b) < abs(eps)) then 
if (considerSign) then 
c := (if b >= 0 then a/eps else a/( -eps));
else
c := a/eps;
end if;
else
c := a/b;
end if;
annotation(derivative=DymolaModels.Functions.Math.divNoZero_der, smoothOrder=0);
end DymolaModels.Functions.Math.divNoZero;

  */
DYMOLA_STATIC double   DymolaModels_Functions_Math_divNoZero(double  a0_0, 
  double  b0_0, double  eps0_0, int  considerSign0_0) {
  PushContext("DymolaModels.Functions.Math.divNoZero")
  {
    /* Declare outputs and temporaries */
    double   c0_0;
    c0_0=0;
    /* Start of real code */
      if (fabs(b0_0) < fabs(eps0_0)) {
        if (considerSign0_0) {
          c0_0 = IF b0_0 >= 0 THEN divGuarded(a0_0,"a",eps0_0,"eps") ELSE 
            divGuarded(a0_0,"a", -eps0_0," -eps");
        }
        else{
          c0_0 = divGuarded(a0_0,"a",eps0_0,"eps");
        }
      }
      else{
        c0_0 = divGuarded(a0_0,"a",b0_0,"b");
      }
    /* Output section */
    PopContext()
    return c0_0;
  }}

/* Flattened Modelica model:

function Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor
discrete input Real x[:] "Multi phase (voltage or current) input";
discrete output Real y[2] "Space phasor";
discrete output Real y0 "Zero sequence component (of voltage or current)";
protected 
parameter Integer m = size(x, 1) "Number of phases";
parameter Real phi[m](unit = "rad", displayUnit = "deg") = Modelica.Electrical.MultiPhase.Functions.symmetricOrientation(m);
parameter Real TransformationMatrix[2, m] = 2*{cos(phi), sin(phi)}/m;
parameter Real InverseTransformation[m, 2] = array({cos(phi[k]),  -sin( -phi[k])} for k in 1:m);
public 
algorithm 
y := TransformationMatrix*x;
y0 := 1/m*sum(x);
annotation(Inline=true);
end Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor;

  */
DYMOLA_STATIC struct Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor_struct
   Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor(RealArray  
   x0_0) {
  PushContext("Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor")
  {
    /* Declare outputs and temporaries */
    RealArray    y0_0;
    double   y00_0;
    int   m0_0;
    RealArray    phi0_0;
    RealArray    TransformationMatrix0_0;
    RealArray    InverseTransformation0_0;
    RealArray    helperx_00;
    MarkObject retmark_ = PushMark();
    y0_0=RealTemporary( 1, 2);
    RePushMark(&retmark_);
    RealFillAssign( y0_0, 0);
    y00_0=0;
    m0_0 = DYNSizeSimple(x0_0, 1);
    phi0_0=RealTemporary( 1, m0_0);
    PushMark();
    RealAssign (phi0_0, Modelica_Electrical_MultiPhase_Functions_symmetricOrientation
      (m0_0));
    Release();
    TransformationMatrix0_0=RealTemporary( 2, 2, m0_0);
    PushMark();
    RealAssign (TransformationMatrix0_0, RealScaleDiv (RealScale (RealArrayArray 
      ( 2, cos_For_1_0(phi0_0), sin_For_1_0(phi0_0)),2),m0_0));
    Release();
    helperx_00=RealTemporary( 2, IntegerBmax(0, m0_0), 2);
    PushMark();
    RealFillAssign( helperx_00, 0);
    InverseTransformation0_0=RealTemporary( 2, m0_0, 2);
    PushMark();
    {
      int end_ = m0_0;
      int k0_0_0;
      for(k0_0_0 = 1;k0_0_0 <= end_;k0_0_0 += 1) {
        RealPutSub( RealScalarArray ( 2, cos(RealElement( phi0_0, (SizeType)(
          k0_0_0))),  -sin( -RealElement( phi0_0, (SizeType)(k0_0_0)))), 
          helperx_00 , Index, (Integer)(k0_0_0) ,Colon  , EndMark);
        Release();
      }
    }
    RealAssign (InverseTransformation0_0, helperx_00);
    Release();
    /* Start of real code */
      RealAssign (y0_0, RealMultiplyMV (TransformationMatrix0_0,x0_0));
      Release();
      y00_0 = divinvGuarded(m0_0,"m")*Realsum( x0_0);
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor_struct out_;
      out_.y0_0_0member = y0_0;
      out_.y00_0_0member = y00_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Electrical.Machines.SpacePhasors.Functions.activePower
discrete input Real v[m](unit = "V") "phase voltages";
discrete input Real i[m](unit = "A") "phase currents";
discrete output Real p(unit = "W") "Active power";
protected 
constant Integer m = 3 "Number of phases";
discrete Real v_[2](unit = "V") "Voltage space phasor";
discrete Real i_[2](unit = "A") "Current space phasor";
public 
algorithm 
v_ := zeros(2);
i_ := zeros(2);
for k in (1:m) loop
v_ := v_+2/m*{cos((k-1)/m*2*3.141592653589793), sin((k-1)/m*2*3.141592653589793)}*v[k];
i_ := i_+2/m*{cos((k-1)/m*2*3.141592653589793), sin((k-1)/m*2*3.141592653589793)}*i[k];
end for;
p := m/2*(v_[1]*i_[1]+v_[2]*i_[2]);
annotation(Inline=true);
end Modelica.Electrical.Machines.SpacePhasors.Functions.activePower;

  */
DYMOLA_STATIC double   Modelica_Electrical_Machines_SpacePhasors_Functions_activePower
  (RealArray   v0_0, RealArray   i0_0) {
  PushContext("Modelica.Electrical.Machines.SpacePhasors.Functions.activePower")
  {
    /* Declare outputs and temporaries */
    double   p0_0;
    int   m0_0;
    RealArray    vx_0;
    RealArray    ix_0;
    MarkObject retmark_ = PushMark();
    p0_0=0;
    m0_0 = 3;
    vx_0=RealTemporary( 1, 2);
    PushMark();
    RealFillAssign( vx_0, 0);
    ix_0=RealTemporary( 1, 2);
    PushMark();
    RealFillAssign( ix_0, 0);
    AssertModelica(DYNSizeSimple(v0_0,1)==m0_0,"size(v, 1) == m","Dimension check of input to function failed");
    AssertModelica(DYNSizeSimple(i0_0,1)==m0_0,"size(i, 1) == m","Dimension check of input to function failed");
    /* Start of real code */
      RealFillAssign (vx_0, 0);
      Release();
      RealFillAssign (ix_0, 0);
      Release();
      {
        int end_ = m0_0;
        int k0_0_0;
        for(k0_0_0 = 1;k0_0_0 <= end_;k0_0_0 += 1) {
          RealAssign (vx_0, RealAdd (vx_0,RealScale (RealScale (RealScalarArray 
            ( 2, cos(divGuarded(k0_0_0-1,"k-1",m0_0,"m")*2*3.141592653589793), 
            sin(divGuarded(k0_0_0-1,"k-1",m0_0,"m")*2*3.141592653589793)),
            divGuarded(2,"2",m0_0,"m")),RealElement( v0_0, (SizeType)(k0_0_0)))));
          Release();
          RealAssign (ix_0, RealAdd (ix_0,RealScale (RealScale (RealScalarArray 
            ( 2, cos(divGuarded(k0_0_0-1,"k-1",m0_0,"m")*2*3.141592653589793), 
            sin(divGuarded(k0_0_0-1,"k-1",m0_0,"m")*2*3.141592653589793)),
            divGuarded(2,"2",m0_0,"m")),RealElement( i0_0, (SizeType)(k0_0_0)))));
          Release();
        }
      }
      p0_0 = m0_0/(double)(2)*(RealVectorElement( vx_0, (SizeType)(1))*
        RealVectorElement( ix_0, (SizeType)(1))+RealVectorElement( vx_0, 
        (SizeType)(2))*RealVectorElement( ix_0, (SizeType)(2)));
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return p0_0;
  }}

/* Flattened Modelica model:

function Modelica.Electrical.MultiPhase.Functions.symmetricOrientation
input Integer m "Number of phases";
discrete output Real orientation[m](unit = "rad", displayUnit = "deg") "Orientation of the resulting fundamental wave field phasors";

algorithm 
if (mod(m, 2) == 0) then 
if (m == 2) then 
orientation[1] := 0;
orientation[2] := 1.5707963267948966;
else
orientation[1:integer(m/2)] := Modelica.Electrical.MultiPhase.Functions.symmetricOrientation(integer(m/2));
orientation[integer(m/2)+1:m] := Modelica.Electrical.MultiPhase.Functions.symmetricOrientation(integer(m/2))-fill(3.141592653589793/m, integer(m/2));
end if;
else
orientation := array((k-1)*2*3.141592653589793/m for k in 1:m);
end if;
end Modelica.Electrical.MultiPhase.Functions.symmetricOrientation;

  */
DYMOLA_STATIC RealArray    Modelica_Electrical_MultiPhase_Functions_symmetricOrientation
  (int  m0_0) {
  PushContext("Modelica.Electrical.MultiPhase.Functions.symmetricOrientation")
  {
    /* Declare outputs and temporaries */
    RealArray    orientation0_0;
    RealArray    helperx_00;
    MarkObject retmark_ = PushMark();
    orientation0_0=RealTemporary( 1, m0_0);
    RePushMark(&retmark_);
    RealFillAssign( orientation0_0, 0);
    helperx_00=RealTemporary( 1, IntegerBmax(0, m0_0));
    PushMark();
    RealFillAssign( helperx_00, 0);
    /* Start of real code */
      if (real2integer(modulusDymola(m0_0, 2)) == 0) {
        if (m0_0 == 2) {
          SetRealElement(0, orientation0_0, (SizeType)(1));
          SetRealElement(1.5707963267948966, orientation0_0, (SizeType)(2));
        }
        else{
          RealPutSub( Modelica_Electrical_MultiPhase_Functions_symmetricOrientation
            (real2integer(m0_0/(double)(2))), orientation0_0 ,Range , (Integer)(1),
             (Integer)(real2integer(m0_0/(double)(2))) , EndMark);
          Release();
          RealPutSub( RealSubtract (Modelica_Electrical_MultiPhase_Functions_symmetricOrientation
            (real2integer(m0_0/(double)(2))),RealFill( divGuarded(
            3.141592653589793,"3.141592653589793",m0_0,"m"), 1, (SizeType)(
            real2integer(m0_0/(double)(2))))), orientation0_0 ,Range , (Integer)
            (real2integer(m0_0/(double)(2))+1), (Integer)(m0_0) , EndMark);
          Release();
        }
      }
      else{
        {
          int end_ = m0_0;
          int k0_0_0;
          for(k0_0_0 = 1;k0_0_0 <= end_;k0_0_0 += 1) {
            SetRealElement(divGuarded((k0_0_0-1)*2*3.141592653589793,
              "(k-1)*2*3.141592653589793",m0_0,"m"), helperx_00, (SizeType)(
              k0_0_0));
          }
        }
        RealAssign (orientation0_0, helperx_00);
        Release();
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return orientation0_0;
  }}
DYMOLA_STATIC RealArray    cos_For_1_0(RealArray   u0_0) {
  PushContext("Vectorized ""cos")
   {
    RealArray   y0_0 = RealTemporary(  1, RealSize( u0_0, 1));
    int i_ ;
    int max_size_ = RealNrElements( y0_0);
    for(i_ = 0 ; i_ < max_size_; i_++) {
      y0_0.data[i_]=cos(u0_0.data[i_]);
    }
    PopContext()
    return y0_0;
  }
}
DYMOLA_STATIC RealArray    sin_For_1_0(RealArray   u0_0) {
  PushContext("Vectorized ""sin")
   {
    RealArray   y0_0 = RealTemporary(  1, RealSize( u0_0, 1));
    int i_ ;
    int max_size_ = RealNrElements( y0_0);
    for(i_ = 0 ; i_ < max_size_; i_++) {
      y0_0.data[i_]=sin(u0_0.data[i_]);
    }
    PopContext()
    return y0_0;
  }
}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
BreakSectionFunctionDef(2)
  BreakSectionDef(3);
BreakSectionFunctionDef(4)
BreakSectionFunctionDef(5)
BreakSectionFunctionDef(6)
#define NX_    18
#define NX2_   2
#define NU_    0
#define NY_    0
#define NW_    977
#define NP_    175
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   2
#define MAXAuxStr_   10
#define MAXAuxStrLen_   500
#define NHash1_ 336019004
#define NHash2_ 67256905
#define NHash3_ 0
#define NI_    0
#define NRelF_ 13
#define NRel_  13
#define NTim_  4
#define NSamp_ 0
#define NCons_ 0
#define NA_    1328
#define SizePre_ 0
#define SizeEq_ 9
#define SizeDelay_ 0
#define QNLmax_ 2
#define MAXAux 4
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 407
#define NGlobalHelpI_ 80
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="ElectricVehicle2.Motors.SpeedControlled";
#endif
DYMOLA_STATIC const char*usedLibraries[]={"ElectrifiedPTLib",0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/kunjs/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[30]={9 , 10 , 1 , 7 , 8 , 9 , 10 , 11 , 12 , 13
   , 14 , 15 , 1 , 2 , 1 , 3 , 1 , 4 , 1 , 5 , 1 , 6 , 1 , 16 , 1 , 17 , 1 , 18
   , 0 , 0};
static int QJacobianGrp0[19]={1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
   0, 0};
static int QJacobianGrp1[19]={2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0,
   0, 0};
static int QJacobianGrp2[19]={3, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0,
   0, 0};
static int QJacobianGrp3[19]={4, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0,
   0, 0};
static int QJacobianGrp4[19]={5, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0,
   0, 0};
static int QJacobianGrp5[19]={6, 6, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
   0, 0};
static int QJacobianGrp6[19]={16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
   16, 16, 16, 16, 16, 0};
static int QJacobianGrp7[19]={17, 17, 0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
   17, 17, 17, 17, 0, 0};
static int QJacobianGrp8[19]={18, 18, 0, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
   18, 18, 18, 18, 18, 0};
DYMOLA_STATIC struct QJacobianTag_ QJacobianGC2_[10]={
{0, QJacobianGrp0},{0, QJacobianGrp1},{0, QJacobianGrp2},{0, QJacobianGrp3},{0, 
  QJacobianGrp4},{0, QJacobianGrp5},{0, QJacobianGrp6},{0, QJacobianGrp7},{0, 
  QJacobianGrp8},{0,0}};
DYMOLA_STATIC double QJacobianCD_[19]={0  , 44 , 50 , 54 , 56 , 56 , 54 , 110 , 121
   , 132 , 143 , 154 , 165 , 176 , 187 , 198 , 95 , 80 , 63};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,0) = 3;
DYNX(W_,1) = 1;
DYNX(W_,8) = false;
DYNX(W_,31) = false;
DYNX(W_,32) = false;
DYNX(W_,33) = 3;
DYNX(W_,42) = 3;
DYNX(W_,52) = false;
DYNX(W_,54) = false;
DYNX(W_,66) = 3;
DYNX(W_,70) = 3;
DYNX(W_,85) = true;
DYNX(W_,121) = 3;
DYNX(W_,122) = 3;
DYNX(W_,124) = 3;
DYNX(W_,128) = 3;
DYNX(W_,129) = 3;
DYNX(W_,142) = 3;
DYNX(W_,143) = true;
DYNX(W_,151) = true;
DYNX(W_,159) = true;
DYNX(W_,167) = true;
DYNX(W_,198) = true;
DYNX(W_,203) = 3;
DYNX(W_,220) = 3;
DYNX(W_,221) = 3;
DYNX(W_,228) = 3;
DYNX(W_,232) = 3;
DYNX(W_,233) = 3;
DYNX(W_,241) = true;
DYNX(W_,244) = false;
DYNX(W_,245) = 3;
DYNX(W_,246) = false;
DYNX(W_,247) = 293.15;
DYNX(W_,251) = 3;
DYNX(W_,257) = false;
DYNX(W_,269) = 3;
DYNX(W_,281) = 3.141592653589793;
DYNX(W_,282) = 3;
DYNX(W_,294) = false;
DYNX(W_,331) = false;
DYNX(W_,357) = true;
DYNX(W_,370) = false;
DYNX(W_,380) = 3;
DYNX(W_,381) = 1;
DYNX(W_,382) = false;
memcpy(&DYNX(W_,383), &DymArrays0, sizeof(double)*3);
DYNX(W_,387) = 3;
DYNX(W_,388) = 3;
DYNX(W_,398) = false;
DYNX(W_,399) = false;
DYNX(W_,404) = 3;
DYNX(W_,405) = 3;
DYNX(W_,409) = 3;
DYNX(W_,413) = 3;
DYNX(W_,414) = 3;
DYNX(W_,418) = 3;
memcpy(&DYNX(W_,431), &DymArrays1, sizeof(double)*7);
DYNX(W_,441) = 3;
DYNX(W_,457) = 3;
DYNX(W_,458) = 3;
memcpy(&DYNX(W_,470), &DymArrays0, sizeof(double)*3);
memcpy(&DYNX(W_,479), &DymArrays0, sizeof(double)*3);
DYNX(W_,490) = false;
DYNX(W_,497) = false;
DYNX(W_,498) = 1;
memcpy(&DYNX(W_,500), &DymArrays2, sizeof(double)*3);
DYNX(W_,510) = 1;
memcpy(&DYNX(W_,513), &DymArrays3, sizeof(double)*3);
DYNX(W_,552) = true;
DYNX(W_,557) = 3;
DYNX(W_,558) = 3;
memcpy(&DYNX(W_,563), &DymArrays2, sizeof(double)*3);
DYNX(W_,568) = 1;
DYNX(W_,578) = 0.00015;
DYNX(W_,579) = 0.0003;
DYNX(W_,604) = 1;
DYNX(W_,605) = 1;
DYNX(W_,630) = 3;
DYNX(W_,636) = false;
DYNX(W_,637) = 1;
DYNX(W_,645) = true;
DYNX(W_,646) = true;
DYNX(W_,651) = 2;
DYNX(W_,653) = 1E-60;
DYNX(W_,679) = 0.00015;
DYNX(W_,680) = 0.0003;
DYNX(W_,700) = 3;
DYNX(W_,704) = 3;
DYNX(W_,710) = true;
DYNX(W_,711) = 1;
DYNX(W_,722) = true;
DYNX(W_,723) = true;
DYNX(W_,724) = false;
DYNX(W_,725) = false;
DYNX(W_,726) = false;
DYNX(W_,727) = false;
DYNX(W_,728) = false;
DYNX(W_,731) = false;
DYNX(W_,732) = false;
DYNX(W_,733) = false;
DYNX(W_,734) = false;
DYNX(W_,735) = false;
DYNX(W_,736) = false;
DYNX(W_,737) = false;
DYNX(W_,742) = false;
DYNX(W_,756) = false;
DYNX(W_,757) = false;
DYNX(W_,761) = false;
DYNX(W_,762) = false;
DYNX(W_,770) = false;
DYNX(W_,771) = false;
DYNX(W_,775) = false;
DYNX(W_,776) = false;
DYNX(W_,780) = false;
DYNX(W_,781) = false;
DYNX(W_,785) = false;
DYNX(W_,786) = false;
DYNX(W_,790) = false;
DYNX(W_,791) = false;
DYNX(W_,802) = false;
DYNX(W_,803) = false;
DYNX(W_,807) = false;
DYNX(W_,808) = false;
DYNX(W_,823) = true;
DYNX(W_,824) = true;
DYNX(W_,844) = 3;
DYNX(W_,850) = false;
DYNX(W_,851) = false;
DYNX(W_,863) = false;
DYNX(W_,864) = false;
DYNX(W_,12) = 0.001;
DYNX(W_,18) = 0.0;
DYNX(W_,41) = false;
DYNX(W_,59) = 0.001;
DYNX(W_,82) = 0.001;
DYNX(W_,92) = 0.0;
DYNX(W_,193) = 0.0;
DYNX(W_,197) = 1;
DYNX(W_,204) = 1;
memcpy(&DYNX(W_,208), &DymArrays4, sizeof(double)*12);
DYNX(W_,259) = 293.15;
DYNX(W_,261) = 293.15;
DYNX(W_,264) = 293.15;
DYNX(W_,266) = 293.15;
DYNX(W_,326) = 293.15;
DYNX(W_,270) = 293.15;
DYNX(W_,279) = 293.15;
DYNX(W_,299) = 3;
DYNX(W_,323) = 0.0;
DYNX(W_,324) = 0.0;
DYNX(W_,349) = 3;
#endif
DYNSetAuxString(did_, "ExplicitEuler", 0);
#if defined(DynSimStruct) || defined(BUILDFMU)
memcpy(&DYNX(W_,507), &DymArrays5, sizeof(double)*3);
DYNX(W_,512) = 2E-05;
DYNX(W_,516) = 0.00015;
DYNX(W_,517) = 0.0003;
DYNX(W_,518) = false;
DYNX(W_,521) = 0.001;
DYNX(W_,526) = 0.0;
DYNX(W_,596) = 1;
DYNX(W_,600) = 1;
DYNX(W_,607) = 0.00015;
DYNX(W_,608) = 0.0003;
DYNX(W_,610) = 0.00015;
DYNX(W_,611) = 0.0003;
DYNX(W_,616) = -0.0003;
DYNX(W_,619) = 0.00015;
DYNX(W_,633) = 3;
DYNX(W_,634) = true;
DYNX(W_,635) = false;
DYNX(W_,642) = false;
DYNX(W_,643) = 2;
DYNX(W_,644) = true;
DYNX(W_,648) = 1;
DYNX(W_,656) = 0.00013;
DYNX(W_,657) = 0.00028;
DYNX(W_,664) = false;
DYNX(W_,665) = 2;
DYNX(W_,666) = true;
DYNX(W_,670) = false;
DYNX(W_,671) = 2;
DYNX(W_,672) = true;
DYNX(W_,687) = 0.00015;
DYNX(W_,688) = 0.0003;
DYNX(W_,699) = 0.816496580927726;
DYNX(W_,707) = 3;
DYNX(W_,708) = true;
DYNX(W_,709) = false;
DYNX(W_,716) = false;
DYNX(W_,717) = 2;
DYNX(W_,718) = true;
DYNX(W_,721) = false;
#endif
DYNSetAuxString(did_, "ExplicitEuler", 1);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,758) = 3;
DYNX(W_,763) = 3;
DYNX(W_,766) = true;
DYNX(W_,767) = 2;
DYNX(W_,768) = true;
DYNX(W_,772) = 3;
DYNX(W_,777) = 3;
DYNX(W_,782) = 3;
DYNX(W_,787) = 3;
DYNX(W_,792) = 3;
#endif
DYNSetAuxString(did_, "", 2);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,804) = 3;
DYNX(W_,809) = 3;
#endif
DYNSetAuxString(did_, "", 4);
DYNSetAuxString(did_, "", 6);
DYNSetAuxString(did_, "", 8);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,825) = 1;
DYNX(W_,841) = 0.5773502691896258;
DYNX(W_,843) = 1;
DYNX(W_,845) = 293.15;
DYNX(W_,852) = 3;
DYNX(W_,865) = 3;
DYNX(W_,876) = false;
DYNX(W_,880) = false;
DYNX(W_,884) = false;
DYNX(W_,888) = false;
DYNX(W_,892) = false;
DYNX(W_,896) = false;
DYNX(W_,900) = false;
DYNX(W_,904) = false;
DYNX(W_,908) = false;
DYNX(W_,912) = false;
DYNX(W_,916) = false;
DYNX(W_,920) = false;
DYNX(W_,924) = false;
DYNX(W_,928) = false;
DYNX(W_,932) = false;
DYNX(W_,936) = false;
DYNX(W_,940) = false;
DYNX(W_,944) = false;
DYNX(W_,948) = false;
DYNX(W_,952) = false;
DYNX(W_,956) = false;
DYNX(W_,960) = false;
DYNX(W_,964) = false;
DYNX(W_,968) = false;
DYNX(W_,972) = false;
DYNX(W_,976) = false;
DYNX(W_,9) = 280.0;
DYNX(W_,15) = 1800.0;
DYNX(W_,21) = 850.0;
DYNX(W_,25) = 120.0;
DYNX(W_,494) = true;
DYNX(W_,797) = 1E-60;
DYNX(W_,798) = true;
DYNX(W_,799) = 1;
#endif
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,812) = 1E-60;
DYNX(W_,813) = true;
DYNX(W_,814) = 1;
DYNX(W_,815) = 1E-60;
DYNX(W_,816) = true;
DYNX(W_,817) = 1;
DYNX(W_,818) = 1E-60;
DYNX(W_,819) = true;
DYNX(W_,820) = 1;
DYNX(W_,390) = 0;
DYNX(W_,473) = 0;
DYNX(W_,186) = 0;
DYNX(W_,393) = 0;
DYNX(W_,492) = 0;
DYNX(W_,71) = 0.0;
DYNX(W_,73) = 0.0;
DYNX(W_,72) = 0.0;
DYNX(W_,120) = 0.0;
DYNX(W_,442) = 0;
DYNX(W_,406) = 0;
DYNX(W_,415) = 0;
DYNX(W_,407) = 0;
DYNX(W_,416) = 0;
DYNX(W_,408) = 0;
DYNX(W_,417) = 0;
DYNX(W_,67) = 0.0;
DYNX(W_,102) = 0.0;
DYNX(W_,107) = 0;
DYNX(W_,110) = 0;
memcpy(&DYNX(W_,364), &DymArrays6, sizeof(double)*3);
DYNX(W_,369) = 0;
DYNX(W_,379) = 0;
DYNX(W_,250) = 0.0;
DYNX(W_,376) = 0;
DYNX(W_,403) = 0.0;
DYNX(W_,466) = 0.0;
DYNX(W_,760) = 0;
DYNX(W_,765) = 0;
DYNX(W_,774) = 0;
DYNX(W_,779) = 0;
DYNX(W_,784) = 0;
DYNX(W_,789) = 0;
DYNX(W_,794) = 0;
DYNX(W_,806) = 0;
DYNX(W_,811) = 0;
DYNX(W_,856) = 0;
DYNX(W_,869) = 0;
DYNX(W_,116) = 0.0;
DYNX(W_,181) = 0.0;
DYNX(W_,115) = 0.0;
DYNX(W_,855) = false;
DYNX(W_,868) = false;
memcpy(&DYNX(W_,877), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,881), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,885), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,889), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,893), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,897), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,901), &DymArrays7, sizeof(double)*3);
DYNX(W_,183) = 0.0;
DYNX(W_,391) = 0.0;
DYNX(W_,303) = 0.0;
DYNX(W_,320) = 0.0;
DYNX(W_,361) = 0.0;
DYNX(W_,86) = 293.15;
DYNX(W_,74) = 0.0;
DYNX(W_,68) = 0.0;
DYNX(W_,87) = 0.0;
DYNX(W_,293) = 0.0;
DYNX(W_,292) = 293.15;
DYNX(W_,296) = 0.0;
DYNX(W_,295) = 293.15;
DYNX(W_,289) = 0.0;
DYNX(W_,288) = 293.15;
DYNX(W_,287) = 0.0;
DYNX(W_,286) = 293.15;
memcpy(&DYNX(W_,283), &DymArrays6, sizeof(double)*3);
DYNX(W_,291) = 0.0;
DYNX(W_,290) = 293.15;
DYNX(W_,182) = 0.0;
DYNX(W_,187) = 0.0;
DYNX(W_,185) = 0.0;
DYNX(W_,184) = 0.0;
DYNX(W_,358) = 293.15;
DYNX(W_,346) = 0.0;
DYNX(W_,374) = 293.15;
DYNX(W_,375) = 293.15;
DYNX(W_,377) = 293.15;
DYNX(W_,378) = 293.15;
DYNX(W_,225) = 0.0;
DYNX(W_,224) = 0.0;
DYNX(W_,223) = 0.0;
DYNX(W_,222) = 0.0;
DYNX(W_,199) = 293.15;
DYNX(W_,367) = 293.15;
DYNX(W_,368) = 293.15;
DYNX(W_,242) = 293.15;
memcpy(&DYNX(W_,229), &DymArrays6, sizeof(double)*3);
memcpy(&DYNX(W_,371), &DymArrays7, sizeof(double)*3);
DYNX(W_,272) = 0.0;
DYNX(W_,280) = 293.15;
DYNX(W_,846) = 293.15;
DYNX(W_,267) = 293.15;
DYNX(W_,278) = 293.15;
DYNX(W_,277) = 293.15;
DYNX(W_,263) = 0.0;
DYNX(W_,262) = 293.15;
DYNX(W_,276) = 293.15;
DYNX(W_,275) = 0.0;
DYNX(W_,274) = 293.15;
DYNX(W_,260) = 293.15;
DYNX(W_,265) = 293.15;
DYNX(W_,256) = 293.15;
DYNX(W_,258) = 293.15;
DYNX(W_,254) = 0.0;
DYNX(W_,253) = 293.15;
DYNX(W_,252) = 293.15;
DYNX(W_,255) = 293.15;
memcpy(&DYNX(W_,905), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,410), &DymArrays6, sizeof(double)*3);
memcpy(&DYNX(W_,909), &DymArrays7, sizeof(double)*3);
DYNX(W_,468) = 0.0;
DYNX(W_,467) = 0.0;
DYNX(W_,469) = 0.0;
DYNX(W_,443) = 0.0;
DYNX(W_,445) = 0.0;
DYNX(W_,444) = 0.0;
DYNX(W_,447) = 0.0;
DYNX(W_,446) = 0.0;
memcpy(&DYNX(W_,438), &DymArrays6, sizeof(double)*3);
DYNX(W_,394) = 0.0;
DYNX(W_,465) = 0.0;
DYNX(W_,460) = 0.0;
DYNX(W_,459) = 0.0;
DYNX(W_,462) = 0.0;
DYNX(W_,461) = 0.0;
DYNX(W_,464) = 0.0;
DYNX(W_,463) = 0.0;
DYNX(W_,389) = 0.0;
DYNX(W_,386) = 0.0;
memcpy(&DYNX(W_,913), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,917), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,921), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,925), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,929), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,933), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,937), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,941), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,873), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,400), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,419), &DymArrays6, sizeof(double)*3);
DYNX(W_,426) = 0.0;
DYNX(W_,425) = 0.0;
DYNX(W_,428) = 0.0;
DYNX(W_,427) = 0.0;
DYNX(W_,430) = 0.0;
DYNX(W_,429) = 0.0;
DYNX(W_,773) = false;
DYNX(W_,810) = false;
DYNX(W_,783) = false;
memcpy(&DYNX(W_,945), &DymArrays7, sizeof(double)*3);
DYNX(W_,759) = false;
memcpy(&DYNX(W_,949), &DymArrays7, sizeof(double)*3);
DYNX(W_,778) = false;
DYNX(W_,805) = false;
DYNX(W_,788) = false;
DYNX(W_,793) = false;
DYNX(W_,764) = false;
memcpy(&DYNX(W_,953), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,957), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,961), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,965), &DymArrays7, sizeof(double)*3);
memcpy(&DYNX(W_,969), &DymArrays7, sizeof(double)*3);
DYNX(W_,478) = 0.0;
memcpy(&DYNX(W_,482), &DymArrays8, sizeof(double)*6);
DYNX(W_,476) = 0.0;
DYNX(W_,474) = 0.0;
DYNX(W_,475) = 0.0;
memcpy(&DYNX(W_,973), &DymArrays7, sizeof(double)*3);
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
AssertModelica(DYNX(DP_,127) >= DYNX(DP_,128),"machineEfficiencyComputation.limiter.uMax >= machineEfficiencyComputation.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,127), true, 0)),") < uMin (="),Real2String2(
  DYNX(DP_,128), true, 0)),")"));
PopAllMarks();
BoundParameterSection
DYNX(W_,2) = 10*DYNX(DP_,4);
DYNX(W_,3) = DYNX(DP_,9);
DYNX(W_,4) = 0.00015-DYNX(DP_,9);
DYNX(W_,5) = 0.0003-DYNX(DP_,9);
DYNX(W_,6) = DYNX(W_,4)+DYNX(DP_,9);
DYNX(W_,7) = DYNX(W_,5)+DYNX(DP_,9);
DYNX(DYNhelp,0) = divinvGuarded(DYNX(DP_,2),"machine.data.p");
DYNX(W_,10) = DYNX(DYNhelp,0)*6.283185307179586*DYNX(DP_,3);
DYNX(W_,11) = divGuarded(280*DYNX(DP_,2),"280*machine.data.p",6.283185307179586*
  DYNX(DP_,3),"6.283185307179586*machine.data.fs_nom");
DYNX(W_,13) = DYNX(DYNhelp,0)*0.006283185307179587*DYNX(DP_,3);
DYNX(DYNhelp,1) = DYNX(DYNhelp,0)*0.006283185307179587*DYNX(DP_,3)*DYNX(DP_,2);
DYNX(DYNhelp,2) = 6.283185307179586*DYNX(DP_,3);
DYNX(DYNhelp,3) = divinvGuarded(DYNX(DYNhelp,2),"6.283185307179586*machine.data.fs_nom");
DYNX(DYNhelp,4) = DYNX(DYNhelp,3)*DYNX(DYNhelp,1);
DYNX(W_,14) = DYNX(DYNhelp,3)*280.0*DYNX(DP_,2)*sqr(DYNX(DYNhelp,4));
DYNX(W_,16) = DYNX(DP_,25)-DYNX(DP_,26)*DYNX(DP_,6);
DYNX(W_,17) = 6.283185307179586*DYNX(DP_,3);
DYNX(W_,19) = divGuarded(600.0,"600.0",sqr(DYNX(DP_,25)-DYNX(DP_,26)*DYNX(DP_,6)),
  "(machine.data.u_s_nom-machine.data.i_s_nom*machine.data.Rs)^2");
DYNX(W_,20) = 6.283185307179586E-06*DYNX(DP_,3);
DYNX(W_,22) = DYNX(DP_,26);
DYNX(W_,23) = DYNX(DYNhelp,0)*6.283185307179586*DYNX(DP_,3);
DYNX(W_,24) = divGuarded(850*DYNX(DP_,2),"850*machine.data.p",6.283185307179586*
  DYNX(DP_,3),"6.283185307179586*machine.data.fs_nom");
DYNX(W_,26) = DYNX(DP_,26);
DYNX(W_,27) = DYNX(DYNhelp,0)*6.283185307179586*DYNX(DP_,3);
DYNX(W_,28) = divGuarded(120*DYNX(DP_,2),"120*machine.data.p",6.283185307179586*
  DYNX(DP_,3),"6.283185307179586*machine.data.fs_nom");
DYNX(W_,29) = DYNX(DYNhelp,0)*6.283185307179586*DYNX(DP_,3);
DYNX(W_,30) = DYNX(DP_,24)*DYNX(W_,29);
DYNX(W_,43) = DYNX(DP_,2);
DYNX(W_,44) = DYNX(DP_,3);
DYNX(W_,45) = DYNX(DP_,5);
DYNX(W_,46) = DYNX(DP_,6);
DYNX(W_,47) = DYNX(DP_,8);
DYNX(W_,48) = DYNX(DP_,7);
DYNX(W_,49) = DYNX(W_,3);
DYNX(W_,50) = DYNX(DP_,9);
DYNX(W_,51) = DYNX(DP_,4);
DYNX(W_,53) = DYNX(W_,2);
DYNX(W_,55) = DYNX(W_,9);
DYNX(W_,56) = DYNX(W_,10);
DYNX(W_,57) = DYNX(DP_,18);
DYNX(W_,58) = DYNX(W_,11);
DYNX(W_,60) = DYNX(W_,13);
DYNX(W_,61) = DYNX(W_,14);
DYNX(W_,65) = DYNX(W_,51);
DYNX(W_,69) = DYNX(W_,53);
DYNX(W_,78) = DYNX(W_,55);
DYNX(W_,79) = DYNX(W_,56);
DYNX(W_,80) = DYNX(W_,57);
DYNX(W_,81) = DYNX(W_,58);
DYNX(W_,83) = DYNX(W_,60);
DYNX(W_,84) = DYNX(W_,61);
DYNX(W_,88) = DYNX(DP_,19);
DYNX(W_,89) = DYNX(W_,15);
DYNX(W_,90) = DYNX(W_,16);
DYNX(W_,91) = DYNX(W_,17);
DYNX(W_,93) = DYNX(W_,19);
DYNX(W_,94) = DYNX(W_,20);
DYNX(W_,95) = DYNX(W_,21);
DYNX(W_,96) = DYNX(W_,22);
DYNX(W_,97) = DYNX(W_,23);
DYNX(W_,98) = DYNX(DP_,20);
DYNX(W_,99) = DYNX(W_,24);
DYNX(W_,133) = DYNX(W_,46);
DYNX(W_,134) = DYNX(W_,46);
DYNX(W_,135) = DYNX(W_,46);
DYNX(W_,136) = DYNX(W_,47);
DYNX(W_,137) = DYNX(W_,47);
DYNX(W_,138) = DYNX(W_,47);
DYNX(W_,139) = divGuarded(DYNX(W_,48),"machine.coreElement.alpha20s",1+
  DYNX(W_,48)*(DYNX(W_,47)-293.15),"1+machine.coreElement.alpha20s*(machine.coreElement.TsRef-293.15)");
DYNX(W_,140) = divGuarded(DYNX(W_,48),"machine.coreElement.alpha20s",1+
  DYNX(W_,48)*(DYNX(W_,47)-293.15),"1+machine.coreElement.alpha20s*(machine.coreElement.TsRef-293.15)");
BreakSectionFunctionEnd()
BreakSectionFunctionStart(2);
DYNX(W_,141) = divGuarded(DYNX(W_,48),"machine.coreElement.alpha20s",1+
  DYNX(W_,48)*(DYNX(W_,47)-293.15),"1+machine.coreElement.alpha20s*(machine.coreElement.TsRef-293.15)");
DYNX(W_,144) = DYNX(W_,47);
DYNX(W_,145) = DYNX(W_,47);
DYNX(W_,146) = DYNX(W_,47);
DYNX(W_,147) = DYNX(W_,133);
DYNX(W_,148) = DYNX(W_,136);
DYNX(W_,149) = DYNX(W_,139);
DYNX(W_,152) = DYNX(W_,148);
DYNX(W_,155) = DYNX(W_,134);
DYNX(W_,156) = DYNX(W_,137);
DYNX(W_,157) = DYNX(W_,140);
DYNX(W_,160) = DYNX(W_,156);
DYNX(W_,163) = DYNX(W_,135);
DYNX(W_,164) = DYNX(W_,138);
DYNX(W_,165) = DYNX(W_,141);
DYNX(W_,168) = DYNX(W_,164);
DYNX(W_,171) = DYNX(W_,50);
DYNX(W_,172) = DYNX(W_,50);
DYNX(W_,188) = DYNX(W_,49);
DYNX(W_,189) = DYNX(W_,88);
DYNX(W_,190) = DYNX(W_,89);
DYNX(W_,191) = DYNX(W_,90);
DYNX(W_,192) = DYNX(W_,91);
DYNX(W_,194) = DYNX(W_,93);
DYNX(W_,195) = DYNX(W_,94);
DYNX(W_,196) = DYNX(W_,189);
DYNX(W_,236) = DYNX(W_,95);
DYNX(W_,237) = DYNX(W_,96);
DYNX(W_,238) = DYNX(W_,97);
DYNX(W_,239) = DYNX(W_,98);
DYNX(W_,240) = DYNX(W_,99);
DYNX(W_,248) = DYNX(W_,45);
DYNX(W_,268) = DYNX(W_,248);
AssertModelica(1+DYNX(W_,149)*(DYNX(W_,268)-DYNX(W_,148)) >= 1E-15,
  "1+machine.coreElement.rs.resistor[1].alpha*(machine.coreElement.thermalAmbient.constTs.k-machine.coreElement.rs.resistor[1].T_ref) >= 1E-15",
   "Temperature outside scope of model!");
AssertModelica(1+DYNX(W_,157)*(DYNX(W_,268)-DYNX(W_,156)) >= 1E-15,
  "1+machine.coreElement.rs.resistor[2].alpha*(machine.coreElement.thermalAmbient.constTs.k-machine.coreElement.rs.resistor[2].T_ref) >= 1E-15",
   "Temperature outside scope of model!");
AssertModelica(1+DYNX(W_,165)*(DYNX(W_,268)-DYNX(W_,164)) >= 1E-15,
  "1+machine.coreElement.rs.resistor[3].alpha*(machine.coreElement.thermalAmbient.constTs.k-machine.coreElement.rs.resistor[3].T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,327) = DYNX(DP_,13);
DYNX(W_,271) = DYNX(W_,327);
DYNX(W_,329) = DYNX(W_,4);
DYNX(W_,297) = DYNX(W_,329);
DYNX(W_,330) = DYNX(W_,5);
DYNX(W_,298) = DYNX(W_,330);
DYNX(W_,300) = DYNX(W_,43);
DYNX(W_,322) = DYNX(W_,297);
DYNX(W_,325) = DYNX(W_,298);
DYNX(W_,328) = DYNX(DP_,10);
DYNX(W_,332) = DYNX(DP_,11);
DYNX(W_,333) = DYNX(DP_,12);
DYNX(W_,334) = DYNX(DP_,14);
DYNX(W_,335) = DYNX(DP_,15);
DYNX(W_,336) = DYNX(DP_,17);
DYNX(W_,337) = DYNX(DP_,16);
DYNX(W_,338) = DYNX(W_,25);
DYNX(W_,339) = DYNX(DP_,21);
DYNX(W_,340) = DYNX(W_,26);
DYNX(W_,341) = DYNX(DP_,22);
DYNX(W_,342) = DYNX(W_,27);
DYNX(W_,343) = DYNX(DP_,23);
DYNX(W_,344) = DYNX(W_,28);
DYNX(W_,360) = divGuarded(1.4142135623730951*DYNX(W_,328),"1.4142135623730951*machine.coreElement.VsOpenCircuit",
  3.141592653589793*DYNX(W_,329)*2*DYNX(W_,44),"3.141592653589793*(machine.coreElement.Lmd*2*machine.coreElement.fsNominal)");
DYNX(W_,345) = DYNX(W_,360);
DYNX(W_,350) = DYNX(W_,338);
DYNX(W_,351) = DYNX(W_,339);
DYNX(W_,352) = DYNX(W_,340);
DYNX(W_,353) = DYNX(W_,341);
DYNX(W_,354) = DYNX(W_,342);
DYNX(W_,355) = DYNX(W_,343);
DYNX(W_,356) = DYNX(W_,344);
DYNX(W_,488) = DYNX(DP_,31);
DYNX(W_,493) = (-0.5)*DYNX(DP_,24);
DYNX(W_,495) = 2*DYNX(W_,29);
DYNX(W_,499) = DYNX(DP_,40);
DYNX(W_,503) = DYNX(DP_,36);
DYNX(W_,504) = DYNX(DP_,37);
DYNX(W_,505) = DYNX(DP_,43);
DYNX(W_,506) = divGuarded(1.4142135623730951*DYNX(W_,505),"1.4142135623730951*controller.data.u_s_openCircuit",
  6.283185307179586*DYNX(W_,504),"6.283185307179586*controller.data.fs_nom");
DYNX(W_,511) = 10*DYNX(DP_,38);
DYNX(DYNhelp,5) = divinvGuarded(DYNX(DP_,36),"controller.data.machineData.p");
DYNX(W_,519) = DYNX(DYNhelp,5)*6.283185307179586*DYNX(DP_,37);
DYNX(W_,520) = divGuarded(280*DYNX(DP_,36),"280*controller.data.machineData.p",
  6.283185307179586*DYNX(DP_,37),"6.283185307179586*controller.data.machineData.fs_nom");
DYNX(W_,522) = DYNX(DYNhelp,5)*0.006283185307179587*DYNX(DP_,37);
DYNX(DYNhelp,6) = DYNX(DYNhelp,5)*0.006283185307179587*DYNX(DP_,37)*DYNX(DP_,36);
DYNX(DYNhelp,7) = 6.283185307179586*DYNX(DP_,37);
DYNX(DYNhelp,8) = divinvGuarded(DYNX(DYNhelp,7),"6.283185307179586*controller.data.machineData.fs_nom");
DYNX(DYNhelp,9) = DYNX(DYNhelp,8)*DYNX(DYNhelp,6);
DYNX(W_,523) = DYNX(DYNhelp,8)*280.0*DYNX(DP_,36)*sqr(DYNX(DYNhelp,9));
DYNX(W_,524) = DYNX(DP_,62)-DYNX(DP_,63)*DYNX(DP_,40);
DYNX(W_,525) = 6.283185307179586*DYNX(DP_,37);
DYNX(W_,527) = divGuarded(600.0,"600.0",sqr(DYNX(DP_,62)-DYNX(DP_,63)*
  DYNX(DP_,40)),"(controller.data.machineData.u_s_nom-controller.data.machineData.i_s_nom*controller.data.machineData.Rs)^2");
DYNX(W_,528) = 6.283185307179586E-06*DYNX(DP_,37);
DYNX(W_,529) = DYNX(DP_,63);
DYNX(W_,530) = DYNX(DYNhelp,5)*6.283185307179586*DYNX(DP_,37);
DYNX(W_,531) = divGuarded(850*DYNX(DP_,36),"850*controller.data.machineData.p",
  6.283185307179586*DYNX(DP_,37),"6.283185307179586*controller.data.machineData.fs_nom");
DYNX(W_,532) = DYNX(DP_,63);
DYNX(W_,533) = DYNX(DYNhelp,5)*6.283185307179586*DYNX(DP_,37);
DYNX(W_,534) = divGuarded(120*DYNX(DP_,36),"120*controller.data.machineData.p",
  6.283185307179586*DYNX(DP_,37),"6.283185307179586*controller.data.machineData.fs_nom");
DYNX(W_,535) = DYNX(DYNhelp,5)*6.283185307179586*DYNX(DP_,37);
DYNX(W_,536) = DYNX(DP_,61)*DYNX(W_,535);
DYNX(W_,537) = 5*DYNX(W_,499);
DYNX(DYNhelp,10) = divinvGuarded(DYNX(W_,499),"controller.data.Rs");
DYNX(W_,547) = DYNX(DYNhelp,10)*DYNX(W_,507);
DYNX(W_,538) = DYNX(W_,547);
DYNX(W_,539) = 5*DYNX(W_,499);
DYNX(W_,548) = DYNX(DYNhelp,10)*DYNX(W_,508);
DYNX(W_,540) = DYNX(W_,548);
DYNX(DYNhelp,11) = divinvGuarded(DYNX(DP_,65),"controller.data.T_d");
DYNX(W_,545) = DYNX(DYNhelp,11)*DYNX(W_,507);
DYNX(W_,541) = IF DYNX(DP_,64) THEN DYNX(W_,545) ELSE DYNX(W_,537);
DYNX(DYNhelp,12) = divinvGuarded(DYNX(DP_,66),"controller.data.T_q");
DYNX(W_,546) = DYNX(DYNhelp,12)*DYNX(W_,508);
DYNX(W_,542) = IF DYNX(DP_,64) THEN DYNX(W_,546) ELSE DYNX(W_,539);
DYNX(W_,543) = IF DYNX(DP_,64) THEN DYNX(W_,547) ELSE DYNX(W_,538);
DYNX(W_,544) = IF DYNX(DP_,64) THEN DYNX(W_,548) ELSE DYNX(W_,540);
DYNX(W_,549) = DYNX(DP_,160);
DYNX(W_,550) = DYNX(W_,549)+DYNX(DP_,38);
DYNX(DYNhelp,13) = divinvGuarded(DYNX(W_,542),"controller.data.kp_q");
DYNX(W_,551) = DYNX(DYNhelp,13)*DYNX(W_,508);
DYNX(W_,553) = divGuarded(2*DYNX(W_,550),"2*controller.data.J_sum",6.0*
  DYNX(W_,503)*DYNX(W_,506)*DYNX(W_,551),"6.0*(controller.data.p*controller.data.psi_PM*controller.data.Tw_q)");
DYNX(W_,554) = 4*DYNX(W_,551);
DYNX(W_,559) = divGuarded(2*DYNX(W_,550),"2*controller.data.J_sum",6.0*
  DYNX(W_,503)*DYNX(W_,506)*DYNX(W_,551),"6.0*(controller.data.p*controller.data.psi_PM*controller.data.Tw_q)");
DYNX(W_,555) = DYNX(W_,559);
DYNX(W_,560) = 4*DYNX(W_,551);
DYNX(W_,556) = DYNX(W_,560);
DYNX(W_,561) = DYNX(W_,503);
DYNX(W_,562) = DYNX(W_,499);
DYNX(W_,566) = DYNX(W_,504);
DYNX(W_,567) = DYNX(W_,506);
DYNX(W_,569) = DYNX(DP_,68);
DYNX(W_,570) = DYNX(W_,541);
DYNX(W_,571) = DYNX(W_,543);
DYNX(W_,572) = DYNX(W_,542);
DYNX(W_,573) = DYNX(W_,544);
DYNX(W_,574) = DYNX(DP_,69);
DYNX(W_,575) = DYNX(DP_,70);
DYNX(W_,576) = DYNX(DP_,72);
DYNX(W_,577) = 1.4142135623730951*DYNX(W_,576);
DYNX(W_,580) = DYNX(W_,570);
DYNX(W_,581) = DYNX(W_,571);
DYNX(W_,582) = DYNX(W_,572);
DYNX(W_,583) = DYNX(W_,573);
DYNX(W_,594) = DYNX(W_,580);
DYNX(W_,595) = DYNX(W_,581);
DYNX(W_,598) = DYNX(W_,582);
DYNX(W_,599) = DYNX(W_,583);
DYNX(W_,606) = DYNX(W_,561);
DYNX(W_,609) = DYNX(W_,567);
DYNX(W_,612) = DYNX(W_,609);
DYNX(W_,618) = DYNX(W_,612);
DYNX(W_,620) = DYNX(W_,606);
DYNX(W_,621) = DYNX(W_,606);
DYNX(W_,622) = DYNX(W_,566);
DYNX(W_,623) = DYNX(W_,574);
DYNX(W_,624) = DYNX(W_,575);
DYNX(W_,625) = DYNX(W_,569);
DYNX(W_,631) = DYNX(W_,623);
DYNX(W_,632) = DYNX(W_,624);
DYNX(W_,638) = DYNX(W_,631);
DYNX(DYNhelp,14) = divinvGuarded(DYNX(W_,622),"controller.coreElement.fieldWeakeningController.fs_nom");
DYNX(W_,647) = DYNX(DYNhelp,14)*0.2;
DYNX(W_,650) = DYNX(W_,625);
DYNX(W_,658) = DYNX(W_,567);
DYNX(W_,662) = DYNX(W_,577);
DYNX(W_,669) = DYNX(W_,662);
DYNX(W_,677) = DYNX(W_,561);
DYNX(W_,681) = DYNX(W_,562);
DYNX(W_,682) = DYNX(W_,567);
DYNX(W_,683) = DYNX(W_,577);
DYNX(W_,684) = DYNX(W_,569);
DYNX(W_,689) = DYNX(W_,681);
DYNX(W_,690) = DYNX(W_,682);
DYNX(W_,691) = DYNX(W_,683);
DYNX(W_,692) = DYNX(W_,684);
DYNX(W_,701) = DYNX(W_,555);
DYNX(W_,702) = DYNX(W_,556);
DYNX(W_,705) = DYNX(W_,701);
DYNX(W_,706) = DYNX(W_,702);
DYNX(W_,712) = DYNX(W_,705);
DYNX(DYNhelp,15) = divinvGuarded(DYNX(DP_,32),"controller.data.fs");
DYNX(W_,729) = DYNX(DYNhelp,15);
DYNX(W_,730) = DYNX(DP_,33);
DYNX(W_,739) = (-0.4330127018922193)*DYNX(DP_,25);
DYNX(W_,740) = 1.7320508075688772*DYNX(DP_,25);
DYNX(W_,741) = 2*DYNX(W_,29);
DYNX(DYNhelp,16) = ModelicaStrings_length("");
DYNSetAuxStringD(did_, IF ModelicaStrings_length("") > 0 THEN StringAdd(":\n  ",
  "") ELSE "", 3, 0);
PopAllMarks();
DYNX(DYNhelp,17) = ModelicaStrings_length("");
DYNSetAuxStringD(did_, IF ModelicaStrings_length("") > 0 THEN StringAdd(":\n  ",
  "") ELSE "", 5, 0);
PopAllMarks();
DYNX(DYNhelp,18) = ModelicaStrings_length("");
DYNSetAuxStringD(did_, IF ModelicaStrings_length("") > 0 THEN StringAdd(":\n  ",
  "") ELSE "", 7, 0);
PopAllMarks();
DYNX(DYNhelp,19) = ModelicaStrings_length("");
DYNSetAuxStringD(did_, IF ModelicaStrings_length("") > 0 THEN StringAdd(":\n  ",
  "") ELSE "", 9, 0);
PopAllMarks();
DYNX(W_,848) = DYNX(DP_,83);
DYNX(DYNhelp,20) = divinvGuarded(DYNX(W_,632),"controller.coreElement.fieldWeakeningController.fieldWeakeningController.Ti");
DYNX(W_,849) = DYNX(DYNhelp,20);
DYNX(W_,853) = DYNX(DP_,85);
DYNX(W_,859) = divinvGuarded(DYNX(W_,631)*DYNX(DP_,84),"controller.coreElement.fieldWeakeningController.fieldWeakeningController.k*controller.coreElement.fieldWeakeningController.fieldWeakeningController.Ni");
DYNX(W_,861) = DYNX(DP_,100);
DYNX(DYNhelp,21) = divinvGuarded(DYNX(W_,706),"controller.coreElement.speedController.Ti");
DYNX(W_,862) = DYNX(DYNhelp,21);
DYNX(W_,866) = DYNX(DP_,102);
DYNX(W_,872) = divinvGuarded(DYNX(W_,705)*DYNX(DP_,101),"controller.coreElement.speedController.k*controller.coreElement.speedController.Ni");
BoundParameterConstantSection
DYNX(W_,170) = DYNX(W_,163)*(1+DYNX(W_,165)*(DYNX(W_,268)-DYNX(W_,164)));
DYNX(W_,154) = DYNX(W_,147)*(1+DYNX(W_,149)*(DYNX(W_,268)-DYNX(W_,148)));
DYNX(W_,162) = DYNX(W_,155)*(1+DYNX(W_,157)*(DYNX(W_,268)-DYNX(W_,156)));
DYNX(W_,119) = DYNX(W_,345);
DYNX(DYNhelp,22) = fabs(DYNX(W_,91));
DYNX(W_,202) = RealBmax(DYNX(DYNhelp,22), DYNX(W_,195));
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,62) = 0;
#endif
InitialSection
InitialStartSection
InitialStartSection2
DYNX(W_,686) = DYNX(W_,691);
DYNX(W_,695) = DYNX(W_,691);
DYNX(X_,3) = DYNX(DP_,73);
DYNX(X_,4) = DYNX(DP_,75);
DYNX(X_,5) = DYNX(DP_,91);
DYNX(X_,6) = DYNX(DP_,124);
DYNX(X_,7) = DYNX(DP_,126);
DYNX(X_,8) = DYNX(DP_,132);
DYNX(X_,9) = DYNX(DP_,134);
DYNX(X_,10) = DYNX(DP_,136);
DYNX(X_,11) = DYNX(DP_,138);
DYNX(X_,12) = DYNX(DP_,140);
DYNX(X_,13) = DYNX(DP_,142);
DYNX(X_,14) = DYNX(DP_,144);
DYNX(X_,16) = DYNX(W_,853);
DYNX(X_,17) = DYNX(W_,866);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(X_,16) = DYNX(W_,853);
DYNX(X_,4) = DYNX(DP_,75);
DYNX(X_,5) = DYNX(DP_,91);
DYNX(X_,17) = DYNX(W_,866);
DYNX(X_,3) = DYNX(DP_,73);
DYNX(X_,6) = DYNX(DP_,124);
DYNX(X_,7) = DYNX(DP_,126);
DYNX(X_,8) = DYNX(DP_,132);
DYNX(X_,9) = DYNX(DP_,134);
DYNX(X_,10) = DYNX(DP_,136);
DYNX(X_,11) = DYNX(DP_,138);
DYNX(X_,12) = DYNX(DP_,140);
DYNX(X_,13) = DYNX(DP_,142);
DYNX(X_,14) = DYNX(DP_,144);
DYNX(W_,301) = DYNX(W_,300)*(DYNX(X_,2)-DYNX(DP_,27));
DYNX(W_,314) = sin(DYNX(W_,301));
DYNX(W_,315) = cos(DYNX(W_,301));
DYNX(W_,176) = DYNX(W_,314)*DYNX(X_,0)+DYNX(W_,315)*DYNX(X_,1);
DYNX(W_,312) = cos(DYNX(W_,301));
DYNX(W_,313) =  -sin(DYNX(W_,301));
DYNX(W_,175) = DYNX(W_,312)*DYNX(X_,0)+DYNX(W_,313)*DYNX(X_,1);
DYNX(W_,392) = DYNX(X_,2)-DYNX(DP_,29);
DYNX(W_,586) = DYNX(W_,621)*DYNX(W_,392);
DYNX(W_,496) = DYNX(DP_,116)+(IF LessTime(DYNX(DP_,117), 0) THEN 0 ELSE IF 
  LessTime(DYNX(DP_,117)+DYNX(DP_,115), 1) THEN divGuarded((DYNTime-
  DYNX(DP_,117))*DYNX(W_,741),"(time-desiredSpeed.startTime)*desiredSpeed.height",
  DYNX(DP_,115),"desiredSpeed.duration") ELSE DYNX(W_,741));
DYNX(W_,860) = DYNX(W_,861)*DYNX(W_,496)+DYNX(DP_,168)*DYNX(X_,15);
DYNX(W_,715) = DYNX(DP_,169)*DYNX(W_,860);
DYNX(W_,713) = DYNX(DP_,104)*DYNX(W_,715)+DYNX(DP_,105)*DYNX(X_,17);
DYNX(W_,714) = DYNX(W_,712)*DYNX(W_,713);
DYNX(W_,738) = DYNX(W_,740)+(IF LessTime(DYNX(DP_,114), 2) THEN 0 ELSE IF 
  LessTime(DYNX(DP_,114)+DYNX(DP_,113), 3) THEN divGuarded((DYNTime-
  DYNX(DP_,114))*DYNX(W_,739),"(time-maxLineVoltage.startTime)*maxLineVoltage.height",
  DYNX(DP_,113),"maxLineVoltage.duration") ELSE DYNX(W_,739));
DYNX(W_,685) = 0.816496580927726*DYNX(W_,738);
DYNX(W_,678) = DYNX(W_,677)*DYNX(X_,15);
if (DymolaHomotopyLambda==0){
  BreakSectionCallNew(3);
}
else {

  { /* Non-linear system of equations to solve. */
  /* Tag: initialization.nonlinear[1] */
  /* Introducing 3 common subexpressions used in 3 expressions */
  /* Of the common subexpressions 2 are reals, 0 are integers, and 1
     are booleans. */
  const char*const varnames_[]={"controller.coreElement.currentLimits.i_s_limit",
     "controller.coreElement.currentLimits.withReluctance.i_s_max_MTPV"};
  const double nominal_[]={1, 1};
  NonLinearSystemOfEquations(Jacobian__, residue__, x__, 2, 0, 1, 1, -2, 
    DYNX(DYNhelp,23), 53, DYNX(did_->helpvari_vec,0), 24);
  SetInitVector(x__, 1, DYNX(W_,686), DYNX(W_,691));
  SetInitVector(x__, 2, DYNX(W_,695), DYNX(W_,691));
  Residues;
    DYNX(W_,720) = IF DYNX(W_,686) >= 0 THEN DYNX(W_,686) ELSE  -DYNX(W_,686);
    DYNX(W_,719) = DYNX(DP_,107)*DYNX(W_,720);
    DYNX(W_,659) = homotopy(IF GreaterS(DYNX(W_,714),"controller.coreElement.speedController.gainPI.y",
       DYNX(W_,686),"controller.coreElement.currentLimits.i_s_limit", 1) THEN 
      DYNX(W_,686) ELSE IF LessS(DYNX(W_,714),"controller.coreElement.speedController.gainPI.y",
       DYNX(W_,719),"controller.coreElement.speedController.limiter.limit2", 2)
       THEN DYNX(W_,719) ELSE DYNX(W_,714), DYNX(W_,714));
    DYNX(W_,696) = IF (IF DYNX(W_,659) > 0 THEN 1 ELSE IF DYNX(W_,659) < 0 THEN -1
       ELSE 0) == (IF DYNX(W_,678) > 0 THEN 1 ELSE IF DYNX(W_,678) < 0 THEN -1
       ELSE 0) THEN 1 ELSE 0;
    DYNX(W_,627) = DYNX(W_,692)*DYNX(W_,685)-DYNX(W_,696)*fabs(DYNX(W_,659))*
      DYNX(W_,689);
    DYNX(W_,698) = (PushModelContext(1,"DymolaModels.Functions.Math.divNoZero(controller.coreElement.fieldWeakeningController.u_s_max, controller.coreElement.mechanicalToElectricSpeed.y, 1, true)")
      DymolaModels_Functions_Math_divNoZero(DYNX(W_,627), DYNX(W_,678), 1, true));
    PopModelContext();
    DYNX(DYNhelp,76) = 0.0003*DYNX(W_,690);
    DYNX(DYNhelp,77) = sqr(DYNX(W_,698));
    DYNX(W_,697) = (-1666.6666666666667)*(DYNX(DYNhelp,76)-sqrtGuarded(sqr(
      DYNX(DYNhelp,76))+1.7999999999999997E-07*DYNX(DYNhelp,77),"(0.0003*controller.coreElement.currentLimits.withReluctance.psi_PM)^2+1.7999999999999997E-07*controller.coreElement.currentLimits.withReluctance.psi_MTPV^2"));
    DYNX(W_,694) = 3333.3333333333335*sqrtGuarded(RealBmax(0, DYNX(DYNhelp,77)-
      sqr(DYNX(W_,697))),"max(0, controller.coreElement.currentLimits.withReluctance.psi_MTPV^2-controller.coreElement.currentLimits.withReluctance.delta_psi^2)");
    DYNX(W_,693) = (-6666.666666666667)*(DYNX(W_,690)+DYNX(W_,697));
      DYNX(Aux_,0) = 1666.6666666666667*(DYNX(W_,658)-sqrtGuarded(sqr(
        DYNX(W_,658))+1.7999999999999997E-07*sqr(DYNX(W_,659)),"controller.coreElement.MTPA.psi_PM^2+1.7999999999999997E-07*controller.coreElement.MTPA.i_s_ref^2"));
      DYNX(Aux_,1) = IF sqr(DYNX(W_,659))-sqr(DYNX(Aux_,0)) <= 0 THEN 0 ELSE (
        IF DYNX(W_,659) > 0 THEN 1 ELSE IF DYNX(W_,659) < 0 THEN -1 ELSE 0)*
        sqrtGuarded(sqr(DYNX(W_,659))-sqr(DYNX(Aux_,0)),"controller.coreElement.MTPA.i_s_ref^2-controller.coreElement.MTPA.i_d_mtpa_alg2.4.^2");
    DYNX(W_,660) = DYNX(Aux_,0);
    DYNX(DYNhelp,78) = LessS(fabs(DYNX(W_,695)),"abs(controller.coreElement.currentLimits.withReluctance.i_s_max_MTPV)",
       DYNX(W_,691),"controller.coreElement.currentLimits.withReluctance.i_s_peak",
       0);
    DYNX(W_,654) = IF DYNX(DYNhelp,78) THEN DYNX(W_,693)-DYNX(W_,660) ELSE  -(
      DYNX(W_,691)+DYNX(W_,660));
    DYNX(W_,674) = IF DYNX(DYNhelp,78) THEN DYNX(W_,694) ELSE DYNX(W_,691);
    DYNX(W_,661) = DYNX(Aux_,1);
  SetVector(residue__, 1, sqr(DYNX(W_,695))-(sqr(DYNX(W_,693))+sqr(DYNX(W_,694))));
  SetVector(residue__, 2, DYNX(W_,686)-RealBmin(DYNX(W_,691), sqrtGuarded(sqr(
    DYNX(W_,654)+DYNX(W_,660))+sqr(DYNX(W_,674)),"(controller.coreElement.fieldWeakeningController.i_d_min+controller.coreElement.MTPA.i_d_mtpa)^2+controller.coreElement.limit_i_q.i_q_max^2")));

  { /* No analytic Jacobian available*/
  SolveNonLinearSystemOfEquationsInit(Jacobian__, 0, 0, 0, residue__, x__,"Tag: initialization.nonlinear[1]");
  DYNX(W_,686) = GetVector(x__, 1);
  DYNX(W_,695) = GetVector(x__, 2);
  EndNonLinearSystemOfEquationsInit(residue__, x__, 1);
   /* End of Non-Linear Equation Block */ }



}
AssertModelica(GreaterEqual(DYNX(W_,686),"controller.coreElement.currentLimits.i_s_limit",
   DYNX(W_,719),"controller.coreElement.speedController.limiter.limit2", 3),
  "controller.coreElement.currentLimits.i_s_limit >= controller.coreElement.speedController.limiter.limit2",
   "Input signals are not consistent: limit1 < limit2");
AssertModelica(GreaterEqual(DYNX(W_,686),"controller.coreElement.currentLimits.i_s_limit",
   DYNX(W_,719),"controller.coreElement.speedController.limiter.limit2", 3),
  "controller.coreElement.currentLimits.i_s_limit >= controller.coreElement.speedController.limiter.limit2",
   StringAdd(StringAdd(StringAdd(StringAdd("\n### Error in class LimitedPI: Limits must be consistent. However, yMax (=",
  Real2String2(DYNX(W_,686), true, 0)),") < limiter.limit2 (="),Real2String2(
  DYNX(W_,719), true, 0)),")###\n"));
PopAllMarks();
DYNX(W_,673) = DYNX(DP_,97)*DYNX(W_,674);
AssertModelica(GreaterEqual(DYNX(W_,674),"controller.coreElement.limit_i_q.i_q_max",
   DYNX(W_,673),"controller.coreElement.limit_i_q.variableLimiter1.limit2", 4),
  "controller.coreElement.limit_i_q.i_q_max >= controller.coreElement.limit_i_q.variableLimiter1.limit2",
   "Input signals are not consistent: limit1 < limit2");
BreakSectionFunctionEnd()
BreakSectionFunctionStart(4);
DYNX(W_,663) = homotopy(IF GreaterS(DYNX(W_,661),"controller.coreElement.MTPA.i_q_mtpa",
   DYNX(W_,674),"controller.coreElement.limit_i_q.i_q_max", 5) THEN DYNX(W_,674)
   ELSE IF LessS(DYNX(W_,661),"controller.coreElement.MTPA.i_q_mtpa", 
  DYNX(W_,673),"controller.coreElement.limit_i_q.variableLimiter1.limit2", 6)
   THEN DYNX(W_,673) ELSE DYNX(W_,661), DYNX(W_,661));
DYNX(W_,628) = DYNX(W_,650)*DYNX(W_,627);
DYNX(W_,847) = DYNX(W_,848)*DYNX(W_,628)+DYNX(DP_,161)*DYNX(X_,5);
DYNX(W_,641) = DYNX(DP_,162)*DYNX(W_,847);
DYNX(W_,639) = DYNX(DP_,87)*DYNX(W_,641)+DYNX(DP_,88)*DYNX(X_,16);
DYNX(W_,640) = DYNX(W_,638)*DYNX(W_,639);
DYNX(W_,655) = RealBmin(DYNX(W_,654), DYNX(DP_,93));
AssertModelica(GreaterEqual(DYNX(DP_,92),"controller.coreElement.fieldWeakeningController.delta_i_d_max.k",
   DYNX(W_,655),"controller.coreElement.fieldWeakeningController.aboveZeroProtection.y",
   7),"controller.coreElement.fieldWeakeningController.delta_i_d_max.k >= controller.coreElement.fieldWeakeningController.aboveZeroProtection.y",
   "Input signals are not consistent: limit1 < limit2");
AssertModelica(GreaterEqual(DYNX(DP_,92),"controller.coreElement.fieldWeakeningController.delta_i_d_max.k",
   DYNX(W_,655),"controller.coreElement.fieldWeakeningController.aboveZeroProtection.y",
   7),"controller.coreElement.fieldWeakeningController.delta_i_d_max.k >= controller.coreElement.fieldWeakeningController.aboveZeroProtection.y",
   StringAdd(StringAdd(StringAdd(StringAdd("\n### Error in class LimitedPI: Limits must be consistent. However, yMax (=",
  Real2String2(DYNX(DP_,92), true, 0)),") < limiter.limit2 (="),Real2String2(
  DYNX(W_,655), true, 0)),")###\n"));
PopAllMarks();
DYNX(W_,626) = homotopy(IF GreaterS(DYNX(W_,640),"controller.coreElement.fieldWeakeningController.fieldWeakeningController.gainPI.y",
   DYNX(DP_,92),"controller.coreElement.fieldWeakeningController.delta_i_d_max.k",
   8) THEN DYNX(DP_,92) ELSE IF LessS(DYNX(W_,640),"controller.coreElement.fieldWeakeningController.fieldWeakeningController.gainPI.y",
   DYNX(W_,655),"controller.coreElement.fieldWeakeningController.aboveZeroProtection.y",
   9) THEN DYNX(W_,655) ELSE DYNX(W_,640), DYNX(W_,640));
DYNX(W_,584) = DYNX(DP_,98)*DYNX(W_,660)+DYNX(DP_,99)*DYNX(W_,626);
DYNX(W_,667) = IF sqr(DYNX(W_,669))-sqr(DYNX(W_,584)) <= 0 THEN 0 ELSE 
  sqrtGuarded(sqr(DYNX(W_,669))-sqr(DYNX(W_,584)),"controller.coreElement.limit_i_q.availableCurrent.i_s_peak^2-controller.coreElement.currentControllers.i_d_ref^2");
DYNX(W_,668) = DYNX(DP_,95)*DYNX(W_,667);
AssertModelica(GreaterEqual(DYNX(W_,667),"controller.coreElement.limit_i_q.variableLimiter.limit1",
   DYNX(W_,668),"controller.coreElement.limit_i_q.variableLimiter.limit2", 10),
  "controller.coreElement.limit_i_q.variableLimiter.limit1 >= controller.coreElement.limit_i_q.variableLimiter.limit2",
   "Input signals are not consistent: limit1 < limit2");
DYNX(W_,585) = homotopy(IF GreaterS(DYNX(W_,663),"controller.coreElement.limit_i_q.variableLimiter.u",
   DYNX(W_,667),"controller.coreElement.limit_i_q.variableLimiter.limit1", 11)
   THEN DYNX(W_,667) ELSE IF LessS(DYNX(W_,663),"controller.coreElement.limit_i_q.variableLimiter.u",
   DYNX(W_,668),"controller.coreElement.limit_i_q.variableLimiter.limit2", 12)
   THEN DYNX(W_,668) ELSE DYNX(W_,663), DYNX(W_,663));
DYNX(W_,613) = DYNX(W_,620)*DYNX(X_,15);

 /* Linear system of equations to solve. */
/* Tag: initialization.linear[1] */
/* Introducing 38 common subexpressions used in 54 expressions */
/* Of the common subexpressions 38 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,79) = cos(DYNX(W_,586));
DYNX(DYNhelp,80) = 1.5*DYNX(DYNhelp,79);
DYNX(DYNhelp,81) = sin(DYNX(W_,586));
DYNX(DYNhelp,82) = 0.8660254037844386*DYNX(DYNhelp,81);
DYNX(DYNhelp,83) = DYNX(DYNhelp,80)-DYNX(DYNhelp,82);
DYNX(DYNhelp,84) = DYNX(DP_,77)*DYNX(DYNhelp,83);
DYNX(DYNhelp,85) = DYNX(W_,594)*DYNX(DYNhelp,84);
DYNX(DYNhelp,86) = DYNX(W_,594)*DYNX(X_,3);
DYNX(DYNhelp,87) = 1.5*DYNX(DYNhelp,81);
DYNX(DYNhelp,88) = (-0.8660254037844386)*DYNX(DYNhelp,79)-DYNX(DYNhelp,87);
DYNX(DYNhelp,89) = DYNX(DP_,79)*DYNX(DYNhelp,88);
DYNX(DYNhelp,90) = DYNX(W_,598)*DYNX(DYNhelp,89);
DYNX(DYNhelp,91) = DYNX(W_,598)*DYNX(X_,4);
DYNX(DYNhelp,92) = DYNX(W_,613)*DYNX(DP_,80)*DYNX(DYNhelp,88);
DYNX(DYNhelp,93) = DYNX(DP_,82)*DYNX(W_,618);
DYNX(DYNhelp,94) = DYNX(DYNhelp,82)+DYNX(DYNhelp,80);
DYNX(DYNhelp,95) = DYNX(DP_,77)*DYNX(DYNhelp,94);
DYNX(DYNhelp,96) = DYNX(W_,594)*DYNX(DYNhelp,95);
DYNX(DYNhelp,97) = 0.8660254037844386*DYNX(DYNhelp,79)-DYNX(DYNhelp,87);
DYNX(DYNhelp,98) = DYNX(DP_,79)*DYNX(DYNhelp,97);
DYNX(DYNhelp,99) = DYNX(W_,598)*DYNX(DYNhelp,98);
DYNX(DYNhelp,100) = DYNX(W_,613)*DYNX(DP_,80)*DYNX(DYNhelp,97);
/* Automatic tearing of linear system of 35 simultaneous equations
gave a linear system of 4 equations for numerical solution.*/
{
  const char*const varnames_[]={"machine.coreElement.spacePhasorS.v[3]", 
    "machine.coreElement.spacePhasorS.v[2]", "machine.plug_p.pin[3].i", 
    "machine.plug_p.pin[2].i"};
  const double nominal_[]={1, 1, 1, 1};
  DidLinearSystemOfEquations(J, b, y, 4, DYNX(DYNhelp,101), 64, DYNX(did_->helpvari_vec,24), 12);
  /* Jacobian depending on continuous variables */
  SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    DYNX(DYNhelp,165) = 0.00015*DYNX(DP_,81)*DYNX(DYNhelp,92)-DYNX(DYNhelp,85);
    DYNX(DYNhelp,166) = (-0.0003)*DYNX(W_,613)*DYNX(DP_,78)*DYNX(DYNhelp,83)-
      DYNX(DYNhelp,90);
    DYNX(DYNhelp,167) = DYNX(DYNhelp,79)*DYNX(DYNhelp,165)-DYNX(DYNhelp,81)*
      DYNX(DYNhelp,166);
    DYNX(DYNhelp,168) = 0.6666666666666666*DYNX(DYNhelp,167);
    DYNX(DYNhelp,169) = 0.3333333333333333*DYNX(DYNhelp,167);
    DYNX(DYNhelp,170) = 0.5773502691896258*(DYNX(DYNhelp,81)*DYNX(DYNhelp,165)+
      DYNX(DYNhelp,79)*DYNX(DYNhelp,166));
    DYNX(DYNhelp,171) = 0.00015*DYNX(DP_,81)*DYNX(DYNhelp,100)-DYNX(DYNhelp,96);
    DYNX(DYNhelp,172) = DYNX(DP_,78)*DYNX(DYNhelp,94);
    DYNX(DYNhelp,173) = (-0.0003)*DYNX(W_,613)*DYNX(DYNhelp,172)-
      DYNX(DYNhelp,99);
    DYNX(DYNhelp,174) = DYNX(DYNhelp,79)*DYNX(DYNhelp,171)-DYNX(DYNhelp,81)*
      DYNX(DYNhelp,173);
    DYNX(DYNhelp,175) = 0.6666666666666666*DYNX(DYNhelp,174);
    DYNX(DYNhelp,176) = (-1.0)*(DYNX(DYNhelp,175)-DYNX(W_,154))-0.3333333333333333
      *DYNX(DYNhelp,174);
    DYNX(DYNhelp,177) = 0.5773502691896258*(DYNX(DYNhelp,81)*DYNX(DYNhelp,171)+
      DYNX(DYNhelp,79)*DYNX(DYNhelp,173));
    SetMatrixLeading(J, 1, 1, 4, 1.0);
    SetMatrixLeading(J, 1, 2, 4, 2.0);
    SetMatrixLeading(J, 1, 3, 4, (-1.0)*(DYNX(DYNhelp,168)-DYNX(W_,154))-
      DYNX(DYNhelp,169)-DYNX(DYNhelp,170));
    SetMatrixLeading(J, 1, 4, 4, DYNX(W_,162)-DYNX(DYNhelp,168)+DYNX(W_,154)-
      DYNX(DYNhelp,169)+DYNX(DYNhelp,170));
    SetMatrixLeading(J, 2, 1, 4, 2.0);
    SetMatrixLeading(J, 2, 2, 4, 1.0);
    SetMatrixLeading(J, 2, 3, 4, DYNX(DYNhelp,176)-DYNX(DYNhelp,177)+
      DYNX(W_,170));
    SetMatrixLeading(J, 2, 4, 4, DYNX(DYNhelp,176)+DYNX(DYNhelp,177));
    SetMatrixLeading(J, 3, 1, 4, (-1.0000000000000002)*DYNX(W_,194));
    SetMatrixLeading(J, 3, 2, 4, (-0.9999999999999998)*DYNX(W_,194));
    SetMatrixLeading(J, 3, 3, 4, 1.0000000000000002);
    SetMatrixLeading(J, 3, 4, 4, 0.9999999999999998);
    SetMatrixLeading(J, 4, 1, 4, (-0.5773502691896256)*DYNX(W_,194));
    SetMatrixLeading(J, 4, 2, 4, 0.5773502691896257*DYNX(W_,194));
    SetMatrixLeading(J, 4, 3, 4, 0.5773502691896256);
    SetMatrixLeading(J, 4, 4, 4, -0.5773502691896257);
  }
  SetVector(b, 1,  -(DYNX(DYNhelp,85)*DYNX(W_,584)+DYNX(DYNhelp,84)*
    DYNX(DYNhelp,86)+DYNX(DYNhelp,90)*DYNX(W_,585)+DYNX(DYNhelp,89)*
    DYNX(DYNhelp,91)+DYNX(DYNhelp,92)*DYNX(DYNhelp,93)));
  SetVector(b, 2,  -(DYNX(DYNhelp,96)*DYNX(W_,584)+DYNX(DYNhelp,95)*
    DYNX(DYNhelp,86)+DYNX(DYNhelp,99)*DYNX(W_,585)+DYNX(DYNhelp,98)*
    DYNX(DYNhelp,91)+DYNX(DYNhelp,100)*DYNX(DYNhelp,93)));
  SetVector(b, 3,  -DYNX(W_,175));
  SetVector(b, 4,  -DYNX(W_,176));
  SetVector(y, 1, 0.0);
  SetVector(y, 2, 0.0);
  SetVector(y, 3, 0.0);
  SetVector(y, 4, 0.0);
  SolveLinearSystemOfEquations(J, b, y, 1, "initialization.linear[1]");
  DYNX(W_,207) = GetVector(y, 1);
  DYNX(W_,206) = GetVector(y, 2);
  DYNX(W_,39) = GetVector(y, 3);
  DYNX(W_,37) = GetVector(y, 4);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(W_,158) = DYNX(W_,162)*DYNX(W_,37);
DYNX(W_,35) =  -(DYNX(W_,37)+DYNX(W_,39));
DYNX(DYNhelp,178) = 0.6666666666666666*DYNX(W_,35);
DYNX(W_,587) = DYNX(DYNhelp,178)-0.3333333333333333*DYNX(W_,37)-0.3333333333333333
  *DYNX(W_,39);
DYNX(W_,588) = 0.5773502691896258*(DYNX(W_,37)-DYNX(W_,39));
DYNX(W_,589) = DYNX(W_,587)*DYNX(DYNhelp,79)+DYNX(W_,588)*DYNX(DYNhelp,81);
DYNX(W_,592) = DYNX(W_,584)-DYNX(W_,589);
DYNX(W_,597) = DYNX(W_,594)*(DYNX(X_,3)+DYNX(W_,592));
DYNX(W_,590) = DYNX(W_,588)*DYNX(DYNhelp,79)-DYNX(W_,587)*DYNX(DYNhelp,81);
DYNX(W_,617) = (-0.0003)*DYNX(W_,590);
DYNX(W_,602) = DYNX(W_,617)*DYNX(W_,613);
DYNX(W_,675) = DYNX(DP_,77)*DYNX(W_,597)+DYNX(DP_,78)*DYNX(W_,602);
DYNX(W_,593) = DYNX(W_,585)-DYNX(W_,590);
DYNX(W_,601) = DYNX(W_,598)*(DYNX(X_,4)+DYNX(W_,593));
DYNX(W_,614) = 0.00015*DYNX(W_,589);
DYNX(W_,615) = DYNX(DP_,81)*DYNX(W_,614)+DYNX(DYNhelp,93);
DYNX(W_,603) = DYNX(W_,615)*DYNX(W_,613);
DYNX(W_,676) = DYNX(DP_,79)*DYNX(W_,601)+DYNX(DP_,80)*DYNX(W_,603);
DYNX(W_,591) = DYNX(W_,675)*DYNX(DYNhelp,81)+DYNX(W_,676)*DYNX(DYNhelp,79);
DYNX(W_,34) = DYNX(W_,675)*DYNX(DYNhelp,79)-DYNX(W_,676)*DYNX(DYNhelp,81);
DYNX(DYNhelp,179) = 0.8660254037844386*DYNX(W_,591);
DYNX(W_,36) = DYNX(DYNhelp,179)-0.5*DYNX(W_,34);
DYNX(W_,150) = DYNX(W_,154)*DYNX(W_,35);
DYNX(DYNhelp,180) = DYNX(W_,206)+DYNX(W_,207);
DYNX(W_,123) = DYNX(W_,34)-DYNX(W_,150)+DYNX(DYNhelp,180);
DYNX(W_,166) = DYNX(W_,170)*DYNX(W_,39);
DYNX(W_,38) = (-0.5)*DYNX(W_,34)-DYNX(DYNhelp,179);
DYNX(W_,227) = 0.5773502691896256*DYNX(W_,39)-0.5773502691896257*DYNX(W_,37);
DYNX(W_,180) = 0.5773502691896257*DYNX(W_,206)-0.5773502691896256*DYNX(W_,207);
DYNX(W_,201) = DYNX(W_,194)*DYNX(W_,180);
DYNX(W_,205) =  -DYNX(DYNhelp,180);
DYNX(W_,179) = 0.6666666666666666*DYNX(W_,205)-0.33333333333333315*DYNX(W_,206)-
  0.3333333333333336*DYNX(W_,207);
DYNX(W_,200) = DYNX(W_,194)*DYNX(W_,179);
DYNX(W_,226) = 0.3333333333333336*DYNX(W_,39)-DYNX(DYNhelp,178)+0.33333333333333315
  *DYNX(W_,37);
 /* End of Equation Block */ 

DYNX(W_,321) = DYNX(X_,0)+DYNX(W_,345);
DYNX(W_,308) = DYNX(W_,322)*DYNX(W_,321);
DYNX(W_,309) = DYNX(W_,325)*DYNX(X_,1);
DYNX(W_,76) = IF fabs(DYNX(X_,15)) > DYNX(W_,83) THEN DYNX(W_,81)*(IF 
  DYNX(X_,15) > 0 THEN 1 ELSE IF DYNX(X_,15) < 0 THEN -1 ELSE 0)*powGuarded(
  divGuarded(fabs(DYNX(X_,15)),"abs(inertia.w)",DYNX(W_,79),"machine.coreElement.friction.frictionParameters.wRef"),
  "abs(inertia.w)/machine.coreElement.friction.frictionParameters.wRef",
  DYNX(W_,80),"machine.coreElement.friction.frictionParameters.power_w") ELSE 
  divGuarded(DYNX(W_,84)*DYNX(X_,15),"machine.coreElement.friction.frictionParameters.tauLinear*inertia.w",
  DYNX(W_,83),"machine.coreElement.friction.frictionParameters.wLinear");
DYNX(W_,304) = DYNX(W_,312)*DYNX(W_,308)+DYNX(W_,313)*DYNX(W_,309);
DYNX(W_,305) = DYNX(W_,314)*DYNX(W_,308)+DYNX(W_,315)*DYNX(W_,309);
DYNX(W_,63) = 1.5*DYNX(W_,300)*(DYNX(W_,176)*DYNX(W_,304)-DYNX(W_,175)*
  DYNX(W_,305));
DYNX(W_,359) = sqrtGuarded(0.3333333333333333*(sqr(DYNX(W_,35))+sqr(DYNX(W_,37))
  +sqr(DYNX(W_,39))),"0.3333333333333333*(machine.plug_p.pin[1].i^2+machine.plug_p.pin[2].i^2+machine.plug_p.pin[3].i^2)");
DYNX(W_,347) = DYNX(W_,356)*(DYNX(W_,351)+(1-DYNX(W_,351))*powGuarded(divGuarded
  (DYNX(W_,359),"machine.coreElement.permanentMagnet.iRMS",DYNX(W_,352),
  "machine.coreElement.permanentMagnet.permanentMagnetLossParameters.IRef"),
  "machine.coreElement.permanentMagnet.iRMS/machine.coreElement.permanentMagnet.permanentMagnetLossParameters.IRef",
  DYNX(W_,353),"machine.coreElement.permanentMagnet.permanentMagnetLossParameters.power_I"))
  *(IF DYNX(X_,15) > 0 THEN 1 ELSE IF DYNX(X_,15) < 0 THEN -1 ELSE 0)*powGuarded
  (divGuarded(fabs(DYNX(X_,15)),"abs(inertia.w)",DYNX(W_,354),"machine.coreElement.permanentMagnet.permanentMagnetLossParameters.wRef"),
  "abs(inertia.w)/machine.coreElement.permanentMagnet.permanentMagnetLossParameters.wRef",
  DYNX(W_,355),"machine.coreElement.permanentMagnet.permanentMagnetLossParameters.power_w");
DYNX(W_,243) = sqrtGuarded(0.3333333333333333*(sqr(DYNX(W_,35))+sqr(DYNX(W_,37))
  +sqr(DYNX(W_,39))),"0.3333333333333333*(machine.plug_p.pin[1].i^2+machine.plug_p.pin[2].i^2+machine.plug_p.pin[3].i^2)");
DYNX(W_,234) = DYNX(W_,240)*sqr(divGuarded(DYNX(W_,243),"machine.coreElement.strayLoad.iRMS",
  DYNX(W_,237),"machine.coreElement.strayLoad.strayLoadParameters.IRef"))*(IF 
  DYNX(X_,15) > 0 THEN 1 ELSE IF DYNX(X_,15) < 0 THEN -1 ELSE 0)*powGuarded(
  divGuarded(fabs(DYNX(X_,15)),"abs(inertia.w)",DYNX(W_,238),"machine.coreElement.strayLoad.strayLoadParameters.wRef"),
  "abs(inertia.w)/machine.coreElement.strayLoad.strayLoadParameters.wRef",
  DYNX(W_,239),"machine.coreElement.strayLoad.strayLoadParameters.power_w");
DYNX(W_,491) =  -DYNX(W_,493)*sqr(divGuarded(DYNX(X_,15),"inertia.w",
  DYNX(W_,495),"load.w_nominal"));

 /* Linear system of equations to solve. */
/* Tag: initialization.linear[2] */
DYNX(F_,15) = 0.0;
SolveScalarLinearParametric(DYNX(DP_,160)+DYNX(W_,65),"inertia.J+machine.coreElement.inertiaRotor.J",
    -(DYNX(W_,491)+DYNX(W_,76)+DYNX(W_,347)+DYNX(W_,234)-DYNX(W_,63)),
  " -(load.flange.tau+machine.coreElement.friction.flange.tau+machine.coreElement.permanentMagnet.flange.tau+machine.coreElement.strayLoad.flange.tau-machine.coreElement.tauElectrical)",
   DYNX(F_,15),"der(inertia.w)");
DYNX(W_,64) = DYNX(W_,65)*DYNX(F_,15)-DYNX(W_,63);
DYNX(W_,40) = DYNX(W_,76)+DYNX(W_,64)+DYNX(W_,347)+DYNX(W_,234);
 /* End of Equation Block */ 

RealAssign (RealTemporaryDense( &DYNX(W_,451), 1, 2), (PushModelContext(1,
  "Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor({machine.plug_p.pin[1].v, machine.plug_p.pin[2].v, machine.plug_p.pin[3].v})")
  Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor(
  RealScalarArray ( 3, DYNX(W_,34), DYNX(W_,36), DYNX(W_,38))).y0_0_0member));
PopAllMarks();
RealAssign (RealTemporaryDense( &DYNX(W_,453), 1, 2), (PushModelContext(1,
  "Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor({machine.plug_p.pin[1].i, machine.plug_p.pin[2].i, machine.plug_p.pin[3].i})")
  Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor(
  RealScalarArray ( 3, DYNX(W_,35), DYNX(W_,37), DYNX(W_,39))).y0_0_0member));
PopAllMarks();
DYNX(W_,449) = 1.5*(DYNX(W_,451)*DYNX(W_,453)+DYNX(W_,452)*DYNX(W_,454));
DYNX(W_,363) = DYNX(W_,63)+DYNX(W_,64);
DYNX(W_,362) = DYNX(W_,363)-DYNX(W_,40);
DYNX(W_,396) = DYNX(DP_,28)*DYNX(W_,362);
DYNX(W_,397) = DYNX(X_,15)*DYNX(W_,396);
DYNX(W_,801) = RealBmin(DYNX(W_,397), DYNX(W_,449));
DYNX(W_,821) = RealBmin(DYNX(W_,801), DYNX(DP_,152));
DYNX(W_,795) = DYNX(DP_,145)*DYNX(W_,821);
DYNX(W_,822) = DYNX(DP_,148)*DYNX(W_,821)+DYNX(DP_,149)*DYNX(W_,801);
DYNX(W_,800) = RealBmax(DYNX(W_,397), DYNX(W_,449));
DYNX(W_,796) = DYNX(DP_,150)*DYNX(W_,822)+DYNX(DP_,151)*DYNX(W_,800);
DYNX(W_,744) = IF fabs(DYNX(W_,796)) < 1E-60 THEN (IF DYNX(W_,796) >= 0 THEN 
  1E+60*DYNX(W_,795) ELSE (-1E+60)*DYNX(W_,795)) ELSE divGuarded(DYNX(W_,795),
  "machineEfficiencyComputation.powerEfficiencyComp.u1",DYNX(W_,796),
  "machineEfficiencyComputation.powerEfficiencyComp.u2");
DYNX(W_,743) = homotopy(IF DYNX(W_,744) > DYNX(DP_,127) THEN DYNX(DP_,127) ELSE 
  IF DYNX(W_,744) < DYNX(DP_,128) THEN DYNX(DP_,128) ELSE DYNX(W_,744), 
  DYNX(W_,744));
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(F_,2) = DYNX(X_,15);
DYNX(W_,301) = DYNX(W_,300)*(DYNX(X_,2)-DYNX(DP_,27));
DYNX(W_,314) = sin(DYNX(W_,301));
DYNX(W_,315) = cos(DYNX(W_,301));
DYNX(W_,176) = DYNX(W_,314)*DYNX(X_,0)+DYNX(W_,315)*DYNX(X_,1);
DYNX(W_,312) = DYNX(W_,315);
DYNX(W_,313) =  -DYNX(W_,314);
DYNX(W_,175) = DYNX(W_,312)*DYNX(X_,0)+DYNX(W_,313)*DYNX(X_,1);
DYNX(W_,392) = DYNX(X_,2)-DYNX(DP_,29);
DYNX(W_,586) = DYNX(W_,621)*DYNX(W_,392);
DYNX(W_,496) = DYNX(DP_,116)+(IF LessTime(DYNX(DP_,117), 0) THEN 0 ELSE IF 
  LessTime(DYNX(DP_,117)+DYNX(DP_,115), 1) THEN divGuarded((DYNTime-
  DYNX(DP_,117))*DYNX(W_,741),"(time-desiredSpeed.startTime)*desiredSpeed.height",
  DYNX(DP_,115),"desiredSpeed.duration") ELSE DYNX(W_,741));
DYNX(W_,860) = DYNX(W_,861)*DYNX(W_,496)+DYNX(DP_,168)*DYNX(X_,15);
DYNX(W_,715) = DYNX(DP_,169)*DYNX(W_,860);
DYNX(W_,713) = DYNX(DP_,104)*DYNX(W_,715)+DYNX(DP_,105)*DYNX(X_,17);
DYNX(W_,714) = DYNX(W_,712)*DYNX(W_,713);
DYNX(W_,738) = DYNX(W_,740)+(IF LessTime(DYNX(DP_,114), 2) THEN 0 ELSE IF 
  LessTime(DYNX(DP_,114)+DYNX(DP_,113), 3) THEN divGuarded((DYNTime-
  DYNX(DP_,114))*DYNX(W_,739),"(time-maxLineVoltage.startTime)*maxLineVoltage.height",
  DYNX(DP_,113),"maxLineVoltage.duration") ELSE DYNX(W_,739));
DYNX(W_,685) = 0.816496580927726*DYNX(W_,738);
DYNX(W_,678) = DYNX(W_,677)*DYNX(X_,15);

{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[1] */
/* Introducing 10 common subexpressions and reusing 1 variables totally used in 3
   expressions */
/* Of the common subexpressions 10 are reals, 0 are integers, and 1
   are booleans. */
const char*const varnames_[]={"controller.coreElement.currentLimits.withReluctance.i_s_max_MTPV",
   "controller.coreElement.currentLimits.i_s_limit"};
const double nominal_[]={1, 1};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 2, 0, 1, 2, 17, 3, 
  DYNX(DYNhelp,181), 59, DYNX(did_->helpvari_vec,36), 24);
NonLinearSystemSave(DYNX(W_,685), 0);
NonLinearSystemSave(DYNX(W_,678), 1);
NonLinearSystemSave(DYNX(W_,714), 2);
SetInitVectorNH(x__, 1, DYNX(W_,695), Remember_(DYNX(W_,695), 0));
SetInitVectorNH(x__, 2, DYNX(W_,686), Remember_(DYNX(W_,686), 1));
Residues;
  DYNX(W_,720) = IF DYNX(W_,686) >= 0 THEN DYNX(W_,686) ELSE  -DYNX(W_,686);
  DYNX(W_,719) = DYNX(DP_,107)*DYNX(W_,720);
  DYNX(W_,659) = IF GreaterS(DYNX(W_,714),"controller.coreElement.speedController.gainPI.y",
     DYNX(W_,686),"controller.coreElement.currentLimits.i_s_limit", 1) THEN 
    DYNX(W_,686) ELSE IF LessS(DYNX(W_,714),"controller.coreElement.speedController.gainPI.y",
     DYNX(W_,719),"controller.coreElement.speedController.limiter.limit2", 2)
     THEN DYNX(W_,719) ELSE DYNX(W_,714);
  DYNX(W_,696) = IF (IF DYNX(W_,659) > 0 THEN 1 ELSE IF DYNX(W_,659) < 0 THEN -1
     ELSE 0) == (IF DYNX(W_,678) > 0 THEN 1 ELSE IF DYNX(W_,678) < 0 THEN -1
     ELSE 0) THEN 1 ELSE 0;
  DYNX(DYNhelp,240) = fabs(DYNX(W_,659));
  DYNX(W_,627) = DYNX(W_,692)*DYNX(W_,685)-DYNX(W_,696)*DYNX(DYNhelp,240)*
    DYNX(W_,689);
  DYNX(W_,698) = (PushModelContext(1,"DymolaModels.Functions.Math.divNoZero(controller.coreElement.fieldWeakeningController.u_s_max, controller.coreElement.mechanicalToElectricSpeed.y, 1, true)")
    DymolaModels_Functions_Math_divNoZero(DYNX(W_,627), DYNX(W_,678), 1, true));
  PopModelContext();
  DYNX(DYNhelp,241) = 0.0003*DYNX(W_,690);
  DYNX(DYNhelp,242) = sqr(DYNX(W_,698));
  DYNX(DYNhelp,243) = sqrtGuarded(sqr(DYNX(DYNhelp,241))+1.7999999999999997E-07*
    DYNX(DYNhelp,242),"(0.0003*controller.coreElement.currentLimits.withReluctance.psi_PM)^2+1.7999999999999997E-07*controller.coreElement.currentLimits.withReluctance.psi_MTPV^2");
  DYNX(W_,697) = (-1666.6666666666667)*(DYNX(DYNhelp,241)-DYNX(DYNhelp,243));
  DYNX(DYNhelp,244) = RealBmax(0, DYNX(DYNhelp,242)-sqr(DYNX(W_,697)));
  DYNX(DYNhelp,245) = sqrtGuarded(DYNX(DYNhelp,244),"max(0, controller.coreElement.currentLimits.withReluctance.psi_MTPV^2-controller.coreElement.currentLimits.withReluctance.delta_psi^2)");
  DYNX(W_,694) = 3333.3333333333335*DYNX(DYNhelp,245);
  DYNX(DYNhelp,246) = fabs(DYNX(W_,695));
  DYNX(DYNhelp,247) = LessS(DYNX(DYNhelp,246),"abs(controller.coreElement.currentLimits.withReluctance.i_s_max_MTPV)",
     DYNX(W_,691),"controller.coreElement.currentLimits.withReluctance.i_s_peak",
     0);
  DYNX(W_,674) = IF DYNX(DYNhelp,247) THEN DYNX(W_,694) ELSE DYNX(W_,691);
  DYNX(W_,693) = (-6666.666666666667)*(DYNX(W_,690)+DYNX(W_,697));
    DYNX(Aux_,2) = 1666.6666666666667*(DYNX(W_,658)-sqrtGuarded(sqr(DYNX(W_,658))
      +1.7999999999999997E-07*sqr(DYNX(W_,659)),"controller.coreElement.MTPA.psi_PM^2+1.7999999999999997E-07*controller.coreElement.MTPA.i_s_ref^2"));
    DYNX(Aux_,3) = IF sqr(DYNX(W_,659))-sqr(DYNX(Aux_,2)) <= 0 THEN 0 ELSE (IF 
      DYNX(W_,659) > 0 THEN 1 ELSE IF DYNX(W_,659) < 0 THEN -1 ELSE 0)*
      sqrtGuarded(sqr(DYNX(W_,659))-sqr(DYNX(Aux_,2)),"controller.coreElement.MTPA.i_s_ref^2-controller.coreElement.MTPA.i_d_mtpa_alg2.0.^2");
  DYNX(W_,660) = DYNX(Aux_,2);
  DYNX(W_,654) = IF DYNX(DYNhelp,247) THEN DYNX(W_,693)-DYNX(W_,660) ELSE  -(
    DYNX(W_,691)+DYNX(W_,660));
  DYNX(W_,661) = DYNX(Aux_,3);
DYNX(DYNhelp,248) = sqrtGuarded(sqr(DYNX(W_,654)+DYNX(W_,660))+sqr(DYNX(W_,674)),
  "(controller.coreElement.fieldWeakeningController.i_d_min+controller.coreElement.MTPA.i_d_mtpa)^2+controller.coreElement.limit_i_q.i_q_max^2");
DYNX(DYNhelp,249) = RealBmin(DYNX(W_,691), DYNX(DYNhelp,248));
SetVector(residue__, 1, sqr(DYNX(W_,695))-(sqr(DYNX(W_,693))+sqr(DYNX(W_,694))));
SetVector(residue__, 2, DYNX(W_,686)-DYNX(DYNhelp,249));

{ /* No analytic Jacobian available*/
SolveNonLinearSystemOfEquationsNH(Jacobian__, 0, 0, 0, residue__, x__, 2, 
  "Tag: simulation.nonlinear[1]");
DYNX(W_,695) = GetVector(x__, 1);
DYNX(W_,686) = GetVector(x__, 2);
EndNonLinearSystemOfEquationsNH(residue__, x__, 2);
 /* End of Non-Linear Equation Block */ }



AssertModelica(GreaterEqual(DYNX(W_,686),"controller.coreElement.currentLimits.i_s_limit",
   DYNX(W_,719),"controller.coreElement.speedController.limiter.limit2", 3),
  "controller.coreElement.currentLimits.i_s_limit >= controller.coreElement.speedController.limiter.limit2",
   "Input signals are not consistent: limit1 < limit2");
AssertModelica(GreaterEqual(DYNX(W_,686),"controller.coreElement.currentLimits.i_s_limit",
   DYNX(W_,719),"controller.coreElement.speedController.limiter.limit2", 3),
  "controller.coreElement.currentLimits.i_s_limit >= controller.coreElement.speedController.limiter.limit2",
   StringAdd(StringAdd(StringAdd(StringAdd("\n### Error in class LimitedPI: Limits must be consistent. However, yMax (=",
  Real2String2(DYNX(W_,686), true, 0)),") < limiter.limit2 (="),Real2String2(
  DYNX(W_,719), true, 0)),")###\n"));
PopAllMarks();
DYNX(W_,673) = DYNX(DP_,97)*DYNX(W_,674);
AssertModelica(GreaterEqual(DYNX(W_,674),"controller.coreElement.limit_i_q.i_q_max",
   DYNX(W_,673),"controller.coreElement.limit_i_q.variableLimiter1.limit2", 4),
  "controller.coreElement.limit_i_q.i_q_max >= controller.coreElement.limit_i_q.variableLimiter1.limit2",
   "Input signals are not consistent: limit1 < limit2");
DYNX(W_,663) = IF GreaterS(DYNX(W_,661),"controller.coreElement.MTPA.i_q_mtpa", 
  DYNX(W_,674),"controller.coreElement.limit_i_q.i_q_max", 5) THEN DYNX(W_,674)
   ELSE IF LessS(DYNX(W_,661),"controller.coreElement.MTPA.i_q_mtpa", 
  DYNX(W_,673),"controller.coreElement.limit_i_q.variableLimiter1.limit2", 6)
   THEN DYNX(W_,673) ELSE DYNX(W_,661);
DYNX(W_,628) = DYNX(W_,650)*DYNX(W_,627);
DYNX(W_,847) = DYNX(W_,848)*DYNX(W_,628)+DYNX(DP_,161)*DYNX(X_,5);
DYNX(W_,641) = DYNX(DP_,162)*DYNX(W_,847);
DYNX(W_,639) = DYNX(DP_,87)*DYNX(W_,641)+DYNX(DP_,88)*DYNX(X_,16);
DYNX(W_,640) = DYNX(W_,638)*DYNX(W_,639);
DYNX(W_,655) = RealBmin(DYNX(W_,654), DYNX(DP_,93));
DYNX(W_,626) = IF GreaterS(DYNX(W_,640),"controller.coreElement.fieldWeakeningController.fieldWeakeningController.gainPI.y",
   DYNX(DP_,92),"controller.coreElement.fieldWeakeningController.delta_i_d_max.k",
   8) THEN DYNX(DP_,92) ELSE IF LessS(DYNX(W_,640),"controller.coreElement.fieldWeakeningController.fieldWeakeningController.gainPI.y",
   DYNX(W_,655),"controller.coreElement.fieldWeakeningController.aboveZeroProtection.y",
   9) THEN DYNX(W_,655) ELSE DYNX(W_,640);
DYNX(W_,584) = DYNX(DP_,98)*DYNX(W_,660)+DYNX(DP_,99)*DYNX(W_,626);
DYNX(W_,667) = IF sqr(DYNX(W_,669))-sqr(DYNX(W_,584)) <= 0 THEN 0 ELSE 
  sqrtGuarded(sqr(DYNX(W_,669))-sqr(DYNX(W_,584)),"controller.coreElement.limit_i_q.availableCurrent.i_s_peak^2-controller.coreElement.currentControllers.i_d_ref^2");
DYNX(W_,668) = DYNX(DP_,95)*DYNX(W_,667);
AssertModelica(GreaterEqual(DYNX(W_,667),"controller.coreElement.limit_i_q.variableLimiter.limit1",
   DYNX(W_,668),"controller.coreElement.limit_i_q.variableLimiter.limit2", 10),
  "controller.coreElement.limit_i_q.variableLimiter.limit1 >= controller.coreElement.limit_i_q.variableLimiter.limit2",
   "Input signals are not consistent: limit1 < limit2");
DYNX(W_,585) = IF GreaterS(DYNX(W_,663),"controller.coreElement.limit_i_q.variableLimiter.u",
   DYNX(W_,667),"controller.coreElement.limit_i_q.variableLimiter.limit1", 11)
   THEN DYNX(W_,667) ELSE IF LessS(DYNX(W_,663),"controller.coreElement.limit_i_q.variableLimiter.u",
   DYNX(W_,668),"controller.coreElement.limit_i_q.variableLimiter.limit2", 12)
   THEN DYNX(W_,668) ELSE DYNX(W_,663);
DYNX(W_,613) = DYNX(W_,620)*DYNX(X_,15);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[1] */
/* Introducing 41 common subexpressions used in 55 expressions */
/* Of the common subexpressions 41 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,250) = cos(DYNX(W_,586));
DYNX(DYNhelp,251) = 0.8660254037844386*DYNX(DYNhelp,250);
DYNX(DYNhelp,252) = sin(DYNX(W_,586));
DYNX(DYNhelp,253) = 1.5*DYNX(DYNhelp,252);
DYNX(DYNhelp,254) = DYNX(DYNhelp,251)+DYNX(DYNhelp,253);
DYNX(DYNhelp,255) = DYNX(W_,613)*DYNX(DP_,80)*DYNX(DYNhelp,254);
DYNX(DYNhelp,256) = DYNX(DP_,82)*DYNX(W_,618);
DYNX(DYNhelp,257) = DYNX(DP_,79)*DYNX(DYNhelp,254);
DYNX(DYNhelp,258) = DYNX(W_,598)*DYNX(DYNhelp,257);
DYNX(DYNhelp,259) = DYNX(W_,598)*DYNX(X_,4);
DYNX(DYNhelp,260) = 1.5*DYNX(DYNhelp,250);
DYNX(DYNhelp,261) = 0.8660254037844386*DYNX(DYNhelp,252)-DYNX(DYNhelp,260);
DYNX(DYNhelp,262) = DYNX(DP_,77)*DYNX(DYNhelp,261);
DYNX(DYNhelp,263) = DYNX(W_,594)*DYNX(DYNhelp,262);
DYNX(DYNhelp,264) = DYNX(W_,594)*DYNX(X_,3);
DYNX(DYNhelp,265) = DYNX(DYNhelp,253)-DYNX(DYNhelp,251);
DYNX(DYNhelp,266) = DYNX(W_,613)*DYNX(DP_,80)*DYNX(DYNhelp,265);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(5);
DYNX(DYNhelp,267) = DYNX(DP_,79)*DYNX(DYNhelp,265);
DYNX(DYNhelp,268) = DYNX(W_,598)*DYNX(DYNhelp,267);
DYNX(DYNhelp,269) = (-0.8660254037844386)*DYNX(DYNhelp,252)-DYNX(DYNhelp,260);
DYNX(DYNhelp,270) = DYNX(DP_,77)*DYNX(DYNhelp,269);
DYNX(DYNhelp,271) = DYNX(W_,594)*DYNX(DYNhelp,270);
/* Automatic tearing of linear system of 35 simultaneous equations
gave a linear system of 4 equations for numerical solution.*/
{
  const char*const varnames_[]={"machine.plug_p.pin[3].i", "machine.coreElement.spacePhasorS.v[3]",
     "machine.coreElement.spacePhasorS.v[2]", "machine.plug_p.pin[2].i"};
  const double nominal_[]={1, 1, 1, 1};
  DidLinearSystemOfEquations(J, b, y, 4, DYNX(DYNhelp,272), 64, DYNX(did_->helpvari_vec,60), 12);
  /* Jacobian depending on continuous variables */
  SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    DYNX(DYNhelp,336) = (-0.0003)*DYNX(W_,613)*DYNX(DP_,78)*DYNX(DYNhelp,261)-
      DYNX(DYNhelp,258);
    DYNX(DYNhelp,337) = 0.00015*DYNX(DP_,81)*DYNX(DYNhelp,255)-DYNX(DYNhelp,263);
    DYNX(DYNhelp,338) = DYNX(DYNhelp,250)*DYNX(DYNhelp,336)+DYNX(DYNhelp,252)*
      DYNX(DYNhelp,337);
    DYNX(DYNhelp,339) = DYNX(DYNhelp,250)*DYNX(DYNhelp,337);
    DYNX(DYNhelp,340) = DYNX(DYNhelp,252)*DYNX(DYNhelp,336);
    DYNX(DYNhelp,341) = DYNX(DYNhelp,339)-DYNX(DYNhelp,340);
    DYNX(DYNhelp,342) = 0.6666666666666666*DYNX(DYNhelp,341)+DYNX(W_,154);
    DYNX(DYNhelp,343) = 0.3333333333333333*DYNX(DYNhelp,341);
    DYNX(DYNhelp,344) = (-0.0003)*DYNX(W_,613)*DYNX(DP_,78)*DYNX(DYNhelp,269)-
      DYNX(DYNhelp,268);
    DYNX(DYNhelp,345) = DYNX(DYNhelp,250)*DYNX(DYNhelp,344);
    DYNX(DYNhelp,346) = 0.00015*DYNX(DP_,81)*DYNX(DYNhelp,266)-DYNX(DYNhelp,271);
    DYNX(DYNhelp,347) = DYNX(DYNhelp,252)*DYNX(DYNhelp,346);
    DYNX(DYNhelp,348) = DYNX(DYNhelp,345)+DYNX(DYNhelp,347);
    DYNX(DYNhelp,349) = DYNX(DYNhelp,250)*DYNX(DYNhelp,346)-DYNX(DYNhelp,252)*
      DYNX(DYNhelp,344);
    DYNX(DYNhelp,350) = 0.6666666666666666*DYNX(DYNhelp,349)+DYNX(W_,154);
    DYNX(DYNhelp,351) = 0.3333333333333333*DYNX(DYNhelp,349);
    SetMatrixLeading(J, 1, 1, 4, (-0.5773502691896258)*DYNX(DYNhelp,338)-
      DYNX(DYNhelp,342)-DYNX(DYNhelp,343));
    SetMatrixLeading(J, 1, 2, 4, -1.0);
    SetMatrixLeading(J, 1, 3, 4, -2.0);
    SetMatrixLeading(J, 1, 4, 4, 0.5773502691896258*DYNX(DYNhelp,338)-
      DYNX(DYNhelp,342)-DYNX(DYNhelp,343)-DYNX(W_,162));
    SetMatrixLeading(J, 2, 1, 4, (-0.5773502691896258)*DYNX(DYNhelp,348)-
      DYNX(DYNhelp,350)-DYNX(DYNhelp,351)-DYNX(W_,170));
    SetMatrixLeading(J, 2, 2, 4, -2.0);
    SetMatrixLeading(J, 2, 3, 4, -1.0);
    SetMatrixLeading(J, 2, 4, 4, 0.5773502691896258*DYNX(DYNhelp,348)-
      DYNX(DYNhelp,350)-DYNX(DYNhelp,351));
    SetMatrixLeading(J, 3, 1, 4, 1.0000000000000002);
    SetMatrixLeading(J, 3, 2, 4, (-1.0000000000000002)*DYNX(W_,194));
    SetMatrixLeading(J, 3, 3, 4, (-0.9999999999999998)*DYNX(W_,194));
    SetMatrixLeading(J, 3, 4, 4, 0.9999999999999998);
    SetMatrixLeading(J, 4, 1, 4, 0.5773502691896256);
    SetMatrixLeading(J, 4, 2, 4, (-0.5773502691896256)*DYNX(W_,194));
    SetMatrixLeading(J, 4, 3, 4, 0.5773502691896257*DYNX(W_,194));
    SetMatrixLeading(J, 4, 4, 4, -0.5773502691896257);
  }
  SetVector(b, 1,  -(DYNX(DYNhelp,255)*DYNX(DYNhelp,256)+DYNX(DYNhelp,258)*
    DYNX(W_,585)+DYNX(DYNhelp,257)*DYNX(DYNhelp,259)+DYNX(DYNhelp,263)*
    DYNX(W_,584)+DYNX(DYNhelp,262)*DYNX(DYNhelp,264)));
  SetVector(b, 2,  -(DYNX(DYNhelp,266)*DYNX(DYNhelp,256)+DYNX(DYNhelp,268)*
    DYNX(W_,585)+DYNX(DYNhelp,267)*DYNX(DYNhelp,259)+DYNX(DYNhelp,271)*
    DYNX(W_,584)+DYNX(DYNhelp,270)*DYNX(DYNhelp,264)));
  SetVector(b, 3,  -DYNX(W_,175));
  SetVector(b, 4,  -DYNX(W_,176));
  SetVector(y, 1, RememberSimple_(DYNX(W_,39), 2));
  SetVector(y, 2, RememberSimple_(DYNX(W_,207), 3));
  SetVector(y, 3, RememberSimple_(DYNX(W_,206), 4));
  SetVector(y, 4, RememberSimple_(DYNX(W_,37), 5));
  SolveLinearSystemOfEquations(J, b, y, 1, "simulation.linear[1]");
  DYNX(W_,39) = GetVector(y, 1);
  DYNX(W_,207) = GetVector(y, 2);
  DYNX(W_,206) = GetVector(y, 3);
  DYNX(W_,37) = GetVector(y, 4);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(W_,588) = 0.5773502691896258*(DYNX(W_,37)-DYNX(W_,39));
DYNX(W_,35) =  -(DYNX(W_,37)+DYNX(W_,39));
DYNX(DYNhelp,352) = 0.6666666666666666*DYNX(W_,35);
DYNX(W_,587) = DYNX(DYNhelp,352)-0.3333333333333333*DYNX(W_,37)-0.3333333333333333
  *DYNX(W_,39);
DYNX(W_,590) = DYNX(W_,588)*DYNX(DYNhelp,250)-DYNX(W_,587)*DYNX(DYNhelp,252);
DYNX(W_,617) = (-0.0003)*DYNX(W_,590);
DYNX(W_,602) = DYNX(W_,617)*DYNX(W_,613);
DYNX(W_,158) = DYNX(W_,162)*DYNX(W_,37);
DYNX(W_,589) = DYNX(W_,587)*DYNX(DYNhelp,250)+DYNX(W_,588)*DYNX(DYNhelp,252);
DYNX(W_,614) = 0.00015*DYNX(W_,589);
DYNX(W_,615) = DYNX(DP_,81)*DYNX(W_,614)+DYNX(DYNhelp,256);
DYNX(W_,603) = DYNX(W_,615)*DYNX(W_,613);
DYNX(W_,593) = DYNX(W_,585)-DYNX(W_,590);
DYNX(W_,601) = DYNX(W_,598)*(DYNX(X_,4)+DYNX(W_,593));
DYNX(W_,676) = DYNX(DP_,79)*DYNX(W_,601)+DYNX(DP_,80)*DYNX(W_,603);
DYNX(W_,592) = DYNX(W_,584)-DYNX(W_,589);
DYNX(W_,597) = DYNX(W_,594)*(DYNX(X_,3)+DYNX(W_,592));
DYNX(W_,675) = DYNX(DP_,77)*DYNX(W_,597)+DYNX(DP_,78)*DYNX(W_,602);
DYNX(W_,591) = DYNX(W_,675)*DYNX(DYNhelp,252)+DYNX(W_,676)*DYNX(DYNhelp,250);
DYNX(W_,34) = DYNX(W_,675)*DYNX(DYNhelp,250)-DYNX(W_,676)*DYNX(DYNhelp,252);
DYNX(DYNhelp,353) = 0.8660254037844386*DYNX(W_,591);
DYNX(W_,36) = DYNX(DYNhelp,353)-0.5*DYNX(W_,34);
DYNX(W_,150) = DYNX(W_,154)*DYNX(W_,35);
DYNX(DYNhelp,354) = DYNX(W_,206)+DYNX(W_,207);
DYNX(W_,123) = DYNX(W_,34)-DYNX(W_,150)+DYNX(DYNhelp,354);
DYNX(W_,205) =  -DYNX(DYNhelp,354);
DYNX(W_,179) = 0.6666666666666666*DYNX(W_,205)-0.33333333333333315*DYNX(W_,206)-
  0.3333333333333336*DYNX(W_,207);
DYNX(W_,200) = DYNX(W_,194)*DYNX(W_,179);
DYNX(W_,226) = 0.3333333333333336*DYNX(W_,39)-DYNX(DYNhelp,352)+0.33333333333333315
  *DYNX(W_,37);
DYNX(W_,166) = DYNX(W_,170)*DYNX(W_,39);
DYNX(W_,180) = 0.5773502691896257*DYNX(W_,206)-0.5773502691896256*DYNX(W_,207);
DYNX(W_,201) = DYNX(W_,194)*DYNX(W_,180);
DYNX(W_,227) = 0.5773502691896256*DYNX(W_,39)-0.5773502691896257*DYNX(W_,37);
DYNX(W_,38) = (-0.5)*DYNX(W_,34)-DYNX(DYNhelp,353);
 /* End of Equation Block */ 

DYNX(W_,132) = DYNX(W_,207)+DYNX(W_,123);
DYNX(W_,131) = DYNX(W_,206)+DYNX(W_,123);
DYNX(W_,130) = DYNX(W_,123)-(DYNX(W_,206)+DYNX(W_,207));
DYNX(W_,302) = DYNX(W_,300)*DYNX(X_,15);
DYNX(W_,316) =  -DYNX(W_,302)*DYNX(W_,314);
DYNX(W_,321) = DYNX(X_,0)+DYNX(W_,345);
DYNX(W_,308) = DYNX(W_,322)*DYNX(W_,321);
DYNX(W_,318) = DYNX(W_,302)*DYNX(W_,315);
DYNX(W_,319) =  -DYNX(W_,302)*DYNX(W_,314);
DYNX(W_,309) = DYNX(W_,325)*DYNX(X_,1);
DYNX(W_,317) =  -DYNX(W_,302)*DYNX(W_,315);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[2] */
/* Introducing 8 common subexpressions used in 8 expressions */
/* Of the common subexpressions 8 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,355) = DYNX(W_,316)*DYNX(X_,0);
DYNX(DYNhelp,356) = DYNX(W_,317)*DYNX(X_,1);
DYNX(DYNhelp,357) = DYNX(W_,316)*DYNX(W_,308);
DYNX(DYNhelp,358) = DYNX(W_,317)*DYNX(W_,309);
DYNX(DYNhelp,359) = DYNX(W_,318)*DYNX(X_,0);
DYNX(DYNhelp,360) = DYNX(W_,319)*DYNX(X_,1);
DYNX(DYNhelp,361) = DYNX(W_,318)*DYNX(W_,308);
DYNX(DYNhelp,362) = DYNX(W_,319)*DYNX(W_,309);
/* Automatic tearing of linear system of 10 simultaneous equations
gave a linear system of 2 equations for numerical solution.*/
{
  const char*const varnames_[]={"machine.coreElement.der(idq_sr[1])", 
    "machine.coreElement.der(idq_sr[2])"};
  const double nominal_[]={1, 1};
  DidLinearSystemOfEquations(J, b, y, 2, DYNX(DYNhelp,363), 24, DYNX(did_->helpvari_vec,72), 8);
  /* Jacobian depending on continuous variables */
  SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    SetMatrixLeading(J, 1, 1, 2, (-1.0)*DYNX(W_,312)*DYNX(W_,322)-DYNX(W_,171)*
      DYNX(W_,312));
    SetMatrixLeading(J, 1, 2, 2, (-1.0)*DYNX(W_,313)*DYNX(W_,325)-DYNX(W_,171)*
      DYNX(W_,313));
    SetMatrixLeading(J, 2, 1, 2, (-1.0)*DYNX(W_,314)*DYNX(W_,322)-DYNX(W_,172)*
      DYNX(W_,314));
    SetMatrixLeading(J, 2, 2, 2, (-1.0)*DYNX(W_,315)*DYNX(W_,325)-DYNX(W_,172)*
      DYNX(W_,315));
  }
  SetVector(b, 1, DYNX(W_,171)*(DYNX(DYNhelp,355)+DYNX(DYNhelp,356))+
    DYNX(DYNhelp,357)+DYNX(DYNhelp,358)-DYNX(W_,179));
  SetVector(b, 2, DYNX(W_,172)*(DYNX(DYNhelp,359)+DYNX(DYNhelp,360))+
    DYNX(DYNhelp,361)+DYNX(DYNhelp,362)-DYNX(W_,180));
  SetVector(y, 1, RememberSimple_(DYNX(F_,0), 6));
  SetVector(y, 2, RememberSimple_(DYNX(F_,1), 7));
  SolveLinearSystemOfEquations(J, b, y, 2, "simulation.linear[2]");
  DYNX(F_,0) = GetVector(y, 1);
  DYNX(F_,1) = GetVector(y, 2);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(W_,311) = DYNX(W_,325)*DYNX(F_,1);
DYNX(W_,310) = DYNX(W_,322)*DYNX(F_,0);
DYNX(W_,307) = DYNX(DYNhelp,361)+DYNX(W_,314)*DYNX(W_,310)+DYNX(DYNhelp,362)+
  DYNX(W_,315)*DYNX(W_,311);
DYNX(W_,174) = DYNX(W_,180)-DYNX(W_,307);
DYNX(W_,178) = DYNX(DYNhelp,359)+DYNX(W_,314)*DYNX(F_,0)+DYNX(DYNhelp,360)+
  DYNX(W_,315)*DYNX(F_,1);
DYNX(W_,306) = DYNX(DYNhelp,357)+DYNX(W_,312)*DYNX(W_,310)+DYNX(DYNhelp,358)+
  DYNX(W_,313)*DYNX(W_,311);
DYNX(W_,173) = DYNX(W_,179)-DYNX(W_,306);
DYNX(W_,177) = DYNX(DYNhelp,355)+DYNX(W_,312)*DYNX(F_,0)+DYNX(DYNhelp,356)+
  DYNX(W_,313)*DYNX(F_,1);
 /* End of Equation Block */ 

DYNX(W_,858) = DYNX(DP_,166)*DYNX(W_,626)+DYNX(DP_,167)*DYNX(W_,640);
DYNX(W_,857) = DYNX(W_,859)*DYNX(W_,858);
DYNX(W_,854) = DYNX(DP_,163)*DYNX(W_,628)+DYNX(DP_,164)*DYNX(X_,5)+DYNX(DP_,165)
  *DYNX(W_,857);
DYNX(F_,16) = DYNX(W_,849)*DYNX(W_,854);
if (NewParameters_) {
DYNX(DYNhelp,387) = divinvGuarded(DYNX(W_,599),"controller.coreElement.currentControllers.qCurrentController.T");
}
DYNX(F_,4) = DYNX(DYNhelp,387)*DYNX(W_,593);
DYNX(W_,649) = sqrtGuarded(sqr(DYNX(W_,675))+sqr(DYNX(W_,676)),"controller.coreElement.actuatingVoltages_dq[1]^2+controller.coreElement.actuatingVoltages_dq[2]^2");
if (NewParameters_) {
DYNX(DYNhelp,388) = divinvGuarded(DYNX(W_,647),"controller.coreElement.fieldWeakeningController.firstOrder.T");
}
DYNX(F_,5) = DYNX(DYNhelp,388)*(DYNX(DP_,90)*DYNX(W_,649)-DYNX(X_,5));
DYNX(W_,871) = DYNX(DP_,173)*DYNX(W_,659)+DYNX(DP_,174)*DYNX(W_,714);
DYNX(W_,870) = DYNX(W_,872)*DYNX(W_,871);
DYNX(W_,867) = DYNX(DP_,170)*DYNX(W_,496)+DYNX(DP_,171)*DYNX(X_,15)+
  DYNX(DP_,172)*DYNX(W_,870);
DYNX(F_,17) = DYNX(W_,862)*DYNX(W_,867);
if (NewParameters_) {
DYNX(DYNhelp,389) = divinvGuarded(DYNX(W_,595),"controller.coreElement.currentControllers.dCurrentController.T");
}
DYNX(F_,3) = DYNX(DYNhelp,389)*DYNX(W_,592);
DYNX(DYNhelp,390) = fabs(DYNX(X_,15));
DYNX(W_,76) = IF DYNX(DYNhelp,390) > DYNX(W_,83) THEN DYNX(W_,81)*(IF 
  DYNX(X_,15) > 0 THEN 1 ELSE IF DYNX(X_,15) < 0 THEN -1 ELSE 0)*powGuarded(
  divGuarded(DYNX(DYNhelp,390),"abs(inertia.w)",DYNX(W_,79),"machine.coreElement.friction.frictionParameters.wRef"),
  "abs(inertia.w)/machine.coreElement.friction.frictionParameters.wRef",
  DYNX(W_,80),"machine.coreElement.friction.frictionParameters.power_w") ELSE 
  divGuarded(DYNX(W_,84)*DYNX(X_,15),"machine.coreElement.friction.frictionParameters.tauLinear*inertia.w",
  DYNX(W_,83),"machine.coreElement.friction.frictionParameters.wLinear");
DYNX(W_,304) = DYNX(W_,312)*DYNX(W_,308)+DYNX(W_,313)*DYNX(W_,309);
DYNX(W_,305) = DYNX(W_,314)*DYNX(W_,308)+DYNX(W_,315)*DYNX(W_,309);
DYNX(W_,63) = 1.5*DYNX(W_,300)*(DYNX(W_,176)*DYNX(W_,304)-DYNX(W_,175)*
  DYNX(W_,305));
DYNX(W_,359) = sqrtGuarded(0.3333333333333333*(sqr(DYNX(W_,35))+sqr(DYNX(W_,37))
  +sqr(DYNX(W_,39))),"0.3333333333333333*(machine.plug_p.pin[1].i^2+machine.plug_p.pin[2].i^2+machine.plug_p.pin[3].i^2)");
DYNX(DYNhelp,391) = 1-DYNX(W_,351);
if (NewParameters_) {
DYNX(DYNhelp,392) = divinvGuarded(DYNX(W_,352),"machine.coreElement.permanentMagnet.permanentMagnetLossParameters.IRef");
}
DYNX(DYNhelp,393) = powGuarded(DYNX(DYNhelp,392)*DYNX(W_,359),"machine.coreElement.permanentMagnet.iRMS/machine.coreElement.permanentMagnet.permanentMagnetLossParameters.IRef",
  DYNX(W_,353),"machine.coreElement.permanentMagnet.permanentMagnetLossParameters.power_I");
if (NewParameters_) {
DYNX(DYNhelp,394) = divinvGuarded(DYNX(W_,354),"machine.coreElement.permanentMagnet.permanentMagnetLossParameters.wRef");
}
DYNX(W_,347) = DYNX(W_,356)*(DYNX(W_,351)+DYNX(DYNhelp,391)*DYNX(DYNhelp,393))*(
  IF DYNX(X_,15) > 0 THEN 1 ELSE IF DYNX(X_,15) < 0 THEN -1 ELSE 0)*powGuarded(
  DYNX(DYNhelp,394)*DYNX(DYNhelp,390),"abs(inertia.w)/machine.coreElement.permanentMagnet.permanentMagnetLossParameters.wRef",
  DYNX(W_,355),"machine.coreElement.permanentMagnet.permanentMagnetLossParameters.power_w");
DYNX(W_,243) = DYNX(W_,359);
if (NewParameters_) {
DYNX(DYNhelp,395) = divinvGuarded(DYNX(W_,237),"machine.coreElement.strayLoad.strayLoadParameters.IRef");
}
DYNX(DYNhelp,396) = DYNX(DYNhelp,395)*DYNX(W_,243);
if (NewParameters_) {
DYNX(DYNhelp,397) = divinvGuarded(DYNX(W_,238),"machine.coreElement.strayLoad.strayLoadParameters.wRef");
}
DYNX(W_,234) = DYNX(W_,240)*sqr(DYNX(DYNhelp,396))*(IF DYNX(X_,15) > 0 THEN 1
   ELSE IF DYNX(X_,15) < 0 THEN -1 ELSE 0)*powGuarded(DYNX(DYNhelp,397)*
  DYNX(DYNhelp,390),"abs(inertia.w)/machine.coreElement.strayLoad.strayLoadParameters.wRef",
  DYNX(W_,239),"machine.coreElement.strayLoad.strayLoadParameters.power_w");
if (NewParameters_) {
DYNX(DYNhelp,398) = divinvGuarded(DYNX(W_,495),"load.w_nominal");
}
DYNX(W_,491) =  -DYNX(W_,493)*sqr(DYNX(DYNhelp,398)*DYNX(X_,15));

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[3] */
DYNX(F_,15) = RememberSimple_(DYNX(F_,15), 8);
SolveScalarLinearParametric(DYNX(W_,65)+DYNX(DP_,160),"machine.coreElement.inertiaRotor.J+inertia.J",
    -(DYNX(W_,76)+DYNX(W_,347)+DYNX(W_,234)+DYNX(W_,491)-DYNX(W_,63)),
  " -(machine.coreElement.friction.flange.tau+machine.coreElement.permanentMagnet.flange.tau+machine.coreElement.strayLoad.flange.tau+load.flange.tau-machine.coreElement.tauElectrical)",
   DYNX(F_,15),"der(inertia.w)");
DYNX(W_,64) = DYNX(W_,65)*DYNX(F_,15)-DYNX(W_,63);
DYNX(W_,40) =  -(DYNX(DP_,160)*DYNX(F_,15)+DYNX(W_,491));
 /* End of Equation Block */ 

{
  RealAssign(RealTemporaryDense(&(DYNX(DYNhelp,399)), 1, 2), (PushModelContext(1,
    "Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor({machine.plug_p.pin[1].v, machine.plug_p.pin[2].v, machine.plug_p.pin[3].v})")
    Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor(
    RealScalarArray ( 3, DYNX(W_,34), DYNX(W_,36), DYNX(W_,38))).y0_0_0member));
}
PopAllMarks();
RealAssign (RealTemporaryDense( &DYNX(W_,451), 1, 2), RealTemporaryDense(&(
  DYNX(DYNhelp,399)), 1, 2));
PopAllMarks();
{
  RealAssign(RealTemporaryDense(&(DYNX(DYNhelp,401)), 1, 2), (PushModelContext(1,
    "Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor({machine.plug_p.pin[1].i, machine.plug_p.pin[2].i, machine.plug_p.pin[3].i})")
    Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor(
    RealScalarArray ( 3, DYNX(W_,35), DYNX(W_,37), DYNX(W_,39))).y0_0_0member));
}
PopAllMarks();
RealAssign (RealTemporaryDense( &DYNX(W_,453), 1, 2), RealTemporaryDense(&(
  DYNX(DYNhelp,401)), 1, 2));
PopAllMarks();
DYNX(W_,449) = 1.5*(DYNX(W_,451)*DYNX(W_,453)+DYNX(W_,452)*DYNX(W_,454));
DYNX(F_,6) = DYNX(DP_,123)*DYNX(W_,449);
DYNX(W_,363) = DYNX(W_,63)+DYNX(W_,64);
DYNX(W_,362) = DYNX(W_,363)-DYNX(W_,40);
DYNX(W_,396) = DYNX(DP_,28)*DYNX(W_,362);
DYNX(W_,397) = DYNX(X_,15)*DYNX(W_,396);
DYNX(F_,7) = DYNX(DP_,125)*DYNX(W_,397);
DYNX(W_,749) = RealBmax(DYNX(W_,449), DYNX(DP_,153));
DYNX(F_,8) = DYNX(DP_,131)*DYNX(W_,749);
DYNX(W_,748) = RealBmin(DYNX(W_,449), DYNX(DP_,153));
DYNX(W_,754) = DYNX(DP_,146)*DYNX(W_,748);
DYNX(F_,9) = DYNX(DP_,133)*DYNX(W_,754);
DYNX(W_,751) = RealBmax(DYNX(W_,397), DYNX(DP_,154));
DYNX(F_,10) = DYNX(DP_,135)*DYNX(W_,751);
DYNX(W_,750) = RealBmin(DYNX(DP_,154), DYNX(W_,397));
DYNX(W_,752) = DYNX(DP_,147)*DYNX(W_,750);
DYNX(F_,11) = DYNX(DP_,137)*DYNX(W_,752);
DYNX(W_,753) = DYNX(DP_,119)*DYNX(W_,749)+DYNX(DP_,120)*DYNX(W_,752);
DYNX(W_,755) = DYNX(DP_,121)*DYNX(W_,754)+DYNX(DP_,122)*DYNX(W_,751);
DYNX(W_,769) = DYNX(DP_,129)*DYNX(W_,753)+DYNX(DP_,130)*DYNX(W_,755);
DYNX(F_,12) = DYNX(DP_,139)*DYNX(W_,769);
DYNX(W_,801) = RealBmin(DYNX(W_,397), DYNX(W_,449));
DYNX(W_,821) = RealBmin(DYNX(W_,801), DYNX(DP_,152));
DYNX(W_,795) = DYNX(DP_,145)*DYNX(W_,821);
DYNX(F_,13) = DYNX(DP_,141)*DYNX(W_,795);
DYNX(W_,822) = DYNX(DP_,148)*DYNX(W_,821)+DYNX(DP_,149)*DYNX(W_,801);
DYNX(W_,800) = RealBmax(DYNX(W_,397), DYNX(W_,449));
DYNX(W_,796) = DYNX(DP_,150)*DYNX(W_,822)+DYNX(DP_,151)*DYNX(W_,800);
DYNX(F_,14) = DYNX(DP_,143)*DYNX(W_,796);
AssertModelica(GreaterEqual(DYNX(DP_,92),"controller.coreElement.fieldWeakeningController.delta_i_d_max.k",
   DYNX(W_,655),"controller.coreElement.fieldWeakeningController.aboveZeroProtection.y",
   7),"controller.coreElement.fieldWeakeningController.delta_i_d_max.k >= controller.coreElement.fieldWeakeningController.aboveZeroProtection.y",
   "Input signals are not consistent: limit1 < limit2");
AssertModelica(GreaterEqual(DYNX(DP_,92),"controller.coreElement.fieldWeakeningController.delta_i_d_max.k",
   DYNX(W_,655),"controller.coreElement.fieldWeakeningController.aboveZeroProtection.y",
   7),"controller.coreElement.fieldWeakeningController.delta_i_d_max.k >= controller.coreElement.fieldWeakeningController.aboveZeroProtection.y",
   StringAdd(StringAdd(StringAdd(StringAdd("\n### Error in class LimitedPI: Limits must be consistent. However, yMax (=",
  Real2String2(DYNX(DP_,92), true, 0)),") < limiter.limit2 (="),Real2String2(
  DYNX(W_,655), true, 0)),")###\n"));
PopAllMarks();

AcceptedSection1

AcceptedSection2
DYNX(W_,348) = DYNX(X_,2)-DYNX(DP_,27);
DYNX(W_,395) = DYNX(X_,2)-DYNX(DP_,29);
DYNX(W_,77) = DYNX(X_,2)-DYNX(DP_,27);
DYNX(W_,235) = DYNX(X_,2)-DYNX(DP_,27);
DYNX(W_,62) = DYNX(X_,2)-DYNX(DP_,27);
DYNX(W_,75) = DYNX(W_,347)-DYNX(W_,63)+DYNX(W_,76)+DYNX(W_,234);
DYNX(W_,112) = DYNX(W_,34)-DYNX(W_,123);
DYNX(W_,113) = DYNX(W_,36)-DYNX(W_,123);
DYNX(W_,114) = DYNX(W_,38)-DYNX(W_,123);
DYNX(W_,100) = (PushModelContext(1,"Modelica.Electrical.Machines.SpacePhasors.Functions.activePower({machine.coreElement.vs[1], machine.coreElement.vs[2], machine.coreElement.vs[3]}, {machine.plug_p.pin[1].i, machine.plug_p.pin[2].i, machine.plug_p.pin[3].i})")
  Modelica_Electrical_Machines_SpacePhasors_Functions_activePower(
  RealTemporaryDense( &DYNX(W_,112), 1, 3), RealScalarArray ( 3, DYNX(W_,35), 
  DYNX(W_,37), DYNX(W_,39))));
PopAllMarks();
DYNX(W_,101) =  -DYNX(X_,15)*DYNX(W_,40);
DYNX(W_,103) = DYNX(W_,65)*DYNX(F_,15)*DYNX(X_,15);
DYNX(W_,153) = DYNX(W_,150)*DYNX(W_,35);
DYNX(W_,161) = DYNX(W_,158)*DYNX(W_,37);
DYNX(W_,169) = DYNX(W_,166)*DYNX(W_,39);
DYNX(W_,105) = DYNX(W_,153)+DYNX(W_,161)+DYNX(W_,169);
DYNX(W_,106) = 1.5*(DYNX(W_,179)*DYNX(W_,200)+DYNX(W_,180)*DYNX(W_,201));
DYNX(W_,108) = DYNX(W_,234)*DYNX(X_,15);
DYNX(W_,109) = DYNX(W_,76)*DYNX(X_,15);
DYNX(W_,111) = DYNX(W_,347)*DYNX(X_,15);
DYNX(W_,104) = DYNX(W_,105)+DYNX(W_,106)+DYNX(W_,108)+DYNX(W_,109)+DYNX(W_,111);
DYNX(W_,117) = DYNX(W_,312)*DYNX(W_,345);
DYNX(W_,118) = DYNX(W_,314)*DYNX(W_,345);
DYNX(W_,125) = DYNX(W_,34)-DYNX(W_,130);
DYNX(W_,126) = DYNX(W_,36)-DYNX(W_,131);
DYNX(W_,127) = DYNX(W_,38)-DYNX(W_,132);
DYNX(W_,249) = DYNX(W_,153)+DYNX(W_,161)+DYNX(W_,169);
DYNX(W_,273) = DYNX(W_,249)+DYNX(W_,111)+DYNX(W_,106)+DYNX(W_,108)+DYNX(W_,109);
DYNX(W_,422) = DYNX(W_,34)-DYNX(W_,36);
DYNX(W_,423) = DYNX(W_,36)-DYNX(W_,38);
DYNX(W_,424) = DYNX(W_,38)-DYNX(W_,34);
DYNX(W_,456) = atan2(DYNX(W_,451), DYNX(W_,452));
DYNX(W_,455) = atan2(DYNX(W_,453), DYNX(W_,454));
DYNX(W_,448) = cos(DYNX(W_,456)-DYNX(W_,455));
DYNX(W_,450) = 1.5*(DYNX(W_,452)*DYNX(W_,453)-DYNX(W_,451)*DYNX(W_,454));
DYNX(W_,477) = DYNX(W_,35)+DYNX(W_,37)+DYNX(W_,39);
DYNX(W_,489) =  -DYNX(W_,40)*DYNX(X_,15);
DYNX(W_,629) = DYNX(W_,628)-DYNX(X_,5);
DYNX(W_,652) = IF DYNX(W_,649) <= 1E-60 THEN 0 ELSE atan2(DYNX(W_,676), 
  DYNX(W_,675));
DYNX(W_,703) = DYNX(W_,496)-DYNX(X_,15);
DYNX(DYNhelp,403) = fabs(DYNX(W_,796));
DYNX(W_,744) = IF DYNX(DYNhelp,403) < 1E-60 THEN (IF DYNX(W_,796) >= 0 THEN 
  1E+60*DYNX(W_,795) ELSE (-1E+60)*DYNX(W_,795)) ELSE divGuarded(DYNX(W_,795),
  "machineEfficiencyComputation.powerEfficiencyComp.u1",DYNX(W_,796),
  "machineEfficiencyComputation.powerEfficiencyComp.u2");
DYNX(W_,743) = IF DYNX(W_,744) > DYNX(DP_,127) THEN DYNX(DP_,127) ELSE IF 
  DYNX(W_,744) < DYNX(DP_,128) THEN DYNX(DP_,128) ELSE DYNX(W_,744);
DYNX(DYNhelp,404) = fabs(DYNX(X_,14));
DYNX(W_,745) = IF DYNX(DYNhelp,404) < 1E-60 THEN (IF DYNX(X_,14) >= 0 THEN 1E+60
  *DYNX(X_,13) ELSE (-1E+60)*DYNX(X_,13)) ELSE divGuarded(DYNX(X_,13),
  "machineEfficiencyComputation.generatedEnergyComp.y",DYNX(X_,14),
  "machineEfficiencyComputation.consumedEnergyComp.y");
DYNX(DYNhelp,405) = fabs(DYNX(X_,8));
DYNX(W_,746) = IF DYNX(DYNhelp,405) < 1E-60 THEN (IF DYNX(X_,8) >= 0 THEN 1E+60*
  DYNX(X_,11) ELSE (-1E+60)*DYNX(X_,11)) ELSE divGuarded(DYNX(X_,11),
  "machineEfficiencyComputation.generatedMechanicEnergyComp.y",DYNX(X_,8),
  "machineEfficiencyComputation.consumedElectricEnergyComp.y");
DYNX(DYNhelp,406) = fabs(DYNX(X_,10));
DYNX(W_,747) = IF DYNX(DYNhelp,406) < 1E-60 THEN (IF DYNX(X_,10) >= 0 THEN 1E+60
  *DYNX(X_,9) ELSE (-1E+60)*DYNX(X_,9)) ELSE divGuarded(DYNX(X_,9),
  "machineEfficiencyComputation.generatedElectricEnergyComp.y",DYNX(X_,10),
  "machineEfficiencyComputation.consumedMechanicEnergyComp.y");
DYNX(W_,835) = 0.6666666666666666*DYNX(W_,35)-0.3333333333333333*DYNX(W_,37)-
  0.3333333333333333*DYNX(W_,39);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(6);
DYNX(W_,836) = 0.5773502691896258*(DYNX(W_,37)-DYNX(W_,39));
DYNX(W_,826) = sqrtGuarded(DYNX(W_,835)*DYNX(W_,835)+DYNX(W_,836)*DYNX(W_,836),
  "signals.clarkeTransform.alpha*signals.clarkeTransform.alpha+signals.clarkeTransform.beta*signals.clarkeTransform.beta");
DYNX(W_,827) = DYNX(DP_,155)*DYNX(W_,826);
DYNX(W_,828) = DYNX(DP_,158)*DYNX(W_,826);
DYNX(W_,829) = sqrtGuarded(DYNX(W_,675)*DYNX(W_,675)+DYNX(W_,676)*DYNX(W_,676),
  "controller.coreElement.actuatingVoltages_dq[1]*controller.coreElement.actuatingVoltages_dq[1]+controller.coreElement.actuatingVoltages_dq[2]*controller.coreElement.actuatingVoltages_dq[2]");
DYNX(W_,830) = DYNX(DP_,157)*DYNX(W_,829);
DYNX(W_,838) = 0.6666666666666666*DYNX(W_,422)-0.3333333333333333*DYNX(W_,423)-
  0.3333333333333333*DYNX(W_,424);
DYNX(W_,839) = 0.5773502691896258*(DYNX(W_,423)-DYNX(W_,424));
DYNX(W_,831) = sqrtGuarded(DYNX(W_,838)*DYNX(W_,838)+DYNX(W_,839)*DYNX(W_,839),
  "signals.clarkeTransform1.alpha*signals.clarkeTransform1.alpha+signals.clarkeTransform1.beta*signals.clarkeTransform1.beta");
DYNX(W_,832) = DYNX(DP_,156)*DYNX(W_,831);
DYNX(W_,833) = 0.5773502691896258*DYNX(W_,831);
DYNX(W_,834) = DYNX(DP_,159)*DYNX(W_,833);
DYNX(W_,837) = atan2(DYNX(W_,836), DYNX(W_,835));
DYNX(W_,840) = atan2(DYNX(W_,839), DYNX(W_,838));
DYNX(W_,842) = atan2(DYNX(W_,676), DYNX(W_,675));

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("machine.data.m", "Number of phases [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,517)
DeclareParameter("machine.data.useThermalPort", "True: thermal connector is provided, false: temperature is fixed internally [:#(type=Boolean)]",\
 0, false, 0.0,0.0,0.0,0,562)
DeclareParameter("machine.data.useSupport", "True: stator is able to rotate, false: stator is fixed internally [:#(type=Boolean)]",\
 1, false, 0.0,0.0,0.0,0,562)
DeclareVariable("machine.data.terminalConnection", "Choose if the machine is Y=star or /D=delta wired [:#(type=DymolaModels.Electrical.MultiPhase.Choices.Wiring)]",\
 1, 1.0,2.0,0.0,0,517)
DeclareParameter("machine.data.p", "Number of pole pairs (Integer) [:#(type=Integer)]",\
 2, 4, 1.0,1E+100,0.0,0,564)
DeclareParameter("machine.data.fs_nom", "Nominal electric frequency [Hz]", 3, 320,\
 0.0,0.0,0.0,0,560)
DeclareParameter("machine.data.Jr", "Rotor's moment of inertia [kg.m2]", 4, \
0.065, 0.0,0.0,0.0,0,560)
DeclareVariable("machine.data.Js", "Stator's moment of inertia [kg.m2]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareParameter("machine.data.Ts_operational", "Operational temperature of stator resistance [K|degC]",\
 5, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("machine.data.Rs", "Stator resistance per phase at TRef [Ohm]",\
 6, 0.0175, 0.0,0.0,0.0,0,560)
DeclareParameter("machine.data.alpha20s", "Temperature coefficient of stator resistance at 20 degC [1/K]",\
 7, 0.00392, 0.0,0.0,0.0,0,560)
DeclareParameter("machine.data.Ts_ref", "Reference temperature of stator resistance [K|degC]",\
 8, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("machine.data.Ls_zero", "Stator zero sequence inductance [H]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("machine.data.Ls_sigma", "Stator stray inductance per phase [H]",\
 9, 2E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("machine.data.u_s_openCircuit", "Open circuit RMS voltage per phase @ fs_nom [V]",\
 10, 105, 0.0,0.0,0.0,0,560)
DeclareVariable("machine.data.Lmd", "Main field inductance in d-axis [H]", 0.001,\
 0.0,0.0,0.0,0,513)
DeclareVariable("machine.data.Lmq", "Main field inductance in q-axis [H]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("machine.data.Ld", "Overall inductance in d-axis [H]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("machine.data.Lq", "Overall inductance in q-axis [H]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("machine.data.useDamperCage", "Enable / disable damper cage [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("machine.data.Lr_sigma_d", "Damper stray inductance in d-axis [H]",\
 11, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("machine.data.Lr_sigma_q", "Damper stray inductance in q-axis [H]",\
 12, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("machine.data.Tr_operational", "Operational temperature of (optional) damper cage [K|degC]",\
 13, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("machine.data.Rr_d", "Damper resistance in d-axis at TRef [Ohm]",\
 14, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("machine.data.Rr_q", "Damper resistance in q-axis at TRef [Ohm]",\
 15, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("machine.data.alpha20r", "Temperature coefficient of damper resistances in d- and q-axis [1/K]",\
 16, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("machine.data.Tr_ref", "Reference temperature of damper resistances in d- and q-axis [K|degC]",\
 17, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("machine.data.frictionParameters.PRef", "Reference friction losses at wRef [W]",\
 280.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("machine.data.frictionParameters.wRef", "Reference angular velocity that the PRef refer to [rad/s|rev/min]",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareParameter("machine.data.frictionParameters.power_w", "Exponent of friction torque w.r.t. angular velocity",\
 18, 2.0, 1E-60,1E+100,0.0,0,560)
DeclareVariable("machine.data.frictionParameters.tauRef", "Reference friction torque at reference angular velocity [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.data.frictionParameters.linear", "Linear angular velocity range with respect to reference angular velocity",\
 0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.data.frictionParameters.wLinear", "Linear angular velocity range [rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.data.frictionParameters.tauLinear", "Torque corresponding with linear angular velocity range [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("machine.data.statorCoreParameters.m", "Number of phases (1 for DC, 3 for induction machines) [:#(type=Integer)]",\
 19, 3, 0.0,0.0,0.0,0,564)
DeclareVariable("machine.data.statorCoreParameters.PRef", "Reference core losses at reference inner voltage VRef [W]",\
 1800.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("machine.data.statorCoreParameters.VRef", "Reference inner RMS voltage that reference core losses PRef refer to [V]",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("machine.data.statorCoreParameters.wRef", "Reference angular velocity that reference core losses PRef refer to [rad/s]",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("machine.data.statorCoreParameters.ratioHysteresis", \
"Ratio of hysteresis losses with respect to the total core losses at VRef and fRef",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("machine.data.statorCoreParameters.GcRef", "Reference conductance at reference frequency and voltage [S]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.data.statorCoreParameters.wMin", "[rad/s]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("machine.data.strayLoadParameters.PRef", "Reference stray load losses at IRef and wRef [W]",\
 850.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("machine.data.strayLoadParameters.IRef", "Reference RMS current that PRef refers to [A]",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("machine.data.strayLoadParameters.wRef", "Reference angular velocity that PRef refers to [rad/s|rev/min]",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareParameter("machine.data.strayLoadParameters.power_w", "Exponent of stray load loss torque w.r.t. angular velocity",\
 20, 1.0, 1E-60,1E+100,0.0,0,560)
DeclareVariable("machine.data.strayLoadParameters.tauRef", "Reference stray load torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.data.permanentMagnetParameters.PRef", "Reference permanent magnet losses at IRef and wRef [W]",\
 120.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("machine.data.permanentMagnetParameters.c", "Part of permanent magnet losses at current = 0, i.e. independent of current",\
 21, 0.0, 0.0,1.0,0.0,0,560)
DeclareVariable("machine.data.permanentMagnetParameters.IRef", "Reference stator RMS current that PRef refers to [A]",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareParameter("machine.data.permanentMagnetParameters.power_I", \
"Exponent of permanent magnet loss torque w.r.t. stator current", 22, 2.0, 1E-60,\
1E+100,0.0,0,560)
DeclareVariable("machine.data.permanentMagnetParameters.wRef", "Reference angular velocity that PRef refers to [rad/s|rev/min]",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareParameter("machine.data.permanentMagnetParameters.power_w", \
"Exponent of permanent magnet loss torque w.r.t. angular velocity", 23, 1.0, \
1E-60,1E+100,0.0,0,560)
DeclareVariable("machine.data.permanentMagnetParameters.tauRef", \
"Reference permanent magnet loss torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("machine.data.tau_nom", "Nominal torque [N.m]", 24, 150, \
0.0,0.0,0.0,0,560)
DeclareParameter("machine.data.u_s_nom", "Nominal phase voltage (rms) [V]", 25, 145,\
 0.0,0.0,0.0,0,560)
DeclareParameter("machine.data.i_s_nom", "Nominal current per phase (rms) [A]", 26,\
 217, 0.0,0.0,0.0,0,560)
DeclareVariable("machine.data.w_nom", "Nominal mechanical speed [rad/s]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("machine.data.P_nom", "Nominal mechanical power [W]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("machine.useSupport", "true: stator is able to rotate, false: stator is fixed internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("machine.useThermalPort", "true: thermal connector is provided, false: temperature is fixed internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("machine.plug_p.m", "Number of phases [:#(type=Integer)]", 3, \
1.0,1E+100,0.0,0,525)
DeclareVariable("machine.plug_p.pin[1].v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareVariable("machine.plug_p.pin[1].i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("machine.plug_p.pin[2].v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareVariable("machine.plug_p.pin[2].i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("machine.plug_p.pin[3].v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareVariable("machine.plug_p.pin[3].i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("machine.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "multiSensor.flange_a.phi", 1, 1, 2, 4)
DeclareVariable("machine.flange.tau", "Cut torque in the flange [N.m]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("machine.useDamperCage", "True: damper cage is enabled, false: disabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("machine.coreElement.m", "Number of phases [:#(type=Integer)]", 3,\
 0.0,0.0,0.0,0,517)
DeclareVariable("machine.coreElement.p", "Number of pole pairs (Integer) [:#(type=Integer)]",\
 2, 1.0,1E+100,0.0,0,517)
DeclareVariable("machine.coreElement.fsNominal", "Nominal frequency [Hz]", 50, \
0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.TsOperational", "Operational temperature of stator resistance [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.Rs", "Stator resistance per phase at TRef [Ohm]",\
 0.03, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.TsRef", "Reference temperature of stator resistance [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.alpha20s", "Temperature coefficient of stator resistance at 20 degC [1/K|1/K]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.Lszero", "Stator zero sequence inductance [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.Lssigma", "Stator stray inductance per phase [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.Jr", "Rotor's moment of inertia [kg.m2]", \
0.29, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.useSupport", "Enable / disable (=fixed stator) support [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("machine.coreElement.Js", "Stator's moment of inertia [kg.m2]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.useThermalPort", "Enable / disable (=fixed temperatures) thermal port [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("machine.coreElement.frictionParameters.PRef", "Reference friction losses at wRef [W]",\
 280.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.frictionParameters.wRef", "Reference angular velocity that the PRef refer to [rad/s|rev/min]",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.frictionParameters.power_w", \
"Exponent of friction torque w.r.t. angular velocity", 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.frictionParameters.tauRef", \
"Reference friction torque at reference angular velocity [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("machine.coreElement.frictionParameters.linear", \
"Linear angular velocity range with respect to reference angular velocity", \
0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.frictionParameters.wLinear", \
"Linear angular velocity range [rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.frictionParameters.tauLinear", \
"Torque corresponding with linear angular velocity range [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("machine.coreElement.phiMechanical", "Mechanical angle of rotor against stator [rad|deg]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.der(phiMechanical)", "der(Mechanical angle of rotor against stator) [rad/s]",\
 "inertia.w", 1, 1, 15, 0)
DeclareAlias2("machine.coreElement.wMechanical", "Mechanical angular velocity of rotor against stator [rad/s|rev/min]",\
 "inertia.w", 1, 1, 15, 0)
DeclareVariable("machine.coreElement.tauElectrical", "Electromagnetic torque [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.tauShaft", "Shaft torque [N.m]", \
"machine.flange.tau", -1, 5, 40, 0)
DeclareAlias2("machine.coreElement.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "multiSensor.flange_a.phi", 1, 1, 2, 4)
DeclareAlias2("machine.coreElement.flange.tau", "Cut torque in the flange [N.m]",\
 "machine.flange.tau", 1, 5, 40, 132)
DeclareAlias2("machine.coreElement.inertiaRotor.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "multiSensor.flange_a.phi", 1, 1, 2, 4)
DeclareAlias2("machine.coreElement.inertiaRotor.flange_a.tau", "Cut torque in the flange [N.m]",\
 "machine.coreElement.tauElectrical", 1, 5, 63, 132)
DeclareAlias2("machine.coreElement.inertiaRotor.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "multiSensor.flange_a.phi", 1, 1, 2, 4)
DeclareVariable("machine.coreElement.inertiaRotor.flange_b.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("machine.coreElement.inertiaRotor.J", "Moment of inertia [kg.m2]",\
 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.inertiaRotor.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("machine.coreElement.inertiaRotor.phi", "Absolute rotation angle of component [rad|deg]",\
 "multiSensor.flange_a.phi", 1, 1, 2, 0)
DeclareAlias2("machine.coreElement.inertiaRotor.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "inertia.w", 1, 1, 15, 0)
DeclareAlias2("machine.coreElement.inertiaRotor.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 "inertia.w", 1, 1, 15, 0)
DeclareAlias2("machine.coreElement.inertiaRotor.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 "inertia.der(w)", 1, 6, 15, 0)
DeclareAlias2("machine.coreElement.inertiaRotor.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "inertia.der(w)", 1, 6, 15, 0)
DeclareAlias2("machine.coreElement.inertiaStator.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "machine.coreElement.fixed.phi0", 1, 7, 27, 4)
DeclareVariable("machine.coreElement.inertiaStator.flange_a.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.coreElement.inertiaStator.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "machine.coreElement.fixed.phi0", 1, 7, 27, 4)
DeclareVariable("machine.coreElement.inertiaStator.flange_b.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.coreElement.inertiaStator.J", "Moment of inertia [kg.m2]",\
 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.inertiaStator.stateSelect", \
"Priority to use phi and w as states [:#(type=StateSelect)]", 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("machine.coreElement.inertiaStator.phi", "Absolute rotation angle of component [rad|deg]",\
 "machine.coreElement.fixed.phi0", 1, 7, 27, 0)
DeclareVariable("machine.coreElement.inertiaStator.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.inertiaStator.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.inertiaStator.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.inertiaStator.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("machine.coreElement.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 27, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("machine.coreElement.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "machine.coreElement.fixed.phi0", 1, 7, 27, 4)
DeclareVariable("machine.coreElement.fixed.flange.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("machine.coreElement.friction.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "multiSensor.flange_a.phi", 1, 1, 2, 4)
DeclareVariable("machine.coreElement.friction.flange.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("machine.coreElement.friction.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 "machine.coreElement.fixed.phi0", 1, 7, 27, 4)
DeclareAlias2("machine.coreElement.friction.support.tau", "Cut torque in the flange [N.m]",\
 "machine.coreElement.friction.flange.tau", -1, 5, 76, 132)
DeclareVariable("machine.coreElement.friction.phi", "Angle between shaft and support [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.friction.der(phi)", "der(Angle between shaft and support) [rad/s]",\
 "inertia.w", 1, 1, 15, 0)
DeclareAlias2("machine.coreElement.friction.tau", "Torque [N.m]", \
"machine.coreElement.friction.flange.tau", -1, 5, 76, 0)
DeclareAlias2("machine.coreElement.friction.w", "Relative angular velocity of flange and support [rad/s]",\
 "inertia.w", 1, 1, 15, 0)
DeclareVariable("machine.coreElement.friction.frictionParameters.PRef", \
"Reference friction losses at wRef [W]", 280.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.friction.frictionParameters.wRef", \
"Reference angular velocity that the PRef refer to [rad/s|rev/min]", 1E-60, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.friction.frictionParameters.power_w", \
"Exponent of friction torque w.r.t. angular velocity", 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.friction.frictionParameters.tauRef", \
"Reference friction torque at reference angular velocity [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("machine.coreElement.friction.frictionParameters.linear", \
"Linear angular velocity range with respect to reference angular velocity", \
0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.friction.frictionParameters.wLinear", \
"Linear angular velocity range [rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.friction.frictionParameters.tauLinear", \
"Torque corresponding with linear angular velocity range [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("machine.coreElement.friction.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("machine.coreElement.friction.heatPort.T", "Port temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.coreElement.friction.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "machine.coreElement.powerBalance.lossPowerFriction", -1, 5, 109, 132)
DeclareAlias2("machine.coreElement.friction.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 "machine.coreElement.powerBalance.lossPowerFriction", 1, 5, 109, 0)
DeclareAlias2("machine.coreElement.internalSupport.phi", "Absolute rotation angle of flange [rad|deg]",\
 "machine.coreElement.fixed.phi0", 1, 7, 27, 1028)
DeclareVariable("machine.coreElement.internalSupport.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,2825)
DeclareVariable("machine.coreElement.statorCoreParameters.m", "Number of phases (1 for DC, 3 for induction machines) [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,517)
DeclareVariable("machine.coreElement.statorCoreParameters.PRef", \
"Reference core losses at reference inner voltage VRef [W]", 1800.0, 0.0,1E+100,\
0.0,0,513)
DeclareVariable("machine.coreElement.statorCoreParameters.VRef", \
"Reference inner RMS voltage that reference core losses PRef refer to [V]", 100,\
 1E-60,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.statorCoreParameters.wRef", \
"Reference angular velocity that reference core losses PRef refer to [rad/s]", \
1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.statorCoreParameters.ratioHysteresis", \
"Ratio of hysteresis losses with respect to the total core losses at VRef and fRef",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("machine.coreElement.statorCoreParameters.GcRef", \
"Reference conductance at reference frequency and voltage [S]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("machine.coreElement.statorCoreParameters.wMin", "[rad/s]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.strayLoadParameters.PRef", "Reference stray load losses at IRef and wRef [W]",\
 850.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.strayLoadParameters.IRef", "Reference RMS current that PRef refers to [A]",\
 100, 1E-60,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.strayLoadParameters.wRef", "Reference angular velocity that PRef refers to [rad/s|rev/min]",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.strayLoadParameters.power_w", \
"Exponent of stray load loss torque w.r.t. angular velocity", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.strayLoadParameters.tauRef", \
"Reference stray load torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.powerBalance.powerStator", "Electrical power (stator) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.powerBalance.powerMechanical", \
"Mechanical power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.powerBalance.powerInertiaStator", \
"Stator inertia power [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.powerBalance.powerInertiaRotor", \
"Rotor inertia power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.powerBalance.lossPowerTotal", \
"Total loss power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.powerBalance.lossPowerStatorWinding", \
"Stator copper losses [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.powerBalance.lossPowerStatorCore", \
"Stator core losses [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.powerBalance.lossPowerRotorCore", \
"Rotor core losses [W]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.powerBalance.lossPowerStrayLoad", \
"Stray load losses [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.powerBalance.lossPowerFriction", \
"Friction losses [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.powerBalance.lossPowerRotorWinding", \
"Rotor copper losses [W]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.powerBalance.lossPowerPermanentMagnet", \
"Permanent magnet losses [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.vs[1]", "Stator instantaneous voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.vs[2]", "Stator instantaneous voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.vs[3]", "Stator instantaneous voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.is[1]", "Stator instantaneous currents [A]", \
"machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("machine.coreElement.is[2]", "Stator instantaneous currents [A]", \
"machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("machine.coreElement.is[3]", "Stator instantaneous currents [A]", \
"machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareVariable("machine.coreElement.i_0_s", "Stator zero-sequence current [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.der(i_0_s)", "der(Stator zero-sequence current) [A/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("machine.coreElement.idq_ss[1]", "Stator space phasor current / stator fixed frame [A]",\
 "machine.coreElement.lssigma.i_[1]", 1, 5, 175, 0)
DeclareAlias2("machine.coreElement.idq_ss[2]", "Stator space phasor current / stator fixed frame [A]",\
 "machine.coreElement.lssigma.i_[2]", 1, 5, 176, 0)
DeclareState("machine.coreElement.idq_sr[1]", "Stator space phasor current / rotor fixed frame [A]",\
 0, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("machine.coreElement.der(idq_sr[1])", "der(Stator space phasor current / rotor fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("machine.coreElement.idq_sr[2]", "Stator space phasor current / rotor fixed frame [A]",\
 1, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("machine.coreElement.der(idq_sr[2])", "der(Stator space phasor current / rotor fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.idq_rs[1]", "Rotor space phasor current / stator fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.idq_rs[2]", "Rotor space phasor current / stator fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.idq_rr[1]", "Rotor space phasor current / rotor fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.idq_rr[2]", "Rotor space phasor current / rotor fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.plug_sp.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.coreElement.plug_sp.pin[1].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.coreElement.plug_sp.pin[1].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 132)
DeclareAlias2("machine.coreElement.plug_sp.pin[2].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.coreElement.plug_sp.pin[2].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 132)
DeclareAlias2("machine.coreElement.plug_sp.pin[3].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.coreElement.plug_sp.pin[3].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 132)
DeclareVariable("machine.coreElement.plug_sn.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("machine.coreElement.plug_sn.pin[1].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("machine.coreElement.plug_sn.pin[1].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", -1, 5, 35, 132)
DeclareAlias2("machine.coreElement.plug_sn.pin[2].v", "Potential at the pin [V]",\
 "machine.coreElement.plug_sn.pin[1].v", 1, 5, 123, 4)
DeclareAlias2("machine.coreElement.plug_sn.pin[2].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", -1, 5, 37, 132)
DeclareAlias2("machine.coreElement.plug_sn.pin[3].v", "Potential at the pin [V]",\
 "machine.coreElement.plug_sn.pin[1].v", 1, 5, 123, 4)
DeclareAlias2("machine.coreElement.plug_sn.pin[3].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", -1, 5, 39, 132)
DeclareVariable("machine.coreElement.rs.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("machine.coreElement.rs.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.rs.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.rs.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.rs.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("machine.coreElement.rs.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("machine.coreElement.rs.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareVariable("machine.coreElement.rs.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.coreElement.rs.plug_p.pin[1].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.coreElement.rs.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 132)
DeclareAlias2("machine.coreElement.rs.plug_p.pin[2].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.coreElement.rs.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 132)
DeclareAlias2("machine.coreElement.rs.plug_p.pin[3].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.coreElement.rs.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 132)
DeclareVariable("machine.coreElement.rs.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("machine.coreElement.rs.plug_n.pin[1].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("machine.coreElement.rs.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", -1, 5, 35, 132)
DeclareVariable("machine.coreElement.rs.plug_n.pin[2].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("machine.coreElement.rs.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", -1, 5, 37, 132)
DeclareVariable("machine.coreElement.rs.plug_n.pin[3].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("machine.coreElement.rs.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", -1, 5, 39, 132)
DeclareVariable("machine.coreElement.rs.R[1]", "Resistances R_ref at temperatures T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.rs.R[2]", "Resistances R_ref at temperatures T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.rs.R[3]", "Resistances R_ref at temperatures T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.rs.T_ref[1]", "Reference temperatures [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.rs.T_ref[2]", "Reference temperatures [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.rs.T_ref[3]", "Reference temperatures [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.rs.alpha[1]", "Temperature coefficients of resistances at reference temperatures [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.rs.alpha[2]", "Temperature coefficients of resistances at reference temperatures [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.rs.alpha[3]", "Temperature coefficients of resistances at reference temperatures [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.rs.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("machine.coreElement.rs.useHeatPort", "=true, if all heat ports are enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("machine.coreElement.rs.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.rs.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.rs.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("machine.coreElement.rs.heatPort[1].T", "Port temperature [K|degC]",\
 "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.coreElement.rs.heatPort[1].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "machine.coreElement.rs.resistor[1].LossPower", -1, 5, 153, 132)
DeclareAlias2("machine.coreElement.rs.heatPort[2].T", "Port temperature [K|degC]",\
 "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.coreElement.rs.heatPort[2].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "machine.coreElement.rs.resistor[2].LossPower", -1, 5, 161, 132)
DeclareAlias2("machine.coreElement.rs.heatPort[3].T", "Port temperature [K|degC]",\
 "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.coreElement.rs.heatPort[3].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "machine.coreElement.rs.resistor[3].LossPower", -1, 5, 169, 132)
DeclareVariable("machine.coreElement.rs.resistor[1].R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.rs.resistor[1].T_ref", "Reference temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.rs.resistor[1].alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.rs.resistor[1].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.rs.resistor[1].i", "Current flowing from pin p to pin n [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("machine.coreElement.rs.resistor[1].p.v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.coreElement.rs.resistor[1].p.i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 132)
DeclareAlias2("machine.coreElement.rs.resistor[1].n.v", "Potential at the pin [V]",\
 "machine.coreElement.rs.plug_n.pin[1].v", 1, 5, 130, 4)
DeclareAlias2("machine.coreElement.rs.resistor[1].n.i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", -1, 5, 35, 132)
DeclareVariable("machine.coreElement.rs.resistor[1].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("machine.coreElement.rs.resistor[1].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("machine.coreElement.rs.resistor[1].heatPort.T", "Port temperature [K|degC]",\
 "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.coreElement.rs.resistor[1].heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.rs.resistor[1].LossPower", -1, 5, 153, 132)
DeclareVariable("machine.coreElement.rs.resistor[1].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.rs.resistor[1].T_heatPort", "Temperature of heatPort [K|degC]",\
 "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 0)
DeclareVariable("machine.coreElement.rs.resistor[1].R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.rs.resistor[2].R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.rs.resistor[2].T_ref", "Reference temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.rs.resistor[2].alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.rs.resistor[2].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.rs.resistor[2].i", "Current flowing from pin p to pin n [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("machine.coreElement.rs.resistor[2].p.v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.coreElement.rs.resistor[2].p.i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 132)
DeclareAlias2("machine.coreElement.rs.resistor[2].n.v", "Potential at the pin [V]",\
 "machine.coreElement.rs.plug_n.pin[2].v", 1, 5, 131, 4)
DeclareAlias2("machine.coreElement.rs.resistor[2].n.i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", -1, 5, 37, 132)
DeclareVariable("machine.coreElement.rs.resistor[2].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("machine.coreElement.rs.resistor[2].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("machine.coreElement.rs.resistor[2].heatPort.T", "Port temperature [K|degC]",\
 "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.coreElement.rs.resistor[2].heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.rs.resistor[2].LossPower", -1, 5, 161, 132)
DeclareVariable("machine.coreElement.rs.resistor[2].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.rs.resistor[2].T_heatPort", "Temperature of heatPort [K|degC]",\
 "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 0)
DeclareVariable("machine.coreElement.rs.resistor[2].R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.rs.resistor[3].R", "Resistance at temperature T_ref [Ohm]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.rs.resistor[3].T_ref", "Reference temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.rs.resistor[3].alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.rs.resistor[3].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.rs.resistor[3].i", "Current flowing from pin p to pin n [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareAlias2("machine.coreElement.rs.resistor[3].p.v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.coreElement.rs.resistor[3].p.i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 132)
DeclareAlias2("machine.coreElement.rs.resistor[3].n.v", "Potential at the pin [V]",\
 "machine.coreElement.rs.plug_n.pin[3].v", 1, 5, 132, 4)
DeclareAlias2("machine.coreElement.rs.resistor[3].n.i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", -1, 5, 39, 132)
DeclareVariable("machine.coreElement.rs.resistor[3].useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("machine.coreElement.rs.resistor[3].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("machine.coreElement.rs.resistor[3].heatPort.T", "Port temperature [K|degC]",\
 "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.coreElement.rs.resistor[3].heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.rs.resistor[3].LossPower", -1, 5, 169, 132)
DeclareVariable("machine.coreElement.rs.resistor[3].LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.rs.resistor[3].T_heatPort", "Temperature of heatPort [K|degC]",\
 "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 0)
DeclareVariable("machine.coreElement.rs.resistor[3].R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.lssigma.L[1]", "Inductance of both axes [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.lssigma.L[2]", "Inductance of both axes [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.lssigma.v_[1]", "[V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.lssigma.v_[2]", "[V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.lssigma.i_[1]", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.lssigma.i_[2]", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.lssigma.der(i_[1])", "[A/s]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("machine.coreElement.lssigma.der(i_[2])", "[A/s]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("machine.coreElement.lssigma.spacePhasor_a.v_[1]", \
"1=real, 2=imaginary part [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("machine.coreElement.lssigma.spacePhasor_a.v_[2]", \
"1=real, 2=imaginary part [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("machine.coreElement.lssigma.spacePhasor_a.i_[1]", \
"1=real, 2=imaginary part [A]", "machine.coreElement.lssigma.i_[1]", 1, 5, 175, 132)
DeclareAlias2("machine.coreElement.lssigma.spacePhasor_a.i_[2]", \
"1=real, 2=imaginary part [A]", "machine.coreElement.lssigma.i_[2]", 1, 5, 176, 132)
DeclareAlias2("machine.coreElement.lssigma.spacePhasor_b.v_[1]", \
"1=real, 2=imaginary part [V]", "machine.coreElement.airGapR.der(psi_ms[1])", 1,\
 5, 306, 4)
DeclareAlias2("machine.coreElement.lssigma.spacePhasor_b.v_[2]", \
"1=real, 2=imaginary part [V]", "machine.coreElement.airGapR.der(psi_ms[2])", 1,\
 5, 307, 4)
DeclareAlias2("machine.coreElement.lssigma.spacePhasor_b.i_[1]", \
"1=real, 2=imaginary part [A]", "machine.coreElement.lssigma.i_[1]", -1, 5, 175,\
 132)
DeclareAlias2("machine.coreElement.lssigma.spacePhasor_b.i_[2]", \
"1=real, 2=imaginary part [A]", "machine.coreElement.lssigma.i_[2]", -1, 5, 176,\
 132)
DeclareVariable("machine.coreElement.lszero.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.lszero.i", "Current flowing from pin p to pin n [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.lszero.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.lszero.p.v", "Potential at the pin [V]", \
0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("machine.coreElement.lszero.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.coreElement.lszero.n.v", "Potential at the pin [V]", 0,\
 0.0,0.0,0.0,0,521)
DeclareVariable("machine.coreElement.lszero.n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.coreElement.lszero.L", "Inductance [H]", 1, 0.0,0.0,0.0,\
0,513)
DeclareVariable("machine.coreElement.statorCore.coreParameters.m", \
"Number of phases (1 for DC, 3 for induction machines) [:#(type=Integer)]", 0, \
0.0,0.0,0.0,0,517)
DeclareVariable("machine.coreElement.statorCore.coreParameters.PRef", \
"Reference core losses at reference inner voltage VRef [W]", 1800.0, 0.0,1E+100,\
0.0,0,513)
DeclareVariable("machine.coreElement.statorCore.coreParameters.VRef", \
"Reference inner RMS voltage that reference core losses PRef refer to [V]", \
1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.statorCore.coreParameters.wRef", \
"Reference angular velocity that reference core losses PRef refer to [rad/s]", \
1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.statorCore.coreParameters.ratioHysteresis",\
 "Ratio of hysteresis losses with respect to the total core losses at VRef and fRef",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("machine.coreElement.statorCore.coreParameters.GcRef", \
"Reference conductance at reference frequency and voltage [S]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("machine.coreElement.statorCore.coreParameters.wMin", "[rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.statorCore.m", "Number of phases [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,517)
DeclareVariable("machine.coreElement.statorCore.turnsRatio", "Effective number of stator turns / effective number of rotor turns (if used as rotor core)",\
 1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.statorCore.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("machine.coreElement.statorCore.heatPort.T", "Port temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.coreElement.statorCore.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "machine.coreElement.powerBalance.lossPowerStatorCore", -1, 5, 106, 132)
DeclareAlias2("machine.coreElement.statorCore.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 "machine.coreElement.powerBalance.lossPowerStatorCore", 1, 5, 106, 0)
DeclareAlias2("machine.coreElement.statorCore.spacePhasor.v_[1]", \
"1=real, 2=imaginary part [V]", "machine.coreElement.lssigma.spacePhasor_a.v_[1]", 1,\
 5, 179, 4)
DeclareAlias2("machine.coreElement.statorCore.spacePhasor.v_[2]", \
"1=real, 2=imaginary part [V]", "machine.coreElement.lssigma.spacePhasor_a.v_[2]", 1,\
 5, 180, 4)
DeclareVariable("machine.coreElement.statorCore.spacePhasor.i_[1]", \
"1=real, 2=imaginary part [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("machine.coreElement.statorCore.spacePhasor.i_[2]", \
"1=real, 2=imaginary part [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("machine.coreElement.statorCore.w", "Remagnetization angular velocity [rad/s]",\
 "machine.coreElement.statorCoreParameters.wRef", 1, 5, 91, 0)
DeclareAlias2("machine.coreElement.statorCore.Gc", "Variable core loss conductance [S]",\
 "machine.coreElement.statorCore.coreParameters.GcRef", 1, 5, 194, 0)
DeclareVariable("machine.coreElement.statorCore.wLimit", "Limited angular velocity [rad/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.spacePhasorS.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("machine.coreElement.spacePhasorS.turnsRatio", "Turns ratio", 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.spacePhasorS.v[1]", "Instantaneous phase voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.spacePhasorS.v[2]", "Instantaneous phase voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.spacePhasorS.v[3]", "Instantaneous phase voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.spacePhasorS.i[1]", "Instantaneous phase currents [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("machine.coreElement.spacePhasorS.i[2]", "Instantaneous phase currents [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("machine.coreElement.spacePhasorS.i[3]", "Instantaneous phase currents [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareVariable("machine.coreElement.spacePhasorS.TransformationMatrix[1, 1]", \
"", 0.6666666666666666, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.spacePhasorS.TransformationMatrix[1, 2]", \
"", -0.33333333333333315, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.spacePhasorS.TransformationMatrix[1, 3]", \
"", -0.3333333333333336, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.spacePhasorS.TransformationMatrix[2, 1]", \
"", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.spacePhasorS.TransformationMatrix[2, 2]", \
"", 0.5773502691896257, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.spacePhasorS.TransformationMatrix[2, 3]", \
"", -0.5773502691896256, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.spacePhasorS.InverseTransformation[1, 1]", \
"", 1.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.spacePhasorS.InverseTransformation[1, 2]", \
"", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.spacePhasorS.InverseTransformation[2, 1]", \
"", -0.4999999999999998, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.spacePhasorS.InverseTransformation[2, 2]", \
"", 0.8660254037844387, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.spacePhasorS.InverseTransformation[3, 1]", \
"", -0.5000000000000004, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.spacePhasorS.InverseTransformation[3, 2]", \
"", -0.8660254037844385, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.spacePhasorS.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.coreElement.spacePhasorS.plug_p.pin[1].v", \
"Potential at the pin [V]", "machine.coreElement.rs.plug_n.pin[1].v", 1, 5, 130,\
 4)
DeclareAlias2("machine.coreElement.spacePhasorS.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "machine.plug_p.pin[1].i", 1, 5, 35, 132)
DeclareAlias2("machine.coreElement.spacePhasorS.plug_p.pin[2].v", \
"Potential at the pin [V]", "machine.coreElement.rs.plug_n.pin[2].v", 1, 5, 131,\
 4)
DeclareAlias2("machine.coreElement.spacePhasorS.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "machine.plug_p.pin[2].i", 1, 5, 37, 132)
DeclareAlias2("machine.coreElement.spacePhasorS.plug_p.pin[3].v", \
"Potential at the pin [V]", "machine.coreElement.rs.plug_n.pin[3].v", 1, 5, 132,\
 4)
DeclareAlias2("machine.coreElement.spacePhasorS.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "machine.plug_p.pin[3].i", 1, 5, 39, 132)
DeclareVariable("machine.coreElement.spacePhasorS.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.coreElement.spacePhasorS.plug_n.pin[1].v", \
"Potential at the pin [V]", "machine.coreElement.plug_sn.pin[1].v", 1, 5, 123, 4)
DeclareAlias2("machine.coreElement.spacePhasorS.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "machine.plug_p.pin[1].i", -1, 5, 35, 132)
DeclareAlias2("machine.coreElement.spacePhasorS.plug_n.pin[2].v", \
"Potential at the pin [V]", "machine.coreElement.plug_sn.pin[1].v", 1, 5, 123, 4)
DeclareAlias2("machine.coreElement.spacePhasorS.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "machine.plug_p.pin[2].i", -1, 5, 37, 132)
DeclareAlias2("machine.coreElement.spacePhasorS.plug_n.pin[3].v", \
"Potential at the pin [V]", "machine.coreElement.plug_sn.pin[1].v", 1, 5, 123, 4)
DeclareAlias2("machine.coreElement.spacePhasorS.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "machine.plug_p.pin[3].i", -1, 5, 39, 132)
DeclareVariable("machine.coreElement.spacePhasorS.zero.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("machine.coreElement.spacePhasorS.zero.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.coreElement.spacePhasorS.ground.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("machine.coreElement.spacePhasorS.ground.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.coreElement.spacePhasorS.spacePhasor.v_[1]", \
"1=real, 2=imaginary part [V]", "machine.coreElement.lssigma.spacePhasor_a.v_[1]", 1,\
 5, 179, 4)
DeclareAlias2("machine.coreElement.spacePhasorS.spacePhasor.v_[2]", \
"1=real, 2=imaginary part [V]", "machine.coreElement.lssigma.spacePhasor_a.v_[2]", 1,\
 5, 180, 4)
DeclareVariable("machine.coreElement.spacePhasorS.spacePhasor.i_[1]", \
"1=real, 2=imaginary part [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("machine.coreElement.spacePhasorS.spacePhasor.i_[2]", \
"1=real, 2=imaginary part [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("machine.coreElement.strayLoad.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("machine.coreElement.strayLoad.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.strayLoad.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.strayLoad.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("machine.coreElement.strayLoad.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("machine.coreElement.strayLoad.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("machine.coreElement.strayLoad.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareVariable("machine.coreElement.strayLoad.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.coreElement.strayLoad.plug_p.pin[1].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.coreElement.strayLoad.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 132)
DeclareAlias2("machine.coreElement.strayLoad.plug_p.pin[2].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.coreElement.strayLoad.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 132)
DeclareAlias2("machine.coreElement.strayLoad.plug_p.pin[3].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.coreElement.strayLoad.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 132)
DeclareVariable("machine.coreElement.strayLoad.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.coreElement.strayLoad.plug_n.pin[1].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.coreElement.strayLoad.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", -1, 5, 35, 132)
DeclareAlias2("machine.coreElement.strayLoad.plug_n.pin[2].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.coreElement.strayLoad.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", -1, 5, 37, 132)
DeclareAlias2("machine.coreElement.strayLoad.plug_n.pin[3].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.coreElement.strayLoad.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", -1, 5, 39, 132)
DeclareAlias2("machine.coreElement.strayLoad.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "multiSensor.flange_a.phi", 1, 1, 2, 4)
DeclareVariable("machine.coreElement.strayLoad.flange.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("machine.coreElement.strayLoad.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 "machine.coreElement.fixed.phi0", 1, 7, 27, 4)
DeclareAlias2("machine.coreElement.strayLoad.support.tau", "Cut torque in the flange [N.m]",\
 "machine.coreElement.strayLoad.flange.tau", -1, 5, 234, 132)
DeclareVariable("machine.coreElement.strayLoad.phi", "Angle between shaft and support [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.strayLoad.der(phi)", "der(Angle between shaft and support) [rad/s]",\
 "inertia.w", 1, 1, 15, 0)
DeclareAlias2("machine.coreElement.strayLoad.tau", "Torque [N.m]", \
"machine.coreElement.strayLoad.flange.tau", -1, 5, 234, 0)
DeclareAlias2("machine.coreElement.strayLoad.w", "Relative angular velocity of flange and support [rad/s]",\
 "inertia.w", 1, 1, 15, 0)
DeclareVariable("machine.coreElement.strayLoad.strayLoadParameters.PRef", \
"Reference stray load losses at IRef and wRef [W]", 850.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.strayLoad.strayLoadParameters.IRef", \
"Reference RMS current that PRef refers to [A]", 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.strayLoad.strayLoadParameters.wRef", \
"Reference angular velocity that PRef refers to [rad/s|rev/min]", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.strayLoad.strayLoadParameters.power_w", \
"Exponent of stray load loss torque w.r.t. angular velocity", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.strayLoad.strayLoadParameters.tauRef", \
"Reference stray load torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.strayLoad.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("machine.coreElement.strayLoad.heatPort.T", "Port temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.coreElement.strayLoad.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "machine.coreElement.powerBalance.lossPowerStrayLoad", -1, 5, 108, 132)
DeclareAlias2("machine.coreElement.strayLoad.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 "machine.coreElement.powerBalance.lossPowerStrayLoad", 1, 5, 108, 0)
DeclareVariable("machine.coreElement.strayLoad.iRMS", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.thermalAmbient.useDamperCage", \
"Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,515)
DeclareVariable("machine.coreElement.thermalAmbient.m", "Number of stator phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("machine.coreElement.thermalAmbient.useTemperatureInputs", \
"If true, temperature inputs are used; else, temperatures are constant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("machine.coreElement.thermalAmbient.TDefault", "Default temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.thermalAmbient.Ts", "Temperature of stator windings [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.thermalAmbient.Q_flowStatorWinding", \
"Heat flow rate of stator windings [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.thermalAmbient.Q_flowStatorCore", \
"Heat flow rate of stator core losses [W]", "machine.coreElement.powerBalance.lossPowerStatorCore", 1,\
 5, 106, 0)
DeclareVariable("machine.coreElement.thermalAmbient.Q_flowRotorCore", \
"Heat flow rate of stator core losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("machine.coreElement.thermalAmbient.Q_flowStrayLoad", \
"Heat flow rate of stray load losses [W]", "machine.coreElement.powerBalance.lossPowerStrayLoad", 1,\
 5, 108, 0)
DeclareAlias2("machine.coreElement.thermalAmbient.Q_flowFriction", \
"Heat flow rate of friction losses [W]", "machine.coreElement.powerBalance.lossPowerFriction", 1,\
 5, 109, 0)
DeclareVariable("machine.coreElement.thermalAmbient.thermalPort.m", \
"Number of stator phases [:#(type=Integer)]", 3, 0.0,0.0,0.0,0,525)
DeclareAlias2("machine.coreElement.thermalAmbient.thermalPort.heatPortStatorWinding[1].T",\
 "Port temperature [K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1,\
 5, 268, 4)
DeclareAlias2("machine.coreElement.thermalAmbient.thermalPort.heatPortStatorWinding[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.rs.resistor[1].LossPower", 1, 5, 153, 132)
DeclareAlias2("machine.coreElement.thermalAmbient.thermalPort.heatPortStatorWinding[2].T",\
 "Port temperature [K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1,\
 5, 268, 4)
DeclareAlias2("machine.coreElement.thermalAmbient.thermalPort.heatPortStatorWinding[2].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.rs.resistor[2].LossPower", 1, 5, 161, 132)
DeclareAlias2("machine.coreElement.thermalAmbient.thermalPort.heatPortStatorWinding[3].T",\
 "Port temperature [K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1,\
 5, 268, 4)
DeclareAlias2("machine.coreElement.thermalAmbient.thermalPort.heatPortStatorWinding[3].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.rs.resistor[3].LossPower", 1, 5, 169, 132)
DeclareVariable("machine.coreElement.thermalAmbient.thermalPort.heatPortStatorCore.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.coreElement.thermalAmbient.thermalPort.heatPortStatorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.powerBalance.lossPowerStatorCore", 1, 5, 106, 132)
DeclareVariable("machine.coreElement.thermalAmbient.thermalPort.heatPortRotorCore.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.coreElement.thermalAmbient.thermalPort.heatPortRotorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("machine.coreElement.thermalAmbient.thermalPort.heatPortStrayLoad.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.coreElement.thermalAmbient.thermalPort.heatPortStrayLoad.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.powerBalance.lossPowerStrayLoad", 1, 5, 108, 132)
DeclareVariable("machine.coreElement.thermalAmbient.thermalPort.heatPortFriction.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.coreElement.thermalAmbient.thermalPort.heatPortFriction.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.powerBalance.lossPowerFriction", 1, 5, 109, 132)
DeclareVariable("machine.coreElement.thermalAmbient.thermalPort.useDamperCage", \
"Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareVariable("machine.coreElement.thermalAmbient.thermalPort.heatPortPermanentMagnet.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.coreElement.thermalAmbient.thermalPort.heatPortPermanentMagnet.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.powerBalance.lossPowerPermanentMagnet", 1, 5, 111, 132)
DeclareAlias2("machine.coreElement.thermalAmbient.temperatureStatorWinding.port.T",\
 "Port temperature [K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1,\
 5, 268, 4)
DeclareAlias2("machine.coreElement.thermalAmbient.temperatureStatorWinding.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.thermalAmbient.Q_flowStatorWinding", 1, 5, 249, 132)
DeclareAlias2("machine.coreElement.thermalAmbient.temperatureStatorWinding.T", \
"[K]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 0)
DeclareVariable("machine.coreElement.thermalAmbient.temperatureStatorCore.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.thermalAmbient.temperatureStatorCore.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.coreElement.thermalAmbient.temperatureStatorCore.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.powerBalance.lossPowerStatorCore", 1, 5, 106, 132)
DeclareVariable("machine.coreElement.thermalAmbient.temperatureRotorCore.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.thermalAmbient.temperatureRotorCore.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.coreElement.thermalAmbient.temperatureRotorCore.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("machine.coreElement.thermalAmbient.temperatureStrayLoad.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.thermalAmbient.temperatureStrayLoad.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.coreElement.thermalAmbient.temperatureStrayLoad.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.powerBalance.lossPowerStrayLoad", 1, 5, 108, 132)
DeclareVariable("machine.coreElement.thermalAmbient.temperatureFriction.T", \
"Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.thermalAmbient.temperatureFriction.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.coreElement.thermalAmbient.temperatureFriction.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.powerBalance.lossPowerFriction", 1, 5, 109, 132)
DeclareVariable("machine.coreElement.thermalAmbient.constTs.k", "Constant output value",\
 1, 0.0,1E+100,300.0,0,513)
DeclareAlias2("machine.coreElement.thermalAmbient.constTs.y", "Connector of Real output signal",\
 "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 0)
DeclareVariable("machine.coreElement.thermalAmbient.thermalCollectorStator.m", \
"Number of collected heat flows [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,517)
DeclareAlias2("machine.coreElement.thermalAmbient.thermalCollectorStator.port_a[1].T",\
 "Port temperature [K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1,\
 5, 268, 4)
DeclareAlias2("machine.coreElement.thermalAmbient.thermalCollectorStator.port_a[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.rs.resistor[1].LossPower", 1, 5, 153, 132)
DeclareAlias2("machine.coreElement.thermalAmbient.thermalCollectorStator.port_a[2].T",\
 "Port temperature [K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1,\
 5, 268, 4)
DeclareAlias2("machine.coreElement.thermalAmbient.thermalCollectorStator.port_a[2].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.rs.resistor[2].LossPower", 1, 5, 161, 132)
DeclareAlias2("machine.coreElement.thermalAmbient.thermalCollectorStator.port_a[3].T",\
 "Port temperature [K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1,\
 5, 268, 4)
DeclareAlias2("machine.coreElement.thermalAmbient.thermalCollectorStator.port_a[3].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.rs.resistor[3].LossPower", 1, 5, 169, 132)
DeclareAlias2("machine.coreElement.thermalAmbient.thermalCollectorStator.port_b.T",\
 "Port temperature [K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1,\
 5, 268, 4)
DeclareAlias2("machine.coreElement.thermalAmbient.thermalCollectorStator.port_b.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.thermalAmbient.Q_flowStatorWinding", -1, 5, 249, 132)
DeclareVariable("machine.coreElement.thermalAmbient.Tpm", "Temperature of permanent magnet [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.thermalAmbient.Tr", "Temperature of damper cage (optional) [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.thermalAmbient.Q_flowRotorWinding", \
"Heat flow rate of damper cage (optional) [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("machine.coreElement.thermalAmbient.Q_flowPermanentMagnet", \
"Heat flow rate of permanent magnets [W]", "machine.coreElement.powerBalance.lossPowerPermanentMagnet", 1,\
 5, 111, 0)
DeclareVariable("machine.coreElement.thermalAmbient.Q_flowTotal", "[W]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.thermalAmbient.temperatureRotorWinding.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.coreElement.thermalAmbient.temperatureRotorWinding.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("machine.coreElement.thermalAmbient.temperatureRotorWinding.T", \
"[K]", 293.15, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.thermalAmbient.temperaturePermanentMagnet.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.coreElement.thermalAmbient.temperaturePermanentMagnet.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.powerBalance.lossPowerPermanentMagnet", 1, 5, 111, 132)
DeclareVariable("machine.coreElement.thermalAmbient.temperaturePermanentMagnet.T",\
 "[K]", 293.15, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.thermalAmbient.constTpm.k", \
"Constant output value", 293.15, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.thermalAmbient.constTpm.y", \
"Connector of Real output signal", 293.15, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.pi", "", 3.141592653589793, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.internalThermalPort.m", "Number of stator phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,2573)
DeclareAlias2("machine.coreElement.internalThermalPort.heatPortStatorWinding[1].T",\
 "Port temperature [K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1,\
 5, 268, 1028)
DeclareVariable("machine.coreElement.internalThermalPort.heatPortStatorWinding[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareAlias2("machine.coreElement.internalThermalPort.heatPortStatorWinding[2].T",\
 "Port temperature [K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1,\
 5, 268, 1028)
DeclareVariable("machine.coreElement.internalThermalPort.heatPortStatorWinding[2].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareAlias2("machine.coreElement.internalThermalPort.heatPortStatorWinding[3].T",\
 "Port temperature [K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1,\
 5, 268, 1028)
DeclareVariable("machine.coreElement.internalThermalPort.heatPortStatorWinding[3].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("machine.coreElement.internalThermalPort.heatPortStatorCore.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("machine.coreElement.internalThermalPort.heatPortStatorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("machine.coreElement.internalThermalPort.heatPortRotorCore.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("machine.coreElement.internalThermalPort.heatPortRotorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("machine.coreElement.internalThermalPort.heatPortStrayLoad.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("machine.coreElement.internalThermalPort.heatPortStrayLoad.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("machine.coreElement.internalThermalPort.heatPortFriction.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("machine.coreElement.internalThermalPort.heatPortFriction.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("machine.coreElement.internalThermalPort.useDamperCage", \
"Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,2571)
DeclareVariable("machine.coreElement.internalThermalPort.heatPortPermanentMagnet.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("machine.coreElement.internalThermalPort.heatPortPermanentMagnet.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("machine.coreElement.airGapR.Lmd", "Main field inductance d-axis [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.airGapR.Lmq", "Main field inductance q-axis [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.airGapR.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("machine.coreElement.airGapR.p", "Number of pole pairs [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareAlias2("machine.coreElement.airGapR.tauElectrical", "[N.m]", \
"machine.coreElement.tauElectrical", 1, 5, 63, 0)
DeclareVariable("machine.coreElement.airGapR.gamma", "Rotor displacement angle [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.airGapR.der(gamma)", "der(Rotor displacement angle) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.airGapR.i_ss[1]", "Stator current space phasor with respect to the stator fixed frame [A]",\
 "machine.coreElement.lssigma.i_[1]", 1, 5, 175, 0)
DeclareAlias2("machine.coreElement.airGapR.i_ss[2]", "Stator current space phasor with respect to the stator fixed frame [A]",\
 "machine.coreElement.lssigma.i_[2]", 1, 5, 176, 0)
DeclareAlias2("machine.coreElement.airGapR.i_sr[1]", "Stator current space phasor with respect to the rotor fixed frame [A]",\
 "machine.coreElement.idq_sr[1]", 1, 1, 0, 0)
DeclareAlias2("machine.coreElement.airGapR.i_sr[2]", "Stator current space phasor with respect to the rotor fixed frame [A]",\
 "machine.coreElement.idq_sr[2]", 1, 1, 1, 0)
DeclareAlias2("machine.coreElement.airGapR.i_rs[1]", "Rotor current space phasor with respect to the stator fixed frame [A]",\
 "machine.coreElement.idq_rs[1]", 1, 5, 117, 0)
DeclareAlias2("machine.coreElement.airGapR.i_rs[2]", "Rotor current space phasor with respect to the stator fixed frame [A]",\
 "machine.coreElement.idq_rs[2]", 1, 5, 118, 0)
DeclareAlias2("machine.coreElement.airGapR.i_rr[1]", "Rotor current space phasor with respect to the rotor fixed frame [A]",\
 "machine.coreElement.permanentMagnet.Ie", 1, 5, 345, 0)
DeclareVariable("machine.coreElement.airGapR.i_rr[2]", "Rotor current space phasor with respect to the rotor fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.airGapR.psi_ms[1]", "Magnetizing flux phasor with respect to the stator fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.airGapR.psi_ms[2]", "Magnetizing flux phasor with respect to the stator fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.airGapR.der(psi_ms[1])", "der(Magnetizing flux phasor with respect to the stator fixed frame) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.airGapR.der(psi_ms[2])", "der(Magnetizing flux phasor with respect to the stator fixed frame) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.airGapR.psi_mr[1]", "Magnetizing flux phasor with respect to the rotor fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.airGapR.psi_mr[2]", "Magnetizing flux phasor with respect to the rotor fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.airGapR.der(psi_mr[1])", "der(Magnetizing flux phasor with respect to the rotor fixed frame) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.airGapR.der(psi_mr[2])", "der(Magnetizing flux phasor with respect to the rotor fixed frame) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.airGapR.RotationMatrix[1, 1]", \
"Matrix of rotation from rotor to stator", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.airGapR.RotationMatrix[1, 2]", \
"Matrix of rotation from rotor to stator", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.airGapR.RotationMatrix[2, 1]", \
"Matrix of rotation from rotor to stator", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.airGapR.RotationMatrix[2, 2]", \
"Matrix of rotation from rotor to stator", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.airGapR.der(RotationMatrix[1, 1])", \
"der(Matrix of rotation from rotor to stator)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.airGapR.der(RotationMatrix[1, 2])", \
"der(Matrix of rotation from rotor to stator)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.airGapR.der(RotationMatrix[2, 1])", \
"der(Matrix of rotation from rotor to stator)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.airGapR.der(RotationMatrix[2, 2])", \
"der(Matrix of rotation from rotor to stator)", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.airGapR.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "multiSensor.flange_a.phi", 1, 1, 2, 4)
DeclareAlias2("machine.coreElement.airGapR.flange.tau", "Cut torque in the flange [N.m]",\
 "machine.coreElement.tauElectrical", -1, 5, 63, 132)
DeclareAlias2("machine.coreElement.airGapR.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 "machine.coreElement.fixed.phi0", 1, 7, 27, 4)
DeclareAlias2("machine.coreElement.airGapR.support.tau", "Cut torque in the flange [N.m]",\
 "machine.coreElement.tauElectrical", 1, 5, 63, 132)
DeclareAlias2("machine.coreElement.airGapR.spacePhasor_s.v_[1]", \
"1=real, 2=imaginary part [V]", "machine.coreElement.airGapR.der(psi_ms[1])", 1,\
 5, 306, 4)
DeclareAlias2("machine.coreElement.airGapR.spacePhasor_s.v_[2]", \
"1=real, 2=imaginary part [V]", "machine.coreElement.airGapR.der(psi_ms[2])", 1,\
 5, 307, 4)
DeclareAlias2("machine.coreElement.airGapR.spacePhasor_s.i_[1]", \
"1=real, 2=imaginary part [A]", "machine.coreElement.lssigma.i_[1]", 1, 5, 175, 132)
DeclareAlias2("machine.coreElement.airGapR.spacePhasor_s.i_[2]", \
"1=real, 2=imaginary part [A]", "machine.coreElement.lssigma.i_[2]", 1, 5, 176, 132)
DeclareAlias2("machine.coreElement.airGapR.spacePhasor_r.v_[1]", \
"1=real, 2=imaginary part [V]", "machine.coreElement.airGapR.der(psi_mr[1])", 1,\
 5, 310, 4)
DeclareAlias2("machine.coreElement.airGapR.spacePhasor_r.v_[2]", \
"1=real, 2=imaginary part [V]", "machine.coreElement.airGapR.der(psi_mr[2])", 1,\
 5, 311, 4)
DeclareAlias2("machine.coreElement.airGapR.spacePhasor_r.i_[1]", \
"1=real, 2=imaginary part [A]", "machine.coreElement.permanentMagnet.Ie", 1, 5, 345,\
 132)
DeclareVariable("machine.coreElement.airGapR.spacePhasor_r.i_[2]", \
"1=real, 2=imaginary part [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.coreElement.airGapR.i_mr[1]", "Magnetizing current space phasor with respect to the rotor fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.airGapR.i_mr[2]", "Magnetizing current space phasor with respect to the rotor fixed frame [A]",\
 "machine.coreElement.idq_sr[2]", 1, 1, 1, 0)
DeclareVariable("machine.coreElement.airGapR.L[1, 1]", "Inductance matrix [H]", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.airGapR.L[1, 2]", "Inductance matrix [H]", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.airGapR.L[2, 1]", "Inductance matrix [H]", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.airGapR.L[2, 2]", "Inductance matrix [H]", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.TpmOperational", "Operational temperature of permanent magnet [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.TrOperational", "Operational temperature of (optional) damper cage [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.VsOpenCircuit", "Open circuit RMS voltage per phase @ fsNominal [V]",\
 112.3, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.Lmd", "Stator main field inductance per phase in d-axis [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.Lmq", "Stator main field inductance per phase in q-axis [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.useDamperCage", "Enable / disable damper cage [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("machine.coreElement.Lrsigmad", "Damper stray inductance in d-axis [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.Lrsigmaq", "Damper stray inductance in q-axis [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.Rrd", "Damper resistance in d-axis at TRef [Ohm]",\
 0.04, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.Rrq", "Damper resistance in q-axis at TRef [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.TrRef", "Reference temperature of damper resistances in d- and q-axis [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.coreElement.alpha20r", "Temperature coefficient of damper resistances in d- and q-axis [1/K]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.permanentMagnetLossParameters.PRef", \
"Reference permanent magnet losses at IRef and wRef [W]", 120.0, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("machine.coreElement.permanentMagnetLossParameters.c", \
"Part of permanent magnet losses at current = 0, i.e. independent of current", \
0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("machine.coreElement.permanentMagnetLossParameters.IRef", \
"Reference stator RMS current that PRef refers to [A]", 100, 1E-60,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.permanentMagnetLossParameters.power_I", \
"Exponent of permanent magnet loss torque w.r.t. stator current", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.permanentMagnetLossParameters.wRef", \
"Reference angular velocity that PRef refers to [rad/s|rev/min]", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.permanentMagnetLossParameters.power_w", \
"Exponent of permanent magnet loss torque w.r.t. angular velocity", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.permanentMagnetLossParameters.tauRef", \
"Reference permanent magnet loss torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.permanentMagnet.Ie", "Equivalent excitation current [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("machine.coreElement.permanentMagnet.spacePhasor_r.v_[1]", \
"1=real, 2=imaginary part [V]", "machine.coreElement.airGapR.der(psi_mr[1])", 1,\
 5, 310, 4)
DeclareAlias2("machine.coreElement.permanentMagnet.spacePhasor_r.v_[2]", \
"1=real, 2=imaginary part [V]", "machine.coreElement.airGapR.der(psi_mr[2])", 1,\
 5, 311, 4)
DeclareAlias2("machine.coreElement.permanentMagnet.spacePhasor_r.i_[1]", \
"1=real, 2=imaginary part [A]", "machine.coreElement.permanentMagnet.Ie", -1, 5,\
 345, 132)
DeclareVariable("machine.coreElement.permanentMagnet.spacePhasor_r.i_[2]", \
"1=real, 2=imaginary part [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.coreElement.permanentMagnet.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "multiSensor.flange_a.phi", 1, 1, 2, 4)
DeclareVariable("machine.coreElement.permanentMagnet.flange.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("machine.coreElement.permanentMagnet.support.phi", \
"Absolute rotation angle of flange [rad|deg]", "machine.coreElement.fixed.phi0", 1,\
 7, 27, 4)
DeclareAlias2("machine.coreElement.permanentMagnet.support.tau", \
"Cut torque in the flange [N.m]", "machine.coreElement.permanentMagnet.flange.tau", -1,\
 5, 347, 132)
DeclareVariable("machine.coreElement.permanentMagnet.phi", "Angle between shaft and support [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.permanentMagnet.der(phi)", "der(Angle between shaft and support) [rad/s]",\
 "inertia.w", 1, 1, 15, 0)
DeclareAlias2("machine.coreElement.permanentMagnet.tau", "Torque [N.m]", \
"machine.coreElement.permanentMagnet.flange.tau", -1, 5, 347, 0)
DeclareAlias2("machine.coreElement.permanentMagnet.w", "Relative angular velocity of flange and support [rad/s]",\
 "inertia.w", 1, 1, 15, 0)
DeclareVariable("machine.coreElement.permanentMagnet.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("machine.coreElement.permanentMagnet.permanentMagnetLossParameters.PRef",\
 "Reference permanent magnet losses at IRef and wRef [W]", 120.0, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("machine.coreElement.permanentMagnet.permanentMagnetLossParameters.c",\
 "Part of permanent magnet losses at current = 0, i.e. independent of current", \
0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("machine.coreElement.permanentMagnet.permanentMagnetLossParameters.IRef",\
 "Reference stator RMS current that PRef refers to [A]", 1E-60, 1E-60,1E+100,0.0,\
0,513)
DeclareVariable("machine.coreElement.permanentMagnet.permanentMagnetLossParameters.power_I",\
 "Exponent of permanent magnet loss torque w.r.t. stator current", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.permanentMagnet.permanentMagnetLossParameters.wRef",\
 "Reference angular velocity that PRef refers to [rad/s|rev/min]", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.permanentMagnet.permanentMagnetLossParameters.power_w",\
 "Exponent of permanent magnet loss torque w.r.t. angular velocity", 1E-60, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("machine.coreElement.permanentMagnet.permanentMagnetLossParameters.tauRef",\
 "Reference permanent magnet loss torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.permanentMagnet.useHeatPort", \
"=true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("machine.coreElement.permanentMagnet.heatPort.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.coreElement.permanentMagnet.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"machine.coreElement.powerBalance.lossPowerPermanentMagnet", -1, 5, 111, 132)
DeclareAlias2("machine.coreElement.permanentMagnet.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 "machine.coreElement.powerBalance.lossPowerPermanentMagnet", 1, 5, 111, 0)
DeclareAlias2("machine.coreElement.permanentMagnet.is[1]", "Instantaneous stator currents [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("machine.coreElement.permanentMagnet.is[2]", "Instantaneous stator currents [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("machine.coreElement.permanentMagnet.is[3]", "Instantaneous stator currents [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareVariable("machine.coreElement.permanentMagnet.iRMS", "[A]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("machine.coreElement.Ie", "Equivalent excitation current [A]", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("machine.coreElement.damperCageLossPower", "Damper losses [W]", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("machine.coreElement.airgapTorque", "[N.m]", "machine.coreElement.tauElectrical", -1,\
 5, 63, 0)
DeclareVariable("machine.coreElement.innerTorque", "[N.m]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.coreElement.inertiaTorque", "[N.m]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.coreElement.statorWindingTemperatures[1].T", \
"Absolute temperature as output signal [K]", "machine.coreElement.thermalAmbient.constTs.k", 1,\
 5, 268, 0)
DeclareAlias2("machine.coreElement.statorWindingTemperatures[1].port.T", \
"Port temperature [K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5,\
 268, 4)
DeclareVariable("machine.coreElement.statorWindingTemperatures[1].port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0, \
0.0,0.0,0.0,0,777)
DeclareAlias2("machine.coreElement.statorWindingTemperatures[2].T", \
"Absolute temperature as output signal [K]", "machine.coreElement.thermalAmbient.constTs.k", 1,\
 5, 268, 0)
DeclareAlias2("machine.coreElement.statorWindingTemperatures[2].port.T", \
"Port temperature [K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5,\
 268, 4)
DeclareVariable("machine.coreElement.statorWindingTemperatures[2].port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0, \
0.0,0.0,0.0,0,777)
DeclareAlias2("machine.coreElement.statorWindingTemperatures[3].T", \
"Absolute temperature as output signal [K]", "machine.coreElement.thermalAmbient.constTs.k", 1,\
 5, 268, 0)
DeclareAlias2("machine.coreElement.statorWindingTemperatures[3].port.T", \
"Port temperature [K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5,\
 268, 4)
DeclareVariable("machine.coreElement.statorWindingTemperatures[3].port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0, \
0.0,0.0,0.0,0,777)
DeclareVariable("machine.coreElement.statorCoreTemperature.T", "Absolute temperature as output signal [K]",\
 293.15, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.statorCoreTemperature.port.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.coreElement.statorCoreTemperature.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0, \
0.0,0.0,0.0,0,777)
DeclareVariable("machine.coreElement.temperatures.useDamperCage", \
"Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareVariable("machine.coreElement.temperatures.permanentMagnet", "[K|degC]", \
293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.coreElement.temperatures.rotorCore", "[K|degC]", 293.15,\
 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.coreElement.temperatures.statorCore", "[K|degC]", \
293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.coreElement.temperatures.statorWindings[1]", "[K|degC]", \
"machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.coreElement.temperatures.statorWindings[2]", "[K|degC]", \
"machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.coreElement.temperatures.statorWindings[3]", "[K|degC]", \
"machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("machine.coreElement.permanentMagnetTemperature.T", \
"Absolute temperature as output signal [K]", 293.15, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.permanentMagnetTemperature.port.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.coreElement.permanentMagnetTemperature.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0, \
0.0,0.0,0.0,0,777)
DeclareVariable("machine.coreElement.rotorCoreTemperature.T", "Absolute temperature as output signal [K]",\
 293.15, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.rotorCoreTemperature.port.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.coreElement.rotorCoreTemperature.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0, \
0.0,0.0,0.0,0,777)
DeclareVariable("machine.terminalBox.m", "Number of phases [:#(type=Integer)]", 3,\
 0.0,0.0,0.0,0,517)
DeclareVariable("machine.terminalBox.terminalConnection", "Choose Y=star/D=delta [:#(type=DymolaModels.Electrical.MultiPhase.Choices.Wiring)]",\
 1, 1.0,2.0,0.0,0,517)
DeclareVariable("machine.terminalBox.isDelta", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,515)
DeclareVariable("machine.terminalBox.plug_sp.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.terminalBox.plug_sp.pin[1].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.terminalBox.plug_sp.pin[1].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", -1, 5, 35, 132)
DeclareAlias2("machine.terminalBox.plug_sp.pin[2].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.terminalBox.plug_sp.pin[2].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", -1, 5, 37, 132)
DeclareAlias2("machine.terminalBox.plug_sp.pin[3].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.terminalBox.plug_sp.pin[3].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", -1, 5, 39, 132)
DeclareVariable("machine.terminalBox.plug_sn.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.terminalBox.plug_sn.pin[1].v", "Potential at the pin [V]",\
 "machine.coreElement.plug_sn.pin[1].v", 1, 5, 123, 4)
DeclareAlias2("machine.terminalBox.plug_sn.pin[1].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 132)
DeclareAlias2("machine.terminalBox.plug_sn.pin[2].v", "Potential at the pin [V]",\
 "machine.coreElement.plug_sn.pin[1].v", 1, 5, 123, 4)
DeclareAlias2("machine.terminalBox.plug_sn.pin[2].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 132)
DeclareAlias2("machine.terminalBox.plug_sn.pin[3].v", "Potential at the pin [V]",\
 "machine.coreElement.plug_sn.pin[1].v", 1, 5, 123, 4)
DeclareAlias2("machine.terminalBox.plug_sn.pin[3].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 132)
DeclareVariable("machine.terminalBox.plugSupply.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.terminalBox.plugSupply.pin[1].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.terminalBox.plugSupply.pin[1].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 132)
DeclareAlias2("machine.terminalBox.plugSupply.pin[2].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.terminalBox.plugSupply.pin[2].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 132)
DeclareAlias2("machine.terminalBox.plugSupply.pin[3].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.terminalBox.plugSupply.pin[3].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 132)
DeclareAlias2("machine.terminalBox.starpoint.v", "Potential at the pin [V]", \
"machine.coreElement.plug_sn.pin[1].v", 1, 5, 123, 4)
DeclareVariable("machine.terminalBox.starpoint.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.terminalBox.star.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("machine.terminalBox.star.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.terminalBox.star.plug_p.pin[1].v", "Potential at the pin [V]",\
 "machine.coreElement.plug_sn.pin[1].v", 1, 5, 123, 4)
DeclareAlias2("machine.terminalBox.star.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 132)
DeclareAlias2("machine.terminalBox.star.plug_p.pin[2].v", "Potential at the pin [V]",\
 "machine.coreElement.plug_sn.pin[1].v", 1, 5, 123, 4)
DeclareAlias2("machine.terminalBox.star.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 132)
DeclareAlias2("machine.terminalBox.star.plug_p.pin[3].v", "Potential at the pin [V]",\
 "machine.coreElement.plug_sn.pin[1].v", 1, 5, 123, 4)
DeclareAlias2("machine.terminalBox.star.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 132)
DeclareAlias2("machine.terminalBox.star.pin_n.v", "Potential at the pin [V]", \
"machine.coreElement.plug_sn.pin[1].v", 1, 5, 123, 4)
DeclareVariable("machine.terminalBox.star.pin_n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.angleSensor.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "machine.fixed.phi0", 1, 7, 29, 4)
DeclareVariable("machine.angleSensor.flange_a.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.angleSensor.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "multiSensor.flange_a.phi", 1, 1, 2, 4)
DeclareVariable("machine.angleSensor.flange_b.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.angleSensor.phi_rel", "Relative angle between two flanges (= flange_b.phi - flange_a.phi) as output signal [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.speedSensor.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "machine.fixed.phi0", 1, 7, 29, 4)
DeclareVariable("machine.speedSensor.flange_a.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.speedSensor.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "multiSensor.flange_a.phi", 1, 1, 2, 4)
DeclareVariable("machine.speedSensor.flange_b.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.speedSensor.phi_rel", "Relative angle between two flanges (flange_b.phi - flange_a.phi) [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.speedSensor.der(phi_rel)", "der(Relative angle between two flanges (flange_b.phi - flange_a.phi)) [rad/s]",\
 "inertia.w", 1, 1, 15, 0)
DeclareAlias2("machine.speedSensor.w_rel", "Relative angular velocity between two flanges (= der(flange_b.phi) - der(flange_a.phi)) as output signal [rad/s]",\
 "inertia.w", 1, 1, 15, 0)
DeclareAlias2("machine.torqueSensor.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "multiSensor.flange_a.phi", 1, 1, 2, 4)
DeclareAlias2("machine.torqueSensor.flange_a.tau", "Cut torque in the flange [N.m]",\
 "machine.flange.tau", -1, 5, 40, 132)
DeclareAlias2("machine.torqueSensor.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "multiSensor.flange_a.phi", 1, 1, 2, 4)
DeclareAlias2("machine.torqueSensor.flange_b.tau", "Cut torque in the flange [N.m]",\
 "machine.flange.tau", 1, 5, 40, 132)
DeclareAlias2("machine.torqueSensor.tau", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 "machine.flange.tau", -1, 5, 40, 0)
DeclareAlias2("machine.innerPower.u1", "Connector of Real input signal 1", \
"inertia.w", 1, 1, 15, 0)
DeclareVariable("machine.innerPower.u2", "Connector of Real input signal 2", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("machine.innerPower.y", "Connector of Real output signal", 0.0, \
0.0,0.0,0.0,0,512)
DeclareParameter("machine.signChange.k", "Gain value multiplied with input signal [1]",\
 28, -1, 0.0,0.0,0.0,0,560)
DeclareAlias2("machine.signChange.u", "Input signal connector", "machine.coreElement.innerTorque", 1,\
 5, 362, 0)
DeclareAlias2("machine.signChange.y", "Output signal connector", \
"machine.innerPower.u2", 1, 5, 396, 0)
DeclareVariable("machine.toBus_temperatures.useDamperCage", "Enable / disable damper cage [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("machine.toBus_temperatures.u.useDamperCage", "Enable / disable damper cage [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,523)
DeclareVariable("machine.toBus_temperatures.u.permanentMagnet", "[K|degC]", \
293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_temperatures.u.rotorCore", "[K|degC]", 293.15, \
0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_temperatures.u.statorCore", "[K|degC]", 293.15, \
0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.toBus_temperatures.u.statorWindings[1]", "[K|degC]", \
"machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_temperatures.u.statorWindings[2]", "[K|degC]", \
"machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_temperatures.u.statorWindings[3]", "[K|degC]", \
"machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_shaftSpeed.u", "Mechanic rotational speed of machine's shaft [rad/s|1/min]",\
 "inertia.w", 1, 1, 15, 0)
DeclareAlias2("machine.toBus_shaftAngle.u", "Mechanic angle of machine's shaft [rad|deg]",\
 "machine.angleSensor.phi_rel", 1, 5, 392, 0)
DeclareAlias2("machine.toBus_outerTorque.u", "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 0)
DeclareAlias2("machine.toBus_innerTorque.u", "Electrical torque inside the machine [N.m]",\
 "machine.coreElement.innerTorque", 1, 5, 362, 0)
DeclareAlias2("machine.toBus_mechanicPower.u", "Mechanic power at the machine's shaft [W]",\
 "machine.innerPower.y", 1, 5, 397, 0)
DeclareParameter("machine.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 29, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("machine.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "machine.fixed.phi0", 1, 7, 29, 4)
DeclareVariable("machine.fixed.flange.tau", "Cut torque in the flange [N.m]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.delta.m", "Number of phases [:#(type=Integer)]", 3, 2.0,\
1E+100,0.0,0,517)
DeclareVariable("machine.delta.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.delta.plug_p.pin[1].v", "Potential at the pin [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareVariable("machine.delta.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.delta.plug_p.pin[2].v", "Potential at the pin [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareVariable("machine.delta.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.delta.plug_p.pin[3].v", "Potential at the pin [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareVariable("machine.delta.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.delta.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.delta.plug_n.pin[1].v", "Potential at the pin [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareVariable("machine.delta.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.delta.plug_n.pin[2].v", "Potential at the pin [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareVariable("machine.delta.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.delta.plug_n.pin[3].v", "Potential at the pin [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareVariable("machine.delta.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.voltageSensor.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("machine.voltageSensor.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.voltageSensor.plug_p.pin[1].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareVariable("machine.voltageSensor.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.voltageSensor.plug_p.pin[2].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareVariable("machine.voltageSensor.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.voltageSensor.plug_p.pin[3].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareVariable("machine.voltageSensor.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.voltageSensor.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.voltageSensor.plug_n.pin[1].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareVariable("machine.voltageSensor.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.voltageSensor.plug_n.pin[2].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareVariable("machine.voltageSensor.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.voltageSensor.plug_n.pin[3].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareVariable("machine.voltageSensor.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.voltageSensor.v[1]", "Voltage between pin p and n (= p.v - n.v) as output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.voltageSensor.v[2]", "Voltage between pin p and n (= p.v - n.v) as output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.voltageSensor.v[3]", "Voltage between pin p and n (= p.v - n.v) as output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.voltageSensor.voltageSensor[1].p.v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareVariable("machine.voltageSensor.voltageSensor[1].p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.voltageSensor.voltageSensor[1].n.v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareVariable("machine.voltageSensor.voltageSensor[1].n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.voltageSensor.voltageSensor[1].v", "Voltage between pin p and n (= p.v - n.v) as output signal [V]",\
 "machine.voltageSensor.v[1]", 1, 5, 422, 0)
DeclareAlias2("machine.voltageSensor.voltageSensor[2].p.v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareVariable("machine.voltageSensor.voltageSensor[2].p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.voltageSensor.voltageSensor[2].n.v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareVariable("machine.voltageSensor.voltageSensor[2].n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.voltageSensor.voltageSensor[2].v", "Voltage between pin p and n (= p.v - n.v) as output signal [V]",\
 "machine.voltageSensor.v[2]", 1, 5, 423, 0)
DeclareAlias2("machine.voltageSensor.voltageSensor[3].p.v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareVariable("machine.voltageSensor.voltageSensor[3].p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.voltageSensor.voltageSensor[3].n.v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareVariable("machine.voltageSensor.voltageSensor[3].n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.voltageSensor.voltageSensor[3].v", "Voltage between pin p and n (= p.v - n.v) as output signal [V]",\
 "machine.voltageSensor.v[3]", 1, 5, 424, 0)
DeclareVariable("machine.currentSensor.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("machine.currentSensor.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.currentSensor.plug_p.pin[1].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.currentSensor.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 132)
DeclareAlias2("machine.currentSensor.plug_p.pin[2].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.currentSensor.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 132)
DeclareAlias2("machine.currentSensor.plug_p.pin[3].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.currentSensor.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 132)
DeclareVariable("machine.currentSensor.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.currentSensor.plug_n.pin[1].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.currentSensor.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", -1, 5, 35, 132)
DeclareAlias2("machine.currentSensor.plug_n.pin[2].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.currentSensor.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", -1, 5, 37, 132)
DeclareAlias2("machine.currentSensor.plug_n.pin[3].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.currentSensor.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", -1, 5, 39, 132)
DeclareAlias2("machine.currentSensor.i[1]", "current in the branch from p to n as output signal",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("machine.currentSensor.i[2]", "current in the branch from p to n as output signal",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("machine.currentSensor.i[3]", "current in the branch from p to n as output signal",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareAlias2("machine.currentSensor.currentSensor[1].p.v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.currentSensor.currentSensor[1].p.i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 132)
DeclareAlias2("machine.currentSensor.currentSensor[1].n.v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.currentSensor.currentSensor[1].n.i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", -1, 5, 35, 132)
DeclareAlias2("machine.currentSensor.currentSensor[1].i", "Current in the branch from p to n as output signal [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("machine.currentSensor.currentSensor[2].p.v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.currentSensor.currentSensor[2].p.i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 132)
DeclareAlias2("machine.currentSensor.currentSensor[2].n.v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.currentSensor.currentSensor[2].n.i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", -1, 5, 37, 132)
DeclareAlias2("machine.currentSensor.currentSensor[2].i", "Current in the branch from p to n as output signal [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("machine.currentSensor.currentSensor[3].p.v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.currentSensor.currentSensor[3].p.i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 132)
DeclareAlias2("machine.currentSensor.currentSensor[3].n.v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.currentSensor.currentSensor[3].n.i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", -1, 5, 39, 132)
DeclareAlias2("machine.currentSensor.currentSensor[3].i", "Current in the branch from p to n as output signal [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareVariable("machine.quasiPowerSensor.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("machine.quasiPowerSensor.pc.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.quasiPowerSensor.pc.pin[1].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.quasiPowerSensor.pc.pin[1].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 132)
DeclareAlias2("machine.quasiPowerSensor.pc.pin[2].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.quasiPowerSensor.pc.pin[2].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 132)
DeclareAlias2("machine.quasiPowerSensor.pc.pin[3].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.quasiPowerSensor.pc.pin[3].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 132)
DeclareVariable("machine.quasiPowerSensor.nc.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.quasiPowerSensor.nc.pin[1].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.quasiPowerSensor.nc.pin[1].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", -1, 5, 35, 132)
DeclareAlias2("machine.quasiPowerSensor.nc.pin[2].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.quasiPowerSensor.nc.pin[2].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", -1, 5, 37, 132)
DeclareAlias2("machine.quasiPowerSensor.nc.pin[3].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.quasiPowerSensor.nc.pin[3].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", -1, 5, 39, 132)
DeclareVariable("machine.quasiPowerSensor.pv.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("machine.quasiPowerSensor.pv.pin[1].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareVariable("machine.quasiPowerSensor.pv.pin[1].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.quasiPowerSensor.pv.pin[2].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareVariable("machine.quasiPowerSensor.pv.pin[2].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("machine.quasiPowerSensor.pv.pin[3].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareVariable("machine.quasiPowerSensor.pv.pin[3].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.quasiPowerSensor.nv.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("machine.quasiPowerSensor.nv.pin[1].v", "Potential at the pin [V]",\
 0, 0.0,0.0,0.0,0,521)
DeclareVariable("machine.quasiPowerSensor.nv.pin[1].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.quasiPowerSensor.nv.pin[2].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("machine.quasiPowerSensor.nv.pin[2].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.quasiPowerSensor.nv.pin[3].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("machine.quasiPowerSensor.nv.pin[3].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.quasiPowerSensor.cosphi", "cos(phi) [1]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("machine.quasiPowerSensor.P", "Active power [W]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("machine.quasiPowerSensor.Q", "Reactive power [W]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("machine.quasiPowerSensor.v[1]", "Voltages between pin pv and nv [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 0)
DeclareAlias2("machine.quasiPowerSensor.v[2]", "Voltages between pin pv and nv [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 0)
DeclareAlias2("machine.quasiPowerSensor.v[3]", "Voltages between pin pv and nv [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 0)
DeclareAlias2("machine.quasiPowerSensor.i[1]", "Currents in the branch from pi to ni [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("machine.quasiPowerSensor.i[2]", "Currents in the branch from pi to ni [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("machine.quasiPowerSensor.i[3]", "Currents in the branch from pi to ni [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareVariable("machine.quasiPowerSensor.v_[1]", "Space phasor for voltages between pin pv and nv [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.quasiPowerSensor.v_[2]", "Space phasor for voltages between pin pv and nv [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.quasiPowerSensor.i_[1]", "Space phasor for currents in the branch from pi to ni [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.quasiPowerSensor.i_[2]", "Space phasor for currents in the branch from pi to ni [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.quasiPowerSensor.i_arg", "Angle of current space phasor in polar form [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.quasiPowerSensor.v_arg", "Angle of voltage space phasor in polar form [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machine.star.m", "Number of phases [:#(type=Integer)]", 3, 1.0,\
1E+100,0.0,0,517)
DeclareVariable("machine.star.plug_p.m", "Number of phases [:#(type=Integer)]", 3,\
 1.0,1E+100,0.0,0,525)
DeclareVariable("machine.star.plug_p.pin[1].v", "Potential at the pin [V]", 0.0,\
 0.0,0.0,0.0,0,521)
DeclareVariable("machine.star.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.star.plug_p.pin[2].v", "Potential at the pin [V]", 0.0,\
 0.0,0.0,0.0,0,521)
DeclareVariable("machine.star.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.star.plug_p.pin[3].v", "Potential at the pin [V]", 0.0,\
 0.0,0.0,0.0,0,521)
DeclareVariable("machine.star.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("machine.star.pin_n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("machine.star.pin_n.i", "Current flowing into the pin [A]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("machine.ground.p.v", "Potential at the pin [V]", 0.0, 0.0,0.0,\
0.0,0,521)
DeclareVariable("machine.ground.p.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,777)
DeclareAlias2("machine.cosPhi.u", "Mechanic rotational speed of machine's shaft [1]",\
 "machine.quasiPowerSensor.cosphi", 1, 5, 448, 0)
DeclareAlias2("machine.toBus_lineCurrents.u[1]", "Vector with the currents in the three supply lines [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("machine.toBus_lineCurrents.u[2]", "Vector with the currents in the three supply lines [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("machine.toBus_lineCurrents.u[3]", "Vector with the currents in the three supply lines [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareAlias2("machine.toBus_lineVoltages.u[1]", "Vector with the voltages across the three supply lines [V]",\
 "machine.voltageSensor.v[1]", 1, 5, 422, 0)
DeclareAlias2("machine.toBus_lineVoltages.u[2]", "Vector with the voltages across the three supply lines [V]",\
 "machine.voltageSensor.v[2]", 1, 5, 423, 0)
DeclareAlias2("machine.toBus_lineVoltages.u[3]", "Vector with the voltages across the three supply lines [V]",\
 "machine.voltageSensor.v[3]", 1, 5, 424, 0)
DeclareAlias2("machine.toBus_electricPower.u", "Electric power of the machine [W]",\
 "machine.quasiPowerSensor.P", 1, 5, 449, 0)
DeclareAlias2("machine.internalSupport.phi", "Absolute rotation angle of flange [rad|deg]",\
 "machine.fixed.phi0", 1, 7, 29, 1028)
DeclareVariable("machine.internalSupport.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,2825)
DeclareVariable("threePhaseIdealInverter.plug_p1.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseIdealInverter.plug_p1.pin[1].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("threePhaseIdealInverter.plug_p1.pin[1].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", -1, 5, 35, 132)
DeclareAlias2("threePhaseIdealInverter.plug_p1.pin[2].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("threePhaseIdealInverter.plug_p1.pin[2].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", -1, 5, 37, 132)
DeclareAlias2("threePhaseIdealInverter.plug_p1.pin[3].v", "Potential at the pin [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("threePhaseIdealInverter.plug_p1.pin[3].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", -1, 5, 39, 132)
DeclareAlias2("threePhaseIdealInverter.u1[1]", "Connector of Real input signals [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 0)
DeclareAlias2("threePhaseIdealInverter.u1[2]", "Connector of Real input signals [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 0)
DeclareAlias2("threePhaseIdealInverter.u1[3]", "Connector of Real input signals [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 0)
DeclareVariable("threePhaseIdealInverter.star1.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("threePhaseIdealInverter.star1.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("threePhaseIdealInverter.star1.plug_p.pin[1].v", \
"Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("threePhaseIdealInverter.star1.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[1].i", -1, 5, 35, 132)
DeclareVariable("threePhaseIdealInverter.star1.plug_p.pin[2].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("threePhaseIdealInverter.star1.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[2].i", -1, 5, 37, 132)
DeclareVariable("threePhaseIdealInverter.star1.plug_p.pin[3].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("threePhaseIdealInverter.star1.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "machine.plug_p.pin[3].i", -1, 5, 39, 132)
DeclareVariable("threePhaseIdealInverter.star1.pin_n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("threePhaseIdealInverter.star1.pin_n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("threePhaseIdealInverter.ground.p.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("threePhaseIdealInverter.ground.p.i", "Current flowing into the pin [A]",\
 "threePhaseIdealInverter.star1.pin_n.i", -1, 5, 477, 132)
DeclareVariable("threePhaseIdealInverter.sineVoltage.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.i[1]", "Currents flowing into positive plugs [A]",\
 "machine.plug_p.pin[1].i", -1, 5, 35, 0)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.i[2]", "Currents flowing into positive plugs [A]",\
 "machine.plug_p.pin[2].i", -1, 5, 37, 0)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.i[3]", "Currents flowing into positive plugs [A]",\
 "machine.plug_p.pin[3].i", -1, 5, 39, 0)
DeclareVariable("threePhaseIdealInverter.sineVoltage.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.plug_p.pin[1].v", \
"Potential at the pin [V]", "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "machine.plug_p.pin[1].i", -1, 5, 35, 132)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.plug_p.pin[2].v", \
"Potential at the pin [V]", "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "machine.plug_p.pin[2].i", -1, 5, 37, 132)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.plug_p.pin[3].v", \
"Potential at the pin [V]", "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "machine.plug_p.pin[3].i", -1, 5, 39, 132)
DeclareVariable("threePhaseIdealInverter.sineVoltage.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("threePhaseIdealInverter.sineVoltage.plug_n.pin[1].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "machine.plug_p.pin[1].i", 1, 5, 35, 132)
DeclareVariable("threePhaseIdealInverter.sineVoltage.plug_n.pin[2].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "machine.plug_p.pin[2].i", 1, 5, 37, 132)
DeclareVariable("threePhaseIdealInverter.sineVoltage.plug_n.pin[3].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "machine.plug_p.pin[3].i", 1, 5, 39, 132)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.v[1]", "Voltage between pin p and n (= p.v - n.v) as input signal [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 0)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.v[2]", "Voltage between pin p and n (= p.v - n.v) as input signal [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 0)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.v[3]", "Voltage between pin p and n (= p.v - n.v) as input signal [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 0)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.signalVoltage[1].p.v", \
"Potential at the pin [V]", "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.signalVoltage[1].p.i", \
"Current flowing into the pin [A]", "machine.plug_p.pin[1].i", -1, 5, 35, 132)
DeclareVariable("threePhaseIdealInverter.sineVoltage.signalVoltage[1].n.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.signalVoltage[1].n.i", \
"Current flowing into the pin [A]", "machine.plug_p.pin[1].i", 1, 5, 35, 132)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.signalVoltage[1].v", \
"Voltage between pin p and n (= p.v - n.v) as input signal [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 0)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.signalVoltage[1].i", \
"Current flowing from pin p to pin n [A]", "machine.plug_p.pin[1].i", -1, 5, 35,\
 0)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.signalVoltage[2].p.v", \
"Potential at the pin [V]", "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.signalVoltage[2].p.i", \
"Current flowing into the pin [A]", "machine.plug_p.pin[2].i", -1, 5, 37, 132)
DeclareVariable("threePhaseIdealInverter.sineVoltage.signalVoltage[2].n.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.signalVoltage[2].n.i", \
"Current flowing into the pin [A]", "machine.plug_p.pin[2].i", 1, 5, 37, 132)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.signalVoltage[2].v", \
"Voltage between pin p and n (= p.v - n.v) as input signal [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 0)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.signalVoltage[2].i", \
"Current flowing from pin p to pin n [A]", "machine.plug_p.pin[2].i", -1, 5, 37,\
 0)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.signalVoltage[3].p.v", \
"Potential at the pin [V]", "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.signalVoltage[3].p.i", \
"Current flowing into the pin [A]", "machine.plug_p.pin[3].i", -1, 5, 39, 132)
DeclareVariable("threePhaseIdealInverter.sineVoltage.signalVoltage[3].n.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.signalVoltage[3].n.i", \
"Current flowing into the pin [A]", "machine.plug_p.pin[3].i", 1, 5, 39, 132)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.signalVoltage[3].v", \
"Voltage between pin p and n (= p.v - n.v) as input signal [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 0)
DeclareAlias2("threePhaseIdealInverter.sineVoltage.signalVoltage[3].i", \
"Current flowing from pin p to pin n [A]", "machine.plug_p.pin[3].i", -1, 5, 39,\
 0)
DeclareAlias2("threePhaseIdealInverter.toBus_maxStatorVoltage.u", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"threePhaseIdealInverter.const.k", 1, 5, 488, 0)
DeclareAlias2("threePhaseIdealInverter.toBus_SwitchingFrequency.realPassThrough.u",\
 "Connector of Real input signal", "threePhaseIdealInverter.switchingFrequency.k", 1,\
 7, 30, 0)
DeclareAlias2("threePhaseIdealInverter.toBus_SwitchingFrequency.realPassThrough.y",\
 "Connector of Real output signal", "threePhaseIdealInverter.switchingFrequency.k", 1,\
 7, 30, 0)
DeclareAlias2("threePhaseIdealInverter.toBus_SwitchingFrequency.u", \
"Input signal [Hz]", "threePhaseIdealInverter.switchingFrequency.k", 1, 7, 30, 0)
DeclareVariable("threePhaseIdealInverter.const.k", "Constant output value", 1, \
0.0,0.0,0.0,0,513)
DeclareAlias2("threePhaseIdealInverter.const.y", "Connector of Real output signal",\
 "threePhaseIdealInverter.const.k", 1, 5, 488, 0)
DeclareParameter("threePhaseIdealInverter.switchingFrequency.k", \
"Constant output value", 30, 1E+60, 0.0,0.0,0.0,0,560)
DeclareAlias2("threePhaseIdealInverter.switchingFrequency.y", "Connector of Real output signal",\
 "threePhaseIdealInverter.switchingFrequency.k", 1, 7, 30, 0)
DeclareParameter("threePhaseIdealInverter.maxStatorVoltage", "Constant output value",\
 31, 1E+60, 0.0,0.0,0.0,0,560)
DeclareState("multiSensor.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 2, 0.0, 0.0,0.0,0.0,0,568)
DeclareDerivative("multiSensor.flange_a.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("multiSensor.flange_a.tau", "Cut torque in the flange [N.m]", \
"machine.flange.tau", -1, 5, 40, 132)
DeclareAlias2("multiSensor.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "multiSensor.flange_a.phi", 1, 1, 2, 4)
DeclareAlias2("multiSensor.flange_b.tau", "Cut torque in the flange [N.m]", \
"machine.flange.tau", 1, 5, 40, 132)
DeclareVariable("multiSensor.power", "Power in flange flange_a as output signal [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("multiSensor.w", "Absolute angular velocity of flange_a as output signal [rad/s]",\
 "multiSensor.flange_a.der(phi)", 1, 6, 2, 0)
DeclareAlias2("multiSensor.tau", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 "machine.flange.tau", -1, 5, 40, 0)
DeclareVariable("load.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("load.flange.phi", "Absolute rotation angle of flange [rad|deg]", \
"multiSensor.flange_a.phi", 1, 1, 2, 4)
DeclareVariable("load.flange.tau", "Cut torque in the flange [N.m]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("load.phi_support", "Absolute angle of support flange [rad|deg]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("load.phi", "Angle of flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 "multiSensor.flange_a.phi", 1, 1, 2, 0)
DeclareAlias2("load.der(phi)", "der(Angle of flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "inertia.w", 1, 1, 15, 0)
DeclareVariable("load.tau_nominal", "Nominal torque (if negative, torque is acting as load) [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("load.TorqueDirection", "Same direction of torque in both directions of rotation [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("load.w_nominal", "Nominal speed [rad/s|rad/s]", 1E-15, 1E-15,\
1E+100,0.0,0,513)
DeclareAlias2("load.w", "Angular velocity of flange with respect to support (= der(phi)) [rad/s]",\
 "inertia.w", 1, 1, 15, 0)
DeclareAlias2("load.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "load.flange.tau", -1, 5, 491, 0)
DeclareVariable("controller.desiredSpeed", "[rad/s|1/min]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.actuatingVoltages[1]", "[V]", "machine.plug_p.pin[1].v", 1,\
 5, 34, 0)
DeclareAlias2("controller.actuatingVoltages[2]", "[V]", "machine.plug_p.pin[2].v", 1,\
 5, 36, 0)
DeclareAlias2("controller.actuatingVoltages[3]", "[V]", "machine.plug_p.pin[3].v", 1,\
 5, 38, 0)
DeclareVariable("controller.data.discretize", "True: discrete controller, false: continuous controller [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("controller.data.fs", "Sampling rate for the input signals of the discrete controller [Hz]",\
 32, 10000.0, 0.0,1E+100,0.0,0,560)
DeclareParameter("controller.data.useSolver", "True: solverMethod shall be specifically defined [:#(type=Boolean)]",\
 33, true, 0.0,0.0,0.0,0,562)
DeclareVariable("controller.data.terminalConnection", "Choose Y=star/D=delta [:#(type=DymolaModels.Electrical.MultiPhase.Choices.Wiring)]",\
 1, 1.0,2.0,0.0,0,517)
DeclareVariable("controller.data.Rs", "Stator resistance per phase at TRef [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.Lmd", "Main field inductance in d-axis [H]", \
0.00013, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.Lmq", "Main field inductance in q-axis [H]", \
0.00028, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.Ls_sigma", "Stator stray inductance per phase [H]",\
 2E-05, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.p", "Number of pole pairs [:#(type=Integer)]", 0,\
 0.0,0.0,0.0,0,517)
DeclareVariable("controller.data.fs_nom", "Nominal electric frequency [Hz]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.u_s_openCircuit", "Open circuit RMS phase voltage at fs_nom [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.psi_PM", "Magnetic flux created by the permanent magnets [Wb]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.Ld", "Inductance d-axis [H]", 0.00015, 0.0,0.0,\
0.0,0,513)
DeclareVariable("controller.data.Lq", "Inductance q-axis [H]", 0.0003, 0.0,0.0,\
0.0,0,513)
DeclareVariable("controller.data.machineData.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareParameter("controller.data.machineData.useThermalPort", "True: thermal connector is provided, false: temperature is fixed internally [:#(type=Boolean)]",\
 34, false, 0.0,0.0,0.0,0,562)
DeclareParameter("controller.data.machineData.useSupport", "True: stator is able to rotate, false: stator is fixed internally [:#(type=Boolean)]",\
 35, false, 0.0,0.0,0.0,0,562)
DeclareVariable("controller.data.machineData.terminalConnection", \
"Choose if the machine is Y=star or /D=delta wired [:#(type=DymolaModels.Electrical.MultiPhase.Choices.Wiring)]",\
 1, 1.0,2.0,0.0,0,517)
DeclareParameter("controller.data.machineData.p", "Number of pole pairs (Integer) [:#(type=Integer)]",\
 36, 4, 1.0,1E+100,0.0,0,564)
DeclareParameter("controller.data.machineData.fs_nom", "Nominal electric frequency [Hz]",\
 37, 320, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.data.machineData.Jr", "Rotor's moment of inertia [kg.m2]",\
 38, 0.065, 0.0,0.0,0.0,0,560)
DeclareVariable("controller.data.machineData.Js", "Stator's moment of inertia [kg.m2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("controller.data.machineData.Ts_operational", "Operational temperature of stator resistance [K|degC]",\
 39, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("controller.data.machineData.Rs", "Stator resistance per phase at TRef [Ohm]",\
 40, 0.0175, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.data.machineData.alpha20s", "Temperature coefficient of stator resistance at 20 degC [1/K]",\
 41, 0.00392, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.data.machineData.Ts_ref", "Reference temperature of stator resistance [K|degC]",\
 42, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("controller.data.machineData.Ls_zero", "Stator zero sequence inductance [H]",\
 2E-05, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.machineData.Ls_sigma", "Stator stray inductance per phase [H]",\
 2E-05, 0.0,0.0,0.0,0,513)
DeclareParameter("controller.data.machineData.u_s_openCircuit", "Open circuit RMS voltage per phase @ fs_nom [V]",\
 43, 105, 0.0,0.0,0.0,0,560)
DeclareVariable("controller.data.machineData.Lmd", "Main field inductance in d-axis [H]",\
 0.00013, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.machineData.Lmq", "Main field inductance in q-axis [H]",\
 0.00028, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.machineData.Ld", "Overall inductance in d-axis [H]",\
 0.00015, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.machineData.Lq", "Overall inductance in q-axis [H]",\
 0.0003, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.machineData.useDamperCage", "Enable / disable damper cage [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("controller.data.machineData.Lr_sigma_d", "Damper stray inductance in d-axis [H]",\
 44, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.data.machineData.Lr_sigma_q", "Damper stray inductance in q-axis [H]",\
 45, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.data.machineData.Tr_operational", "Operational temperature of (optional) damper cage [K|degC]",\
 46, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("controller.data.machineData.Rr_d", "Damper resistance in d-axis at TRef [Ohm]",\
 47, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.data.machineData.Rr_q", "Damper resistance in q-axis at TRef [Ohm]",\
 48, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.data.machineData.alpha20r", "Temperature coefficient of damper resistances in d- and q-axis [1/K]",\
 49, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.data.machineData.Tr_ref", "Reference temperature of damper resistances in d- and q-axis [K|degC]",\
 50, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("controller.data.machineData.frictionParameters.PRef", \
"Reference friction losses at wRef [W]", 51, 280.0, 0.0,1E+100,0.0,0,560)
DeclareVariable("controller.data.machineData.frictionParameters.wRef", \
"Reference angular velocity that the PRef refer to [rad/s|rev/min]", 1E-60, \
1E-60,1E+100,0.0,0,513)
DeclareParameter("controller.data.machineData.frictionParameters.power_w", \
"Exponent of friction torque w.r.t. angular velocity", 52, 2.0, 1E-60,1E+100,0.0,\
0,560)
DeclareVariable("controller.data.machineData.frictionParameters.tauRef", \
"Reference friction torque at reference angular velocity [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("controller.data.machineData.frictionParameters.linear", \
"Linear angular velocity range with respect to reference angular velocity", \
0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.machineData.frictionParameters.wLinear", \
"Linear angular velocity range [rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.machineData.frictionParameters.tauLinear", \
"Torque corresponding with linear angular velocity range [N.m]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareParameter("controller.data.machineData.statorCoreParameters.m", \
"Number of phases (1 for DC, 3 for induction machines) [:#(type=Integer)]", 53, 3,\
 0.0,0.0,0.0,0,564)
DeclareParameter("controller.data.machineData.statorCoreParameters.PRef", \
"Reference core losses at reference inner voltage VRef [W]", 54, 1800.0, 0.0,\
1E+100,0.0,0,560)
DeclareVariable("controller.data.machineData.statorCoreParameters.VRef", \
"Reference inner RMS voltage that reference core losses PRef refer to [V]", \
1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("controller.data.machineData.statorCoreParameters.wRef", \
"Reference angular velocity that reference core losses PRef refer to [rad/s]", \
1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("controller.data.machineData.statorCoreParameters.ratioHysteresis",\
 "Ratio of hysteresis losses with respect to the total core losses at VRef and fRef",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("controller.data.machineData.statorCoreParameters.GcRef", \
"Reference conductance at reference frequency and voltage [S]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("controller.data.machineData.statorCoreParameters.wMin", \
"[rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("controller.data.machineData.strayLoadParameters.PRef", \
"Reference stray load losses at IRef and wRef [W]", 55, 850.0, 0.0,1E+100,0.0,0,560)
DeclareVariable("controller.data.machineData.strayLoadParameters.IRef", \
"Reference RMS current that PRef refers to [A]", 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("controller.data.machineData.strayLoadParameters.wRef", \
"Reference angular velocity that PRef refers to [rad/s|rev/min]", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareParameter("controller.data.machineData.strayLoadParameters.power_w", \
"Exponent of stray load loss torque w.r.t. angular velocity", 56, 1.0, 1E-60,\
1E+100,0.0,0,560)
DeclareVariable("controller.data.machineData.strayLoadParameters.tauRef", \
"Reference stray load torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("controller.data.machineData.permanentMagnetParameters.PRef", \
"Reference permanent magnet losses at IRef and wRef [W]", 57, 120.0, 0.0,1E+100,\
0.0,0,560)
DeclareParameter("controller.data.machineData.permanentMagnetParameters.c", \
"Part of permanent magnet losses at current = 0, i.e. independent of current", 58,\
 0.0, 0.0,1.0,0.0,0,560)
DeclareVariable("controller.data.machineData.permanentMagnetParameters.IRef", \
"Reference stator RMS current that PRef refers to [A]", 1E-60, 1E-60,1E+100,0.0,\
0,513)
DeclareParameter("controller.data.machineData.permanentMagnetParameters.power_I",\
 "Exponent of permanent magnet loss torque w.r.t. stator current", 59, 2.0, \
1E-60,1E+100,0.0,0,560)
DeclareVariable("controller.data.machineData.permanentMagnetParameters.wRef", \
"Reference angular velocity that PRef refers to [rad/s|rev/min]", 1E-60, 1E-60,\
1E+100,0.0,0,513)
DeclareParameter("controller.data.machineData.permanentMagnetParameters.power_w",\
 "Exponent of permanent magnet loss torque w.r.t. angular velocity", 60, 1.0, \
1E-60,1E+100,0.0,0,560)
DeclareVariable("controller.data.machineData.permanentMagnetParameters.tauRef", \
"Reference permanent magnet loss torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("controller.data.machineData.tau_nom", "Nominal torque [N.m]", 61,\
 150, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.data.machineData.u_s_nom", "Nominal phase voltage (rms) [V]",\
 62, 145, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.data.machineData.i_s_nom", "Nominal current per phase (rms) [A]",\
 63, 217, 0.0,0.0,0.0,0,560)
DeclareVariable("controller.data.machineData.w_nom", "Nominal mechanical speed [rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.machineData.P_nom", "Nominal mechanical power [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("controller.data.simpleCurrentTuning", "True: Controller design based on time constants, otherwise direct controller parameters [:#(type=Boolean)]",\
 64, true, 0.0,0.0,0.0,0,562)
DeclareParameter("controller.data.T_d", "Resulting closed loop time constant for d-current. kp_d is set accordingly. [s|ms]",\
 65, 0.01, 0.0,0.0,0.0,0,560)
DeclareVariable("controller.data.kp_d_set", "Proportional gain of d-axis current controller",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.Ti_d_set", "Integrator Time constant of d-axis current controller [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("controller.data.T_q", "Resulting closed loop time constant for q-current. kp_q is set accordingly. [s|ms]",\
 66, 0.01, 0.0,0.0,0.0,0,560)
DeclareVariable("controller.data.kp_q_set", "Proportional gain of q-axis current controller. If changed, setting Tiq has no effect",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.Ti_q_set", "Integrator time constant of q-axis current controller [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.kp_d", "Proportional gain of d-axis current controller which is used in the simulation",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.kp_q", "Proportional gain of q-axis current controller which is used in the simulation",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.Ti_d", "Integrator time constant of d-axis current controller which is used in the simulation [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.Ti_q", "Integrator time constant of q-axis current controller which is used in the simulation [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.kp_d_from_Ti_d", "Machine dependent conversion factor to get kpd from Tid",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.kp_q_from_Ti_q", "Machine dependent conversion factor to get kpq from Tiq",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.Ti_d_default", "Default value for Tnd if simpleCurrentTuning is false",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.Ti_q_default", "Default value for Tnq if simpleCurrentTuning is false",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.J_load", "Inertia of the load (rotor inertia already considered) [kg.m2]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.J_sum", "Rotor inertia plus load inertia [kg.m2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.Tw_q", "Time constant of the closed loop current transfer function (Iq/Uq) [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.speedTuningWithSO", "Calculate controller parameters with symmetrical optimum [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("controller.data.speedControllerType_set", "Type of speed controller [:#(type=DymolaModels.Blocks.Choices.PI_Controller)]",\
 67, 3, 1.0,3.0,0.0,0,564)
DeclareVariable("controller.data.kp_w_set", "Gain of speed controller", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.Ti_w_set", "Integrator time constant of speed controller [s]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.kp_w", "Gain of speed controller which is used in the simulation",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.Ti_w", "Integrator time constant of speed controller used in the simulation [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.speedControllerType", "Type of speed controller [:#(type=DymolaModels.Blocks.Choices.PI_Controller)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareVariable("controller.data.speedControllerType_SO", "Controller type for tuning with symmetrical optimum [:#(type=DymolaModels.Blocks.Choices.PI_Controller)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareVariable("controller.data.kp_w_SO", "Value for kp_tau resulting from tuning with symmetrical optimum",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.data.Ti_w_SO", "Value for Ti_tau resulting from tuning with symmetrical optimum [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("controller.data.voltageSecurityFactor", "Percentage of the available voltage that is utilized",\
 68, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("controller.data.kp_FW", "Gain of field weakening controller", 69,\
 5, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.data.Ti_FW", "Integrator time constant of field weakening controller [s]",\
 70, 0.05, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.data.k", "Short Circuit Current / Maximum Allowed Current, or psi_PM/(Lmd*i_s_max)",\
 71, 0.75, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.data.i_s_max", "Maximum line current (rms) [A]", 72,\
 450, 0.0,0.0,0.0,0,560)
DeclareVariable("controller.coreElement.p", "Number of pole pairs [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,517)
DeclareVariable("controller.coreElement.Rs", "Warm stator resistance [Ohm]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.Lmd", "Main field inductance in d-axis [H]",\
 0.00013, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.Lmq", "Main field inductance in q-axis [H]",\
 0.00028, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.Ls_sigma", "Stator stray inductance per phase [H]",\
 2E-05, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.fs_nom", "Nominal electric frequency [Hz]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.psi_PM", "Magnetic flux of the permanent magnet [Wb]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.terminalConnection", "Choose if the machine is Y=star or /D=delta wired [:#(type=DymolaModels.Electrical.MultiPhase.Choices.Wiring)]",\
 1, 1.0,2.0,0.0,0,517)
DeclareVariable("controller.coreElement.voltageSecurityFactor", "Percentage of the available voltage that is utilized",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("controller.coreElement.kp_d", "Proportional gain of d-axis current controller",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.Ti_d", "Time constant of d-axis current controller [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.kp_q", "Proportional gain of q-axis current controller",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.Ti_q", "Time constant of q-axis current controller [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.kp_FW", "Gain of field weakening controller",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.Ti_FW", "Integrator Time constant of field weakening controller [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.i_s_max", "Maximum phase current (rms) [A]",\
 300, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.i_s_peak", "Maximum phase current (amplitude) [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.Ld", "Inductance d-axis [H]", 0.00015, \
0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.Lq", "Inductance q-axis [H]", 0.0003, \
0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentControllers.kp_d", \
"Proportional gain of d-axis current controller", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentControllers.Ti_d", \
"Time constant of d-axis current controller [s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentControllers.kp_q", \
"Proportional gain of q-axis current controller", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentControllers.Ti_q", \
"Time constant of q-axis current controller [s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentControllers.i_d_ref", "[A]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.currentControllers.i_q_ref", "[A]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.currentControllers.i_s[1]", "[A]", \
"machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("controller.coreElement.currentControllers.i_s[2]", "[A]", \
"machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("controller.coreElement.currentControllers.i_s[3]", "[A]", \
"machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareAlias2("controller.coreElement.currentControllers.u_s[1]", "[V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 0)
DeclareAlias2("controller.coreElement.currentControllers.u_s[2]", "[V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 0)
DeclareAlias2("controller.coreElement.currentControllers.u_s[3]", "[V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 0)
DeclareAlias2("controller.coreElement.currentControllers.u_s_dq[1]", "[V]", \
"controller.coreElement.actuatingVoltages_dq[1]", 1, 5, 675, 0)
DeclareAlias2("controller.coreElement.currentControllers.u_s_dq[2]", "[V]", \
"controller.coreElement.actuatingVoltages_dq[2]", 1, 5, 676, 0)
DeclareVariable("controller.coreElement.currentControllers.parkTransform.angle",\
 "[rad|deg]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.currentControllers.parkTransform.alpha",\
 "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.currentControllers.parkTransform.beta", \
"", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.currentControllers.parkTransform.d", "",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.currentControllers.parkTransform.q", "",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.currentControllers.clarkeTransform.alpha",\
 "", "controller.coreElement.currentControllers.parkTransform.alpha", 1, 5, 587,\
 0)
DeclareAlias2("controller.coreElement.currentControllers.clarkeTransform.beta", \
"", "controller.coreElement.currentControllers.parkTransform.beta", 1, 5, 588, 0)
DeclareAlias2("controller.coreElement.currentControllers.clarkeTransform.u[1]", \
"", "machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("controller.coreElement.currentControllers.clarkeTransform.u[2]", \
"", "machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("controller.coreElement.currentControllers.clarkeTransform.u[3]", \
"", "machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareAlias2("controller.coreElement.currentControllers.invParkTransform.angle",\
 "[rad|deg]", "controller.coreElement.currentControllers.parkTransform.angle", 1,\
 5, 586, 0)
DeclareAlias2("controller.coreElement.currentControllers.invParkTransform.alpha",\
 "", "machine.plug_p.pin[1].v", 1, 5, 34, 0)
DeclareVariable("controller.coreElement.currentControllers.invParkTransform.beta",\
 "", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.currentControllers.invParkTransform.d", "",\
 "controller.coreElement.actuatingVoltages_dq[1]", 1, 5, 675, 0)
DeclareAlias2("controller.coreElement.currentControllers.invParkTransform.q", "",\
 "controller.coreElement.actuatingVoltages_dq[2]", 1, 5, 676, 0)
DeclareAlias2("controller.coreElement.currentControllers.invClarkeTransform.alpha",\
 "", "machine.plug_p.pin[1].v", 1, 5, 34, 0)
DeclareAlias2("controller.coreElement.currentControllers.invClarkeTransform.beta",\
 "", "controller.coreElement.currentControllers.invParkTransform.beta", 1, 5, 591,\
 0)
DeclareAlias2("controller.coreElement.currentControllers.invClarkeTransform.y[1]",\
 "", "machine.plug_p.pin[1].v", 1, 5, 34, 0)
DeclareAlias2("controller.coreElement.currentControllers.invClarkeTransform.y[2]",\
 "", "machine.plug_p.pin[2].v", 1, 5, 36, 0)
DeclareAlias2("controller.coreElement.currentControllers.invClarkeTransform.y[3]",\
 "", "machine.plug_p.pin[3].v", 1, 5, 38, 0)
DeclareAlias2("controller.coreElement.currentControllers.error_i_d.u1", "", \
"controller.coreElement.currentControllers.i_d_ref", 1, 5, 584, 0)
DeclareAlias2("controller.coreElement.currentControllers.error_i_d.u2", "", \
"controller.coreElement.currentControllers.parkTransform.d", 1, 5, 589, 0)
DeclareVariable("controller.coreElement.currentControllers.error_i_d.y", "", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.currentControllers.error_i_q.u1", "", \
"controller.coreElement.currentControllers.i_q_ref", 1, 5, 585, 0)
DeclareAlias2("controller.coreElement.currentControllers.error_i_q.u2", "", \
"controller.coreElement.currentControllers.parkTransform.q", 1, 5, 590, 0)
DeclareVariable("controller.coreElement.currentControllers.error_i_q.y", "", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.currentControllers.dCurrentController.k",\
 "Gain [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentControllers.dCurrentController.T",\
 "Time Constant (T>0 required) [s]", 1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("controller.coreElement.currentControllers.dCurrentController.initType",\
 "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("controller.coreElement.currentControllers.dCurrentController.x_start",\
 "Initial or guess value of state", 73, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.coreElement.currentControllers.dCurrentController.y_start",\
 "Initial value of output", 74, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.coreElement.currentControllers.dCurrentController.u", \
"Connector of Real input signal", "controller.coreElement.currentControllers.error_i_d.y", 1,\
 5, 592, 0)
DeclareVariable("controller.coreElement.currentControllers.dCurrentController.y",\
 "Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("controller.coreElement.currentControllers.dCurrentController.x", \
"State of block", 3, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("controller.coreElement.currentControllers.dCurrentController.der(x)",\
 "der(State of block)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.currentControllers.qCurrentController.k",\
 "Gain [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentControllers.qCurrentController.T",\
 "Time Constant (T>0 required) [s]", 1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("controller.coreElement.currentControllers.qCurrentController.initType",\
 "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("controller.coreElement.currentControllers.qCurrentController.x_start",\
 "Initial or guess value of state", 75, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.coreElement.currentControllers.qCurrentController.y_start",\
 "Initial value of output", 76, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.coreElement.currentControllers.qCurrentController.u", \
"Connector of Real input signal", "controller.coreElement.currentControllers.error_i_q.y", 1,\
 5, 593, 0)
DeclareVariable("controller.coreElement.currentControllers.qCurrentController.y",\
 "Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("controller.coreElement.currentControllers.qCurrentController.x", \
"State of block", 4, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("controller.coreElement.currentControllers.qCurrentController.der(x)",\
 "der(State of block)", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.currentControllers.sum_u_d.u1", \
"Connector of Real input signal 1", "controller.coreElement.currentControllers.dCurrentController.y", 1,\
 5, 597, 0)
DeclareVariable("controller.coreElement.currentControllers.sum_u_d.u2", \
"Connector of Real input signal 2", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.currentControllers.sum_u_d.y", \
"Connector of Real output signal", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 0)
DeclareParameter("controller.coreElement.currentControllers.sum_u_d.k1", \
"Gain of input signal 1", 77, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.coreElement.currentControllers.sum_u_d.k2", \
"Gain of input signal 2", 78, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.coreElement.currentControllers.sum_u_q.u1", \
"Connector of Real input signal 1", "controller.coreElement.currentControllers.qCurrentController.y", 1,\
 5, 601, 0)
DeclareVariable("controller.coreElement.currentControllers.sum_u_q.u2", \
"Connector of Real input signal 2", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.currentControllers.sum_u_q.y", \
"Connector of Real output signal", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 0)
DeclareParameter("controller.coreElement.currentControllers.sum_u_q.k1", \
"Gain of input signal 1", 79, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.coreElement.currentControllers.sum_u_q.k2", \
"Gain of input signal 2", 80, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("controller.coreElement.currentControllers.multiplex_u_s.n1", \
"Dimension of input signal connector 1 [:#(type=Integer)]", 1, 0.0,0.0,0.0,0,517)
DeclareVariable("controller.coreElement.currentControllers.multiplex_u_s.n2", \
"Dimension of input signal connector 2 [:#(type=Integer)]", 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("controller.coreElement.currentControllers.multiplex_u_s.u1[1]", \
"Connector of Real input signals 1", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 0)
DeclareAlias2("controller.coreElement.currentControllers.multiplex_u_s.u2[1]", \
"Connector of Real input signals 2", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 0)
DeclareAlias2("controller.coreElement.currentControllers.multiplex_u_s.y[1]", \
"Connector of Real output signals", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 0)
DeclareAlias2("controller.coreElement.currentControllers.multiplex_u_s.y[2]", \
"Connector of Real output signals", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 0)
DeclareVariable("controller.coreElement.currentControllers.p", "Number of pole pairs [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,517)
DeclareVariable("controller.coreElement.currentControllers.Ld", "Inductance d-axis [H]",\
 0.00015, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentControllers.Lq", "Inductance q-axis [H]",\
 0.0003, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentControllers.psi_PM", \
"Magnetic flux of the permanent magnet [Wb]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentControllers.decoupling.Ld", \
"Inductance d-axis [H]", 0.00015, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentControllers.decoupling.Lq", \
"Inductance q-axis [H]", 0.0003, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentControllers.decoupling.psi_PM", \
"Magnetic flux of the permanent magnet [Wb]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentControllers.decoupling.w_el", \
"[rad/s|1/min]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.currentControllers.decoupling.i_d", "[A]",\
 "controller.coreElement.currentControllers.parkTransform.d", 1, 5, 589, 0)
DeclareAlias2("controller.coreElement.currentControllers.decoupling.i_q", "[A]",\
 "controller.coreElement.currentControllers.parkTransform.q", 1, 5, 590, 0)
DeclareAlias2("controller.coreElement.currentControllers.decoupling.u_d_coupling",\
 "[V]", "controller.coreElement.currentControllers.sum_u_d.u2", 1, 5, 602, 0)
DeclareAlias2("controller.coreElement.currentControllers.decoupling.u_q_coupling",\
 "[V]", "controller.coreElement.currentControllers.sum_u_q.u2", 1, 5, 603, 0)
DeclareVariable("controller.coreElement.currentControllers.decoupling.psi_d.u1",\
 "Connector of Real input signal 1", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.currentControllers.decoupling.psi_d.u2", \
"Connector of Real input signal 2", "controller.coreElement.currentControllers.decoupling.constant_psi_PM.k", 1,\
 5, 618, 0)
DeclareVariable("controller.coreElement.currentControllers.decoupling.psi_d.y", \
"Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("controller.coreElement.currentControllers.decoupling.psi_d.k1",\
 "Gain of input signal 1", 81, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.coreElement.currentControllers.decoupling.psi_d.k2",\
 "Gain of input signal 2", 82, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("controller.coreElement.currentControllers.decoupling.psi_q.k", \
"Gain value multiplied with input signal [1]", -0.0003, 0.0,0.0,0.0,0,513)
DeclareAlias2("controller.coreElement.currentControllers.decoupling.psi_q.u", \
"Input signal connector", "controller.coreElement.currentControllers.parkTransform.q", 1,\
 5, 590, 0)
DeclareVariable("controller.coreElement.currentControllers.decoupling.psi_q.y", \
"Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.currentControllers.decoupling.constant_psi_PM.k",\
 "Constant output value", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("controller.coreElement.currentControllers.decoupling.constant_psi_PM.y",\
 "Connector of Real output signal", "controller.coreElement.currentControllers.decoupling.constant_psi_PM.k", 1,\
 5, 618, 0)
DeclareAlias2("controller.coreElement.currentControllers.decoupling.flux_to_u_q_coupling.u1",\
 "Connector of Real input signal 1", "controller.coreElement.currentControllers.decoupling.psi_d.y", 1,\
 5, 615, 0)
DeclareAlias2("controller.coreElement.currentControllers.decoupling.flux_to_u_q_coupling.u2",\
 "Connector of Real input signal 2", "controller.coreElement.currentControllers.decoupling.w_el", 1,\
 5, 613, 0)
DeclareAlias2("controller.coreElement.currentControllers.decoupling.flux_to_u_q_coupling.y",\
 "Connector of Real output signal", "controller.coreElement.currentControllers.sum_u_q.u2", 1,\
 5, 603, 0)
DeclareVariable("controller.coreElement.currentControllers.decoupling.psi_d_currentDependentPortion.k",\
 "Gain value multiplied with input signal [1]", 0.00015, 0.0,0.0,0.0,0,513)
DeclareAlias2("controller.coreElement.currentControllers.decoupling.psi_d_currentDependentPortion.u",\
 "Input signal connector", "controller.coreElement.currentControllers.parkTransform.d", 1,\
 5, 589, 0)
DeclareAlias2("controller.coreElement.currentControllers.decoupling.psi_d_currentDependentPortion.y",\
 "Output signal connector", "controller.coreElement.currentControllers.decoupling.psi_d.u1", 1,\
 5, 614, 0)
DeclareAlias2("controller.coreElement.currentControllers.decoupling.flux_to_u_d_coupling.u1",\
 "Connector of Real input signal 1", "controller.coreElement.currentControllers.decoupling.psi_q.y", 1,\
 5, 617, 0)
DeclareAlias2("controller.coreElement.currentControllers.decoupling.flux_to_u_d_coupling.u2",\
 "Connector of Real input signal 2", "controller.coreElement.currentControllers.decoupling.w_el", 1,\
 5, 613, 0)
DeclareAlias2("controller.coreElement.currentControllers.decoupling.flux_to_u_d_coupling.y",\
 "Connector of Real output signal", "controller.coreElement.currentControllers.sum_u_d.u2", 1,\
 5, 602, 0)
DeclareVariable("controller.coreElement.currentControllers.w_el.k", \
"Gain value multiplied with input signal [1]", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("controller.coreElement.currentControllers.w_el.u", \
"Input signal connector", "inertia.w", 1, 1, 15, 0)
DeclareAlias2("controller.coreElement.currentControllers.w_el.y", \
"Output signal connector", "controller.coreElement.currentControllers.decoupling.w_el", 1,\
 5, 613, 0)
DeclareAlias2("controller.coreElement.currentControllers.w_r", "[rad/s|1/min]", \
"inertia.w", 1, 1, 15, 0)
DeclareAlias2("controller.coreElement.currentControllers.theta_r", \
"Rotor Angle [rad|deg]", "machine.angleSensor.phi_rel", 1, 5, 392, 0)
DeclareVariable("controller.coreElement.currentControllers.theta_el.k", \
"Gain value multiplied with input signal [1]", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("controller.coreElement.currentControllers.theta_el.u", \
"Input signal connector", "machine.angleSensor.phi_rel", 1, 5, 392, 0)
DeclareAlias2("controller.coreElement.currentControllers.theta_el.y", \
"Output signal connector", "controller.coreElement.currentControllers.parkTransform.angle", 1,\
 5, 586, 0)
DeclareVariable("controller.coreElement.fieldWeakeningController.fs_nom", \
"Nominal electric frequency [Hz]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.fieldWeakeningController.kp_FW", \
"Gain of field weakening controller", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.fieldWeakeningController.Ti_FW", \
"Integrator Time constant of field weakening controller [s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.fieldWeakeningController.voltageSecurityFactor",\
 "Percentage of the available voltage that is utilized", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("controller.coreElement.fieldWeakeningController.delta_i_d", \
"[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.fieldWeakeningController.u_s_dq[1]", "[V]",\
 "controller.coreElement.actuatingVoltages_dq[1]", 1, 5, 675, 0)
DeclareAlias2("controller.coreElement.fieldWeakeningController.u_s_dq[2]", "[V]",\
 "controller.coreElement.actuatingVoltages_dq[2]", 1, 5, 676, 0)
DeclareVariable("controller.coreElement.fieldWeakeningController.u_s_max", \
"Maximum possible stator voltage [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.u_s",\
 "Connector of setpoint input signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.u_m",\
 "Connector of measurement input signal", "controller.coreElement.fieldWeakeningController.firstOrder.y", 1,\
 1, 5, 0)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.y",\
 "Connector of actuator output signal", "controller.coreElement.fieldWeakeningController.delta_i_d", 1,\
 5, 626, 0)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.controlError",\
 "Control error (set point - measurement)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.controllerType",\
 "Type of controller [:#(type=DymolaModels.Blocks.Choices.PI_Controller)]", 3, \
1.0,3.0,0.0,0,517)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.k",\
 "Gain of controller [1]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.Ti",\
 "Time constant of Integrator block [s]", 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareParameter("controller.coreElement.fieldWeakeningController.fieldWeakeningController.wp",\
 "Set-point weight for Proportional block (0..1)", 83, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("controller.coreElement.fieldWeakeningController.fieldWeakeningController.Ni",\
 "Ni*Ti is time constant of anti-windup compensation", 84, 0.9, 1E-13,1E+100,0.0,\
0,560)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.initType",\
 "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.limitsAtInit",\
 "= false, if limits are ignored during initialization [:#(type=Boolean)]", true,\
 0.0,0.0,0.0,0,515)
DeclareParameter("controller.coreElement.fieldWeakeningController.fieldWeakeningController.xi_start",\
 "Initial or guess value value for integrator output (= integrator state)", 85, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("controller.coreElement.fieldWeakeningController.fieldWeakeningController.y_start",\
 "Initial value of output", 86, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.strict",\
 "= true, if strict limits with noEvent(..) [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.symLimit",\
 "Use symmetric limit, such that yMax=ySym, yMin=-ySym [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.unitTime",\
 "[s]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.gainPI.k",\
 "Gain value multiplied with input signal [1]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.gainPI.u",\
 "Input signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.gainPI.y",\
 "Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addPI.u1",\
 "Connector of Real input signal 1", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addPI.u2",\
 "Connector of Real input signal 2", "controller.coreElement.fieldWeakeningController.fieldWeakeningController.I.y", 1,\
 1, 16, 0)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addPI.y",\
 "Connector of Real output signal", "controller.coreElement.fieldWeakeningController.fieldWeakeningController.gainPI.u", 1,\
 5, 639, 0)
DeclareParameter("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addPI.k1",\
 "Gain of input signal 1", 87, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addPI.k2",\
 "Gain of input signal 2", 88, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.limiter.u",\
 "Connector of Real input signal", "controller.coreElement.fieldWeakeningController.fieldWeakeningController.gainPI.y", 1,\
 5, 640, 0)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.limiter.y",\
 "Connector of Real output signal", "controller.coreElement.fieldWeakeningController.delta_i_d", 1,\
 5, 626, 0)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.limiter.strict",\
 "= true, if strict limits with noEvent(..) [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.limiter.homotopyType",\
 "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.VariableLimiterHomotopy)]",\
 2, 1.0,3.0,0.0,0,517)
DeclareParameter("controller.coreElement.fieldWeakeningController.fieldWeakeningController.limiter.ySimplified",\
 "Fixed value of output in simplified model", 89, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.limiter.limitsAtInit",\
 "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.limiter.limit1",\
 "Connector of Real input signal used as maximum of input u", "controller.coreElement.fieldWeakeningController.delta_i_d_max.k", 1,\
 7, 92, 0)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.limiter.limit2",\
 "Connector of Real input signal used as minimum of input u", "controller.coreElement.fieldWeakeningController.aboveZeroProtection.y", 1,\
 5, 655, 0)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.limiter.simplifiedExpr",\
 "Simplified expression for homotopy-based initialization", "controller.coreElement.fieldWeakeningController.fieldWeakeningController.gainPI.y", 1,\
 5, 640, 1024)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.yMax",\
 "Connector of Real input signal used as maximum of input u", "controller.coreElement.fieldWeakeningController.delta_i_d_max.k", 1,\
 7, 92, 0)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.yMin",\
 "Connector of Real input signal used as minimum of input u", "controller.coreElement.fieldWeakeningController.aboveZeroProtection.y", 1,\
 5, 655, 0)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.with_I",\
 "[:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.with_P",\
 "[:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareParameter("controller.coreElement.fieldWeakeningController.firstOrder.k",\
 "Gain [1]", 90, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("controller.coreElement.fieldWeakeningController.firstOrder.T", \
"Time Constant [s]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.fieldWeakeningController.firstOrder.initType",\
 "Type of initialization (1: no init, 2: steady state, 3/4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("controller.coreElement.fieldWeakeningController.firstOrder.y_start",\
 "Initial or guess value of output (= state)", 91, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("controller.coreElement.fieldWeakeningController.firstOrder.u", \
"Connector of Real input signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("controller.coreElement.fieldWeakeningController.firstOrder.y", \
"Connector of Real output signal", 5, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("controller.coreElement.fieldWeakeningController.firstOrder.der(y)",\
 "der(Connector of Real output signal)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.fieldWeakeningController.voltageUtilization.k",\
 "Gain value multiplied with input signal [1]", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("controller.coreElement.fieldWeakeningController.voltageUtilization.u",\
 "Input signal connector", "controller.coreElement.fieldWeakeningController.u_s_max", 1,\
 5, 627, 0)
DeclareAlias2("controller.coreElement.fieldWeakeningController.voltageUtilization.y",\
 "Output signal connector", "controller.coreElement.fieldWeakeningController.fieldWeakeningController.u_s", 1,\
 5, 628, 0)
DeclareParameter("controller.coreElement.fieldWeakeningController.delta_i_d_max.k",\
 "Constant output value", 92, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.coreElement.fieldWeakeningController.delta_i_d_max.y",\
 "Connector of Real output signal", "controller.coreElement.fieldWeakeningController.delta_i_d_max.k", 1,\
 7, 92, 0)
DeclareVariable("controller.coreElement.fieldWeakeningController.toPolar.n", \
"Number of inputs (= number of outputs) [:#(type=Integer)]", 2, 0.0,0.0,0.0,0,517)
DeclareAlias2("controller.coreElement.fieldWeakeningController.toPolar.u[1]", \
"Connector of Real input signals", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 0)
DeclareAlias2("controller.coreElement.fieldWeakeningController.toPolar.u[2]", \
"Connector of Real input signals", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 0)
DeclareAlias2("controller.coreElement.fieldWeakeningController.toPolar.y[1]", \
"Connector of Real output signals", "controller.coreElement.fieldWeakeningController.firstOrder.u", 1,\
 5, 649, 0)
DeclareVariable("controller.coreElement.fieldWeakeningController.toPolar.y[2]", \
"Connector of Real output signals", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.fieldWeakeningController.toPolar.small",\
 "", 1E-60, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.fieldWeakeningController.i_d_min", \
"Minimum i_d [A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("controller.coreElement.fieldWeakeningController.aboveZeroProtection_source.k",\
 "Constant output value", 93, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.coreElement.fieldWeakeningController.aboveZeroProtection_source.y",\
 "Connector of Real output signal", "controller.coreElement.fieldWeakeningController.aboveZeroProtection_source.k", 1,\
 7, 93, 0)
DeclareAlias2("controller.coreElement.fieldWeakeningController.aboveZeroProtection.u1",\
 "Connector of Real input signal 1", "controller.coreElement.fieldWeakeningController.i_d_min", 1,\
 5, 654, 0)
DeclareAlias2("controller.coreElement.fieldWeakeningController.aboveZeroProtection.u2",\
 "Connector of Real input signal 2", "controller.coreElement.fieldWeakeningController.aboveZeroProtection_source.k", 1,\
 7, 93, 0)
DeclareVariable("controller.coreElement.fieldWeakeningController.aboveZeroProtection.y",\
 "Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.MTPA.Lmd", "Main field inductance d-axis [H]",\
 0.00013, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.MTPA.Lmq", "Main field inductance q-axis [H]",\
 0.00028, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.MTPA.psi_PM", "Flux of the permanent magnet [Wb]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.MTPA.i_s_ref", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.MTPA.i_d_mtpa", "[A]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("controller.coreElement.MTPA.i_q_mtpa", "[A]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("controller.coreElement.limit_i_q.i_s_peak", "Maximum phase current (amplitude) [A]",\
 300, 0.0,0.0,0.0,0,513)
DeclareAlias2("controller.coreElement.limit_i_q.i_q_mtpa", "[A]", \
"controller.coreElement.MTPA.i_q_mtpa", 1, 5, 661, 0)
DeclareAlias2("controller.coreElement.limit_i_q.i_q_ref", "[A]", \
"controller.coreElement.currentControllers.i_q_ref", 1, 5, 585, 0)
DeclareAlias2("controller.coreElement.limit_i_q.i_d_ref", "[A]", \
"controller.coreElement.currentControllers.i_d_ref", 1, 5, 584, 0)
DeclareVariable("controller.coreElement.limit_i_q.variableLimiter.u", \
"Connector of Real input signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.limit_i_q.variableLimiter.y", \
"Connector of Real output signal", "controller.coreElement.currentControllers.i_q_ref", 1,\
 5, 585, 0)
DeclareVariable("controller.coreElement.limit_i_q.variableLimiter.strict", \
"= true, if strict limits with noEvent(..) [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareVariable("controller.coreElement.limit_i_q.variableLimiter.homotopyType",\
 "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.VariableLimiterHomotopy)]",\
 2, 1.0,3.0,0.0,0,517)
DeclareParameter("controller.coreElement.limit_i_q.variableLimiter.ySimplified",\
 "Fixed value of output in simplified model", 94, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("controller.coreElement.limit_i_q.variableLimiter.limitsAtInit",\
 "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("controller.coreElement.limit_i_q.variableLimiter.limit1", \
"Connector of Real input signal used as maximum of input u", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.limit_i_q.variableLimiter.limit2", \
"Connector of Real input signal used as minimum of input u", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.limit_i_q.variableLimiter.simplifiedExpr",\
 "Simplified expression for homotopy-based initialization", "controller.coreElement.limit_i_q.variableLimiter.u", 1,\
 5, 663, 1024)
DeclareVariable("controller.coreElement.limit_i_q.availableCurrent.i_s_peak", \
"Maximum phase current (amplitude) [A]", 300, 0.0,0.0,0.0,0,513)
DeclareAlias2("controller.coreElement.limit_i_q.availableCurrent.y", "[A]", \
"controller.coreElement.limit_i_q.variableLimiter.limit1", 1, 5, 667, 0)
DeclareAlias2("controller.coreElement.limit_i_q.availableCurrent.u", "[A]", \
"controller.coreElement.currentControllers.i_d_ref", 1, 5, 584, 0)
DeclareParameter("controller.coreElement.limit_i_q.changeSign.k", \
"Gain value multiplied with input signal [1]", 95, -1, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.coreElement.limit_i_q.changeSign.u", "Input signal connector",\
 "controller.coreElement.limit_i_q.variableLimiter.limit1", 1, 5, 667, 0)
DeclareAlias2("controller.coreElement.limit_i_q.changeSign.y", "Output signal connector",\
 "controller.coreElement.limit_i_q.variableLimiter.limit2", 1, 5, 668, 0)
DeclareAlias2("controller.coreElement.limit_i_q.variableLimiter1.u", \
"Connector of Real input signal", "controller.coreElement.MTPA.i_q_mtpa", 1, 5, 661,\
 0)
DeclareAlias2("controller.coreElement.limit_i_q.variableLimiter1.y", \
"Connector of Real output signal", "controller.coreElement.limit_i_q.variableLimiter.u", 1,\
 5, 663, 0)
DeclareVariable("controller.coreElement.limit_i_q.variableLimiter1.strict", \
"= true, if strict limits with noEvent(..) [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareVariable("controller.coreElement.limit_i_q.variableLimiter1.homotopyType",\
 "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.VariableLimiterHomotopy)]",\
 2, 1.0,3.0,0.0,0,517)
DeclareParameter("controller.coreElement.limit_i_q.variableLimiter1.ySimplified",\
 "Fixed value of output in simplified model", 96, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("controller.coreElement.limit_i_q.variableLimiter1.limitsAtInit",\
 "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("controller.coreElement.limit_i_q.variableLimiter1.limit1", \
"Connector of Real input signal used as maximum of input u", "controller.coreElement.limit_i_q.i_q_max", 1,\
 5, 674, 0)
DeclareVariable("controller.coreElement.limit_i_q.variableLimiter1.limit2", \
"Connector of Real input signal used as minimum of input u", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.limit_i_q.variableLimiter1.simplifiedExpr",\
 "Simplified expression for homotopy-based initialization", "controller.coreElement.MTPA.i_q_mtpa", 1,\
 5, 661, 1024)
DeclareParameter("controller.coreElement.limit_i_q.changeSign1.k", \
"Gain value multiplied with input signal [1]", 97, -1, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.coreElement.limit_i_q.changeSign1.u", "Input signal connector",\
 "controller.coreElement.limit_i_q.i_q_max", 1, 5, 674, 0)
DeclareAlias2("controller.coreElement.limit_i_q.changeSign1.y", "Output signal connector",\
 "controller.coreElement.limit_i_q.variableLimiter1.limit2", 1, 5, 673, 0)
DeclareVariable("controller.coreElement.limit_i_q.i_q_max", "[A]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("controller.coreElement.reduced_i_d.u1", "Connector of Real input signal 1",\
 "controller.coreElement.MTPA.i_d_mtpa", 1, 5, 660, 0)
DeclareAlias2("controller.coreElement.reduced_i_d.u2", "Connector of Real input signal 2",\
 "controller.coreElement.fieldWeakeningController.delta_i_d", 1, 5, 626, 0)
DeclareAlias2("controller.coreElement.reduced_i_d.y", "Connector of Real output signal",\
 "controller.coreElement.currentControllers.i_d_ref", 1, 5, 584, 0)
DeclareParameter("controller.coreElement.reduced_i_d.k1", "Gain of input signal 1",\
 98, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.coreElement.reduced_i_d.k2", "Gain of input signal 2",\
 99, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.coreElement.actuatingVoltages[1]", "[V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 0)
DeclareAlias2("controller.coreElement.actuatingVoltages[2]", "[V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 0)
DeclareAlias2("controller.coreElement.actuatingVoltages[3]", "[V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 0)
DeclareAlias2("controller.coreElement.shaftSpeed", "[rad/s|1/min]", "inertia.w", 1,\
 1, 15, 0)
DeclareAlias2("controller.coreElement.statorCurrent[1]", "[A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 0)
DeclareAlias2("controller.coreElement.statorCurrent[2]", "[A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 0)
DeclareAlias2("controller.coreElement.statorCurrent[3]", "[A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 0)
DeclareAlias2("controller.coreElement.maxLineVoltage", "[V]", "toBus_maxLineVoltage.u", 1,\
 5, 738, 0)
DeclareVariable("controller.coreElement.actuatingVoltages_dq[1]", "[V]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.actuatingVoltages_dq[2]", "[V]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.mechanicalToElectricSpeed.k", \
"Gain value multiplied with input signal [1]", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("controller.coreElement.mechanicalToElectricSpeed.u", \
"Input signal connector", "inertia.w", 1, 1, 15, 0)
DeclareVariable("controller.coreElement.mechanicalToElectricSpeed.y", \
"Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.currentLimits.Ld", "Inductance d-axis [H]",\
 0.00015, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentLimits.Lq", "Inductance q-axis [H]",\
 0.0003, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentLimits.Rs", "Warm stator resistance [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentLimits.psi_PM", "Flux of the permanent magnet [Wb]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentLimits.i_s_peak", \
"Maximum phase current (amplitude) [A]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentLimits.voltageSecurityFactor", \
"Percentage of the available voltage that is utilized", 0.0, 0.0,1E+100,0.0,0,513)
DeclareAlias2("controller.coreElement.currentLimits.i_s_ref", "[A]", \
"controller.coreElement.MTPA.i_s_ref", 1, 5, 659, 0)
DeclareAlias2("controller.coreElement.currentLimits.w_el", "[rad/s|1/min]", \
"controller.coreElement.mechanicalToElectricSpeed.y", 1, 5, 678, 0)
DeclareVariable("controller.coreElement.currentLimits.u_s_max", "Maximum possible stator voltage [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.currentLimits.i_d_min", "[A]", \
"controller.coreElement.fieldWeakeningController.i_d_min", 1, 5, 654, 0)
DeclareAlias2("controller.coreElement.currentLimits.i_q_max", "[A]", \
"controller.coreElement.limit_i_q.i_q_max", 1, 5, 674, 0)
DeclareVariable("controller.coreElement.currentLimits.i_s_limit", "[A]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.currentLimits.u_field", "Voltage available for the magnetic field [V]",\
 "controller.coreElement.fieldWeakeningController.u_s_max", 1, 5, 627, 0)
DeclareVariable("controller.coreElement.currentLimits.withReluctance.Ld", \
"Inductance d-axis [H]", 0.00015, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentLimits.withReluctance.Lq", \
"Inductance q-axis [H]", 0.0003, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentLimits.withReluctance.Rs", \
"Warm stator resistance [Ohm]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentLimits.withReluctance.psi_PM", \
"Flux of the permanent magnet [Wb]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.currentLimits.withReluctance.i_s_peak", \
"Maximum phase current (amplitude) [A]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("controller.coreElement.currentLimits.withReluctance.voltageSecurityFactor",\
 "Percentage of the available voltage that is utilized", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("controller.coreElement.currentLimits.withReluctance.i_d_min_MTPV",\
 "Lower limit of i_d current for MTPV [A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.currentLimits.withReluctance.i_q_max_MTPV",\
 "Upper and lower limit of i_q current for MTPV [A]", 0.0, 0.0,1E+100,0.0,0,512)
DeclareVariable("controller.coreElement.currentLimits.withReluctance.i_s_max_MTPV",\
 "Maximum allowed stator current magnitude for MTPV [A]", 0.0, 0.0,1E+100,0.0,0,512)
DeclareVariable("controller.coreElement.currentLimits.withReluctance.mode", \
"1: motor mode, 0: generator mode", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.currentLimits.withReluctance.delta_psi",\
 "Auxiliary variable to calculate changes of the flux in d-direction [Wb]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.currentLimits.withReluctance.psi_MTPV", \
"Auxiliary variable for division of u and w_el [Wb]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.currentLimits.withReluctance.i_s_ref", \
"[A]", "controller.coreElement.MTPA.i_s_ref", 1, 5, 659, 0)
DeclareAlias2("controller.coreElement.currentLimits.withReluctance.w_el", \
"[rad/s|1/min]", "controller.coreElement.mechanicalToElectricSpeed.y", 1, 5, 678,\
 0)
DeclareAlias2("controller.coreElement.currentLimits.withReluctance.u_s_max", \
"Maximum allowed stator voltage [V]", "controller.coreElement.currentLimits.u_s_max", 1,\
 5, 685, 0)
DeclareAlias2("controller.coreElement.currentLimits.withReluctance.i_d_min", \
"[A]", "controller.coreElement.fieldWeakeningController.i_d_min", 1, 5, 654, 0)
DeclareAlias2("controller.coreElement.currentLimits.withReluctance.i_q_max", \
"[A]", "controller.coreElement.limit_i_q.i_q_max", 1, 5, 674, 0)
DeclareAlias2("controller.coreElement.currentLimits.withReluctance.i_d_mtpa_ref",\
 "i_d set by MTPA-Block [A]", "controller.coreElement.MTPA.i_d_mtpa", 1, 5, 660,\
 0)
DeclareAlias2("controller.coreElement.currentLimits.withReluctance.i_s_limit", \
"[A]", "controller.coreElement.currentLimits.i_s_limit", 1, 5, 686, 0)
DeclareAlias2("controller.coreElement.currentLimits.withReluctance.u_field", \
"Voltage available for the magnetic field [V]", "controller.coreElement.fieldWeakeningController.u_s_max", 1,\
 5, 627, 0)
DeclareAlias2("controller.coreElement.currentLimits.i_d_mtpa_ref", \
"i_d set by MTPA-Block [A]", "controller.coreElement.MTPA.i_d_mtpa", 1, 5, 660, 0)
DeclareAlias2("controller.coreElement.realPassThrough_current[1].u", \
"Connector of Real input signal", "machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("controller.coreElement.realPassThrough_current[1].y", \
"Connector of Real output signal", "machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("controller.coreElement.realPassThrough_current[2].u", \
"Connector of Real input signal", "machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("controller.coreElement.realPassThrough_current[2].y", \
"Connector of Real output signal", "machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("controller.coreElement.realPassThrough_current[3].u", \
"Connector of Real input signal", "machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareAlias2("controller.coreElement.realPassThrough_current[3].y", \
"Connector of Real output signal", "machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareAlias2("controller.coreElement.realPassThrough_voltages[1].u", \
"Connector of Real input signal", "machine.plug_p.pin[1].v", 1, 5, 34, 0)
DeclareAlias2("controller.coreElement.realPassThrough_voltages[1].y", \
"Connector of Real output signal", "machine.plug_p.pin[1].v", 1, 5, 34, 0)
DeclareAlias2("controller.coreElement.realPassThrough_voltages[2].u", \
"Connector of Real input signal", "machine.plug_p.pin[2].v", 1, 5, 36, 0)
DeclareAlias2("controller.coreElement.realPassThrough_voltages[2].y", \
"Connector of Real output signal", "machine.plug_p.pin[2].v", 1, 5, 36, 0)
DeclareAlias2("controller.coreElement.realPassThrough_voltages[3].u", \
"Connector of Real input signal", "machine.plug_p.pin[3].v", 1, 5, 38, 0)
DeclareAlias2("controller.coreElement.realPassThrough_voltages[3].y", \
"Connector of Real output signal", "machine.plug_p.pin[3].v", 1, 5, 38, 0)
DeclareVariable("controller.coreElement.gain_fromLineVoltage.k", \
"Gain value multiplied with input signal [1]", 0.816496580927726, 0.0,0.0,0.0,0,513)
DeclareAlias2("controller.coreElement.gain_fromLineVoltage.u", "Input signal connector",\
 "toBus_maxLineVoltage.u", 1, 5, 738, 0)
DeclareAlias2("controller.coreElement.gain_fromLineVoltage.y", "Output signal connector",\
 "controller.coreElement.currentLimits.u_s_max", 1, 5, 685, 0)
DeclareAlias2("controller.coreElement.shaftAngle", "[rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 0)
DeclareVariable("controller.coreElement.speedControllerType", "Type of speed controller [:#(type=DymolaModels.Blocks.Choices.PI_Controller)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareVariable("controller.coreElement.kp_w", "Gain of speed controller", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.Ti_w", "Integrator time constant of speed controller [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("controller.coreElement.desiredSpeed", "Connector of Real input signal [rad/s|1/min]",\
 "controller.desiredSpeed", 1, 5, 496, 0)
DeclareAlias2("controller.coreElement.speedController.u_s", "Connector of setpoint input signal",\
 "controller.desiredSpeed", 1, 5, 496, 0)
DeclareAlias2("controller.coreElement.speedController.u_m", "Connector of measurement input signal",\
 "inertia.w", 1, 1, 15, 0)
DeclareAlias2("controller.coreElement.speedController.y", "Connector of actuator output signal",\
 "controller.coreElement.MTPA.i_s_ref", 1, 5, 659, 0)
DeclareVariable("controller.coreElement.speedController.controlError", \
"Control error (set point - measurement)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.speedController.controllerType", \
"Type of controller [:#(type=DymolaModels.Blocks.Choices.PI_Controller)]", 3, \
1.0,3.0,0.0,0,517)
DeclareVariable("controller.coreElement.speedController.k", "Gain of controller [1]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("controller.coreElement.speedController.Ti", "Time constant of Integrator block [s]",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareParameter("controller.coreElement.speedController.wp", "Set-point weight for Proportional block (0..1)",\
 100, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("controller.coreElement.speedController.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 101, 0.9, 1E-13,1E+100,0.0,0,560)
DeclareVariable("controller.coreElement.speedController.initType", \
"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("controller.coreElement.speedController.limitsAtInit", \
"= false, if limits are ignored during initialization [:#(type=Boolean)]", true,\
 0.0,0.0,0.0,0,515)
DeclareParameter("controller.coreElement.speedController.xi_start", \
"Initial or guess value value for integrator output (= integrator state)", 102, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("controller.coreElement.speedController.y_start", \
"Initial value of output", 103, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("controller.coreElement.speedController.strict", \
"= true, if strict limits with noEvent(..) [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareVariable("controller.coreElement.speedController.symLimit", \
"Use symmetric limit, such that yMax=ySym, yMin=-ySym [:#(type=Boolean)]", true,\
 0.0,0.0,0.0,0,515)
DeclareVariable("controller.coreElement.speedController.unitTime", "[s]", 1, \
0.0,0.0,0.0,0,1537)
DeclareVariable("controller.coreElement.speedController.gainPI.k", \
"Gain value multiplied with input signal [1]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.speedController.gainPI.u", \
"Input signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.speedController.gainPI.y", \
"Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.speedController.addPI.u1", \
"Connector of Real input signal 1", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.speedController.addPI.u2", \
"Connector of Real input signal 2", "controller.coreElement.speedController.I.y", 1,\
 1, 17, 0)
DeclareAlias2("controller.coreElement.speedController.addPI.y", "Connector of Real output signal",\
 "controller.coreElement.speedController.gainPI.u", 1, 5, 713, 0)
DeclareParameter("controller.coreElement.speedController.addPI.k1", \
"Gain of input signal 1", 104, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.coreElement.speedController.addPI.k2", \
"Gain of input signal 2", 105, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.coreElement.speedController.limiter.u", \
"Connector of Real input signal", "controller.coreElement.speedController.gainPI.y", 1,\
 5, 714, 0)
DeclareAlias2("controller.coreElement.speedController.limiter.y", \
"Connector of Real output signal", "controller.coreElement.MTPA.i_s_ref", 1, 5, 659,\
 0)
DeclareVariable("controller.coreElement.speedController.limiter.strict", \
"= true, if strict limits with noEvent(..) [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareVariable("controller.coreElement.speedController.limiter.homotopyType", \
"Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.VariableLimiterHomotopy)]",\
 2, 1.0,3.0,0.0,0,517)
DeclareParameter("controller.coreElement.speedController.limiter.ySimplified", \
"Fixed value of output in simplified model", 106, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("controller.coreElement.speedController.limiter.limitsAtInit", \
"Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("controller.coreElement.speedController.limiter.limit1", \
"Connector of Real input signal used as maximum of input u", "controller.coreElement.currentLimits.i_s_limit", 1,\
 5, 686, 0)
DeclareVariable("controller.coreElement.speedController.limiter.limit2", \
"Connector of Real input signal used as minimum of input u", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.speedController.limiter.simplifiedExpr", \
"Simplified expression for homotopy-based initialization", "controller.coreElement.speedController.gainPI.y", 1,\
 5, 714, 1024)
DeclareAlias2("controller.coreElement.speedController.abs.u", "Connector of Real input signal",\
 "controller.coreElement.currentLimits.i_s_limit", 1, 5, 686, 0)
DeclareVariable("controller.coreElement.speedController.abs.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.speedController.abs.generateEvent", \
"Choose whether events shall be generated [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareAlias2("controller.coreElement.speedController.ySym", "Connector of Real input signal used as minimum of input u",\
 "controller.coreElement.currentLimits.i_s_limit", 1, 5, 686, 0)
DeclareParameter("controller.coreElement.speedController.gain.k", \
"Gain value multiplied with input signal [1]", 107, -1, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.coreElement.speedController.gain.u", "Input signal connector",\
 "controller.coreElement.speedController.abs.y", 1, 5, 720, 0)
DeclareAlias2("controller.coreElement.speedController.gain.y", "Output signal connector",\
 "controller.coreElement.speedController.limiter.limit2", 1, 5, 719, 0)
DeclareVariable("controller.coreElement.speedController.with_I", \
"[:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("controller.coreElement.speedController.with_P", \
"[:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareAlias2("controller.fromBus_lineCurrents.y[1]", "Vector with the currents in the three supply lines [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("controller.fromBus_lineCurrents.y[2]", "Vector with the currents in the three supply lines [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("controller.fromBus_lineCurrents.y[3]", "Vector with the currents in the three supply lines [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareAlias2("controller.fromBus_shaftSpeed.y", "Output signal connector [rad/s|1/min]",\
 "inertia.w", 1, 1, 15, 0)
DeclareAlias2("controller.toBus_setVoltageUdUq.u[1]", "Output values for voltage driven inverters in d/q coordinates [V]",\
 "controller.coreElement.actuatingVoltages_dq[1]", 1, 5, 675, 0)
DeclareAlias2("controller.toBus_setVoltageUdUq.u[2]", "Output values for voltage driven inverters in d/q coordinates [V]",\
 "controller.coreElement.actuatingVoltages_dq[2]", 1, 5, 676, 0)
DeclareAlias2("controller.toBus_setVoltageUs.u[1]", "Output values for voltage driven inverters as phase voltages [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 0)
DeclareAlias2("controller.toBus_setVoltageUs.u[2]", "Output values for voltage driven inverters as phase voltages [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 0)
DeclareAlias2("controller.toBus_setVoltageUs.u[3]", "Output values for voltage driven inverters as phase voltages [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 0)
DeclareAlias2("controller.fromBus_maxLineVoltage.y", "Output signal connector [V]",\
 "toBus_maxLineVoltage.u", 1, 5, 738, 0)
DeclareVariable("controller.sampleShaftSpeed.discretize", "false: use sample block; true: pass through [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("controller.sampleShaftSpeed.u", "Connector of continuous-time, Real input signal",\
 "inertia.w", 1, 1, 15, 0)
DeclareAlias2("controller.sampleShaftSpeed.y", "Connector of clocked, Real output signal",\
 "inertia.w", 1, 1, 15, 0)
DeclareAlias2("controller.sampleShaftSpeed.realPassThrough.u", "Connector of Real input signal",\
 "inertia.w", 1, 1, 15, 0)
DeclareAlias2("controller.sampleShaftSpeed.realPassThrough.y", "Connector of Real output signal",\
 "inertia.w", 1, 1, 15, 0)
DeclareVariable("controller.sampleLineCurrents[1].discretize", "false: use sample block; true: pass through [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("controller.sampleLineCurrents[1].u", "Connector of continuous-time, Real input signal",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("controller.sampleLineCurrents[1].y", "Connector of clocked, Real output signal",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("controller.sampleLineCurrents[1].realPassThrough.u", \
"Connector of Real input signal", "machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("controller.sampleLineCurrents[1].realPassThrough.y", \
"Connector of Real output signal", "machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareVariable("controller.sampleLineCurrents[2].discretize", "false: use sample block; true: pass through [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("controller.sampleLineCurrents[2].u", "Connector of continuous-time, Real input signal",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("controller.sampleLineCurrents[2].y", "Connector of clocked, Real output signal",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("controller.sampleLineCurrents[2].realPassThrough.u", \
"Connector of Real input signal", "machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("controller.sampleLineCurrents[2].realPassThrough.y", \
"Connector of Real output signal", "machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareVariable("controller.sampleLineCurrents[3].discretize", "false: use sample block; true: pass through [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("controller.sampleLineCurrents[3].u", "Connector of continuous-time, Real input signal",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareAlias2("controller.sampleLineCurrents[3].y", "Connector of clocked, Real output signal",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareAlias2("controller.sampleLineCurrents[3].realPassThrough.u", \
"Connector of Real input signal", "machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareAlias2("controller.sampleLineCurrents[3].realPassThrough.y", \
"Connector of Real output signal", "machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareVariable("controller.sampleDesiredSpeed.discretize", "false: use sample with clock; true: pass through [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("controller.sampleDesiredSpeed.period", "Period of clock (defined as Real number) [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.sampleDesiredSpeed.useSolver", "= true, if solverMethod shall be explicitly defined [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("controller.sampleDesiredSpeed.u", "Connector of continuous-time, Real input signal",\
 "controller.desiredSpeed", 1, 5, 496, 0)
DeclareAlias2("controller.sampleDesiredSpeed.y", "Connector of clocked, Real output signal",\
 "controller.desiredSpeed", 1, 5, 496, 0)
DeclareAlias2("controller.sampleDesiredSpeed.realPassThrough.u", \
"Connector of Real input signal", "controller.desiredSpeed", 1, 5, 496, 0)
DeclareAlias2("controller.sampleDesiredSpeed.realPassThrough.y", \
"Connector of Real output signal", "controller.desiredSpeed", 1, 5, 496, 0)
DeclareVariable("controller.sampleMaxLineVoltage.discretize", "false: use sample block; true: pass through [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("controller.sampleMaxLineVoltage.u", "Connector of continuous-time, Real input signal",\
 "toBus_maxLineVoltage.u", 1, 5, 738, 0)
DeclareAlias2("controller.sampleMaxLineVoltage.y", "Connector of clocked, Real output signal",\
 "toBus_maxLineVoltage.u", 1, 5, 738, 0)
DeclareAlias2("controller.sampleMaxLineVoltage.realPassThrough.u", \
"Connector of Real input signal", "toBus_maxLineVoltage.u", 1, 5, 738, 0)
DeclareAlias2("controller.sampleMaxLineVoltage.realPassThrough.y", \
"Connector of Real output signal", "toBus_maxLineVoltage.u", 1, 5, 738, 0)
DeclareVariable("controller.holdUdUq[1].discretize", "false: use sample block; true: pass through [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("controller.holdUdUq[1].y_start", "Value of output y before the first tick of the clock associated to input u",\
 108, 0.0, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.holdUdUq[1].u", "Connector of continuous-time, Real input signal",\
 "controller.coreElement.actuatingVoltages_dq[1]", 1, 5, 675, 0)
DeclareAlias2("controller.holdUdUq[1].y", "Connector of clocked, Real output signal",\
 "controller.coreElement.actuatingVoltages_dq[1]", 1, 5, 675, 0)
DeclareAlias2("controller.holdUdUq[1].realPassThrough.u", "Connector of Real input signal",\
 "controller.coreElement.actuatingVoltages_dq[1]", 1, 5, 675, 0)
DeclareAlias2("controller.holdUdUq[1].realPassThrough.y", "Connector of Real output signal",\
 "controller.coreElement.actuatingVoltages_dq[1]", 1, 5, 675, 0)
DeclareVariable("controller.holdUdUq[2].discretize", "false: use sample block; true: pass through [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("controller.holdUdUq[2].y_start", "Value of output y before the first tick of the clock associated to input u",\
 109, 0.0, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.holdUdUq[2].u", "Connector of continuous-time, Real input signal",\
 "controller.coreElement.actuatingVoltages_dq[2]", 1, 5, 676, 0)
DeclareAlias2("controller.holdUdUq[2].y", "Connector of clocked, Real output signal",\
 "controller.coreElement.actuatingVoltages_dq[2]", 1, 5, 676, 0)
DeclareAlias2("controller.holdUdUq[2].realPassThrough.u", "Connector of Real input signal",\
 "controller.coreElement.actuatingVoltages_dq[2]", 1, 5, 676, 0)
DeclareAlias2("controller.holdUdUq[2].realPassThrough.y", "Connector of Real output signal",\
 "controller.coreElement.actuatingVoltages_dq[2]", 1, 5, 676, 0)
DeclareVariable("controller.holdUs[1].discretize", "false: use sample block; true: pass through [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("controller.holdUs[1].y_start", "Value of output y before the first tick of the clock associated to input u",\
 110, 0.0, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.holdUs[1].u", "Connector of continuous-time, Real input signal",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 0)
DeclareAlias2("controller.holdUs[1].y", "Connector of clocked, Real output signal",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 0)
DeclareAlias2("controller.holdUs[1].realPassThrough.u", "Connector of Real input signal",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 0)
DeclareAlias2("controller.holdUs[1].realPassThrough.y", "Connector of Real output signal",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 0)
DeclareVariable("controller.holdUs[2].discretize", "false: use sample block; true: pass through [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("controller.holdUs[2].y_start", "Value of output y before the first tick of the clock associated to input u",\
 111, 0.0, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.holdUs[2].u", "Connector of continuous-time, Real input signal",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 0)
DeclareAlias2("controller.holdUs[2].y", "Connector of clocked, Real output signal",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 0)
DeclareAlias2("controller.holdUs[2].realPassThrough.u", "Connector of Real input signal",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 0)
DeclareAlias2("controller.holdUs[2].realPassThrough.y", "Connector of Real output signal",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 0)
DeclareVariable("controller.holdUs[3].discretize", "false: use sample block; true: pass through [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("controller.holdUs[3].y_start", "Value of output y before the first tick of the clock associated to input u",\
 112, 0.0, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.holdUs[3].u", "Connector of continuous-time, Real input signal",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 0)
DeclareAlias2("controller.holdUs[3].y", "Connector of clocked, Real output signal",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 0)
DeclareAlias2("controller.holdUs[3].realPassThrough.u", "Connector of Real input signal",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 0)
DeclareAlias2("controller.holdUs[3].realPassThrough.y", "Connector of Real output signal",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 0)
DeclareAlias2("controller.fromBus_shaftAngle.y", "Output signal connector [rad|deg]",\
 "machine.angleSensor.phi_rel", 1, 5, 392, 0)
DeclareVariable("controller.sampleShaftAngle.discretize", "false: use sample block; true: pass through [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("controller.sampleShaftAngle.u", "Connector of continuous-time, Real input signal",\
 "machine.angleSensor.phi_rel", 1, 5, 392, 0)
DeclareAlias2("controller.sampleShaftAngle.y", "Connector of clocked, Real output signal",\
 "machine.angleSensor.phi_rel", 1, 5, 392, 0)
DeclareAlias2("controller.sampleShaftAngle.realPassThrough.u", "Connector of Real input signal",\
 "machine.angleSensor.phi_rel", 1, 5, 392, 0)
DeclareAlias2("controller.sampleShaftAngle.realPassThrough.y", "Connector of Real output signal",\
 "machine.angleSensor.phi_rel", 1, 5, 392, 0)
DeclareVariable("toBus_maxLineVoltage.u", "Maximum voltage that is possible at the machine's terminal [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("maxLineVoltage.height", "Height of ramps", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("maxLineVoltage.duration", "Duration of ramp (= 0.0 gives a Step) [s|s]",\
 113, 1.5, 0.0,1E+100,0.0,0,560)
DeclareAlias2("maxLineVoltage.y", "Connector of Real output signal", \
"toBus_maxLineVoltage.u", 1, 5, 738, 0)
DeclareVariable("maxLineVoltage.offset", "Offset of output signal y", 0.0, \
0.0,0.0,0.0,0,513)
DeclareParameter("maxLineVoltage.startTime", "Output y = offset for time < startTime [s|s]",\
 114, 2.5, 0.0,0.0,0.0,0,560)
DeclareVariable("desiredSpeed.height", "Height of ramps", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("desiredSpeed.duration", "Duration of ramp (= 0.0 gives a Step) [s|s]",\
 115, 5, 0.0,1E+100,0.0,0,560)
DeclareAlias2("desiredSpeed.y", "Connector of Real output signal", \
"controller.desiredSpeed", 1, 5, 496, 0)
DeclareParameter("desiredSpeed.offset", "Offset of output signal y", 116, 0, \
0.0,0.0,0.0,0,560)
DeclareParameter("desiredSpeed.startTime", "Output y = offset for time < startTime [s|s]",\
 117, 0.2, 0.0,0.0,0.0,0,560)
DeclareVariable("machineEfficiencyComputation.useAveraging", "true: Input powers will be averaged, false: instantaneous values will be used [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("machineEfficiencyComputation.f", "Base frequency for input averaging [Hz]",\
 118, 100, 0.0,0.0,0.0,0,560)
DeclareVariable("machineEfficiencyComputation.powerEfficiencyLimited", "[1]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machineEfficiencyComputation.powerEfficiency", "[1]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("machineEfficiencyComputation.energyEfficiency", "[1]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("machineEfficiencyComputation.motorEnergyEfficiency", "[1]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("machineEfficiencyComputation.generatorEnergyEfficiency", "[1]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machineEfficiencyComputation.consumedEnergy", "[J]", \
"machineEfficiencyComputation.consumedEnergyComp.y", 1, 1, 14, 0)
DeclareAlias2("machineEfficiencyComputation.generatedEnergy", "[J]", \
"machineEfficiencyComputation.generatedEnergyComp.y", 1, 1, 13, 0)
DeclareAlias2("machineEfficiencyComputation.lossEnergy", "[J]", "machineEfficiencyComputation.lossEnergyComp.y", 1,\
 1, 12, 0)
DeclareAlias2("machineEfficiencyComputation.consumedElectricEnergy", "[J]", \
"machineEfficiencyComputation.consumedElectricEnergyComp.y", 1, 1, 8, 0)
DeclareAlias2("machineEfficiencyComputation.generatedElectricEnergy", "[J]", \
"machineEfficiencyComputation.generatedElectricEnergyComp.y", 1, 1, 9, 0)
DeclareAlias2("machineEfficiencyComputation.consumedMechanicEnergy", "[J]", \
"machineEfficiencyComputation.consumedMechanicEnergyComp.y", 1, 1, 10, 0)
DeclareAlias2("machineEfficiencyComputation.generatedMechanicEnergy", "[J]", \
"machineEfficiencyComputation.generatedMechanicEnergyComp.y", 1, 1, 11, 0)
DeclareAlias2("machineEfficiencyComputation.generatedElectricPower.u1", \
"Connector of Real input signal 1", "machine.quasiPowerSensor.P", 1, 5, 449, 0)
DeclareAlias2("machineEfficiencyComputation.generatedElectricPower.u2", \
"Connector of Real input signal 2", "machineEfficiencyComputation.zero3.k", 1, 7,\
 153, 0)
DeclareVariable("machineEfficiencyComputation.generatedElectricPower.y", \
"Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machineEfficiencyComputation.consumedElectricPower.u1", \
"Connector of Real input signal 1", "machine.quasiPowerSensor.P", 1, 5, 449, 0)
DeclareAlias2("machineEfficiencyComputation.consumedElectricPower.u2", \
"Connector of Real input signal 2", "machineEfficiencyComputation.zero3.k", 1, 7,\
 153, 0)
DeclareVariable("machineEfficiencyComputation.consumedElectricPower.y", \
"Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machineEfficiencyComputation.generatedMechanicPower.u1", \
"Connector of Real input signal 1", "machineEfficiencyComputation.zero4.k", 1, 7,\
 154, 0)
DeclareAlias2("machineEfficiencyComputation.generatedMechanicPower.u2", \
"Connector of Real input signal 2", "machine.innerPower.y", 1, 5, 397, 0)
DeclareVariable("machineEfficiencyComputation.generatedMechanicPower.y", \
"Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machineEfficiencyComputation.consumedMechanicPower.u1", \
"Connector of Real input signal 1", "machine.innerPower.y", 1, 5, 397, 0)
DeclareAlias2("machineEfficiencyComputation.consumedMechanicPower.u2", \
"Connector of Real input signal 2", "machineEfficiencyComputation.zero4.k", 1, 7,\
 154, 0)
DeclareVariable("machineEfficiencyComputation.consumedMechanicPower.y", \
"Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machineEfficiencyComputation.motorLosses.u1", "Connector of Real input signal 1",\
 "machineEfficiencyComputation.consumedElectricPower.y", 1, 5, 749, 0)
DeclareVariable("machineEfficiencyComputation.motorLosses.u2", "Connector of Real input signal 2",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machineEfficiencyComputation.motorLosses.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("machineEfficiencyComputation.motorLosses.k1", "Gain of input signal 1",\
 119, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("machineEfficiencyComputation.motorLosses.k2", "Gain of input signal 2",\
 120, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("machineEfficiencyComputation.generatorLosses.u1", \
"Connector of Real input signal 1", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machineEfficiencyComputation.generatorLosses.u2", \
"Connector of Real input signal 2", "machineEfficiencyComputation.consumedMechanicPower.y", 1,\
 5, 751, 0)
DeclareVariable("machineEfficiencyComputation.generatorLosses.y", \
"Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("machineEfficiencyComputation.generatorLosses.k1", \
"Gain of input signal 1", 121, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("machineEfficiencyComputation.generatorLosses.k2", \
"Gain of input signal 2", 122, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("machineEfficiencyComputation.electricEnergy.k", \
"Integrator gain [1]", 123, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("machineEfficiencyComputation.electricEnergy.use_reset", \
"=true, if reset port enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.electricEnergy.use_set", \
"=true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.electricEnergy.initType", \
"Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("machineEfficiencyComputation.electricEnergy.y_start", \
"Initial or guess value of output (= state)", 124, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("machineEfficiencyComputation.electricEnergy.u", "Connector of Real input signal",\
 "machine.quasiPowerSensor.P", 1, 5, 449, 0)
DeclareState("machineEfficiencyComputation.electricEnergy.y", "Connector of Real output signal",\
 6, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("machineEfficiencyComputation.electricEnergy.der(y)", \
"der(Connector of Real output signal)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machineEfficiencyComputation.electricEnergy.local_reset", \
"[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.electricEnergy.local_set", "", 0, \
0.0,0.0,0.0,0,1537)
DeclareParameter("machineEfficiencyComputation.mechanicEnergy.k", \
"Integrator gain [1]", 125, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("machineEfficiencyComputation.mechanicEnergy.use_reset", \
"=true, if reset port enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.mechanicEnergy.use_set", \
"=true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.mechanicEnergy.initType", \
"Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("machineEfficiencyComputation.mechanicEnergy.y_start", \
"Initial or guess value of output (= state)", 126, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("machineEfficiencyComputation.mechanicEnergy.u", "Connector of Real input signal",\
 "machine.innerPower.y", 1, 5, 397, 0)
DeclareState("machineEfficiencyComputation.mechanicEnergy.y", "Connector of Real output signal",\
 7, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("machineEfficiencyComputation.mechanicEnergy.der(y)", \
"der(Connector of Real output signal)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("machineEfficiencyComputation.mechanicEnergy.local_reset", \
"[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.mechanicEnergy.local_set", "", 0, \
0.0,0.0,0.0,0,1537)
DeclareParameter("machineEfficiencyComputation.limiter.uMax", "Upper limits of input signals",\
 127, 1.1, 0.0,0.0,0.0,0,2608)
DeclareParameter("machineEfficiencyComputation.limiter.uMin", "Lower limits of input signals",\
 128, 0, 0.0,0.0,0.0,0,2608)
DeclareVariable("machineEfficiencyComputation.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("machineEfficiencyComputation.limiter.homotopyType", \
"Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,2565)
DeclareVariable("machineEfficiencyComputation.limiter.limitsAtInit", \
"Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("machineEfficiencyComputation.limiter.u", "Connector of Real input signal",\
 "machineEfficiencyComputation.powerEfficiency", 1, 5, 744, 1024)
DeclareAlias2("machineEfficiencyComputation.limiter.y", "Connector of Real output signal",\
 "machineEfficiencyComputation.powerEfficiencyLimited", 1, 5, 743, 1024)
DeclareAlias2("machineEfficiencyComputation.limiter.simplifiedExpr", \
"Simplified expression for homotopy-based initialization", "machineEfficiencyComputation.powerEfficiency", 1,\
 5, 744, 1024)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerPassThrough.u", \
"Connector of Real input signal", "machine.innerPower.y", 1, 5, 397, 1024)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerPassThrough.y", \
"Connector of Real output signal", "machine.innerPower.y", 1, 5, 397, 1024)
DeclareAlias2("machineEfficiencyComputation.electricPowerPassThrough.u", \
"Connector of Real input signal", "machine.quasiPowerSensor.P", 1, 5, 449, 1024)
DeclareAlias2("machineEfficiencyComputation.electricPowerPassThrough.y", \
"Connector of Real output signal", "machine.quasiPowerSensor.P", 1, 5, 449, 1024)
DeclareAlias2("machineEfficiencyComputation.losses.u1", "Connector of Real input signal 1",\
 "machineEfficiencyComputation.motorLosses.y", 1, 5, 753, 1024)
DeclareAlias2("machineEfficiencyComputation.losses.u2", "Connector of Real input signal 2",\
 "machineEfficiencyComputation.generatorLosses.y", 1, 5, 755, 1024)
DeclareVariable("machineEfficiencyComputation.losses.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareParameter("machineEfficiencyComputation.losses.k1", "Gain of input signal 1",\
 129, 1, 0.0,0.0,0.0,0,2608)
DeclareParameter("machineEfficiencyComputation.losses.k2", "Gain of input signal 2",\
 130, 1, 0.0,0.0,0.0,0,2608)
DeclareParameter("machineEfficiencyComputation.consumedElectricEnergyComp.k", \
"Integrator gain [1]", 131, 1, 0.0,0.0,0.0,0,2608)
DeclareVariable("machineEfficiencyComputation.consumedElectricEnergyComp.use_reset",\
 "=true, if reset port enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.consumedElectricEnergyComp.use_set",\
 "=true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.consumedElectricEnergyComp.initType",\
 "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,2565)
DeclareParameter("machineEfficiencyComputation.consumedElectricEnergyComp.y_start",\
 "Initial or guess value of output (= state)", 132, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("machineEfficiencyComputation.consumedElectricEnergyComp.u", \
"Connector of Real input signal", "machineEfficiencyComputation.consumedElectricPower.y", 1,\
 5, 749, 1024)
DeclareState("machineEfficiencyComputation.consumedElectricEnergyComp.y", \
"Connector of Real output signal", 8, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("machineEfficiencyComputation.consumedElectricEnergyComp.der(y)",\
 "der(Connector of Real output signal)", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("machineEfficiencyComputation.consumedElectricEnergyComp.local_reset",\
 "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.consumedElectricEnergyComp.local_set",\
 "", 0, 0.0,0.0,0.0,0,1537)
DeclareParameter("machineEfficiencyComputation.generatedElectricEnergyComp.k", \
"Integrator gain [1]", 133, 1, 0.0,0.0,0.0,0,2608)
DeclareVariable("machineEfficiencyComputation.generatedElectricEnergyComp.use_reset",\
 "=true, if reset port enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.generatedElectricEnergyComp.use_set",\
 "=true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.generatedElectricEnergyComp.initType",\
 "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,2565)
DeclareParameter("machineEfficiencyComputation.generatedElectricEnergyComp.y_start",\
 "Initial or guess value of output (= state)", 134, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("machineEfficiencyComputation.generatedElectricEnergyComp.u", \
"Connector of Real input signal", "machineEfficiencyComputation.generatorLosses.u1", 1,\
 5, 754, 1024)
DeclareState("machineEfficiencyComputation.generatedElectricEnergyComp.y", \
"Connector of Real output signal", 9, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("machineEfficiencyComputation.generatedElectricEnergyComp.der(y)",\
 "der(Connector of Real output signal)", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("machineEfficiencyComputation.generatedElectricEnergyComp.local_reset",\
 "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.generatedElectricEnergyComp.local_set",\
 "", 0, 0.0,0.0,0.0,0,1537)
DeclareParameter("machineEfficiencyComputation.consumedMechanicEnergyComp.k", \
"Integrator gain [1]", 135, 1, 0.0,0.0,0.0,0,2608)
DeclareVariable("machineEfficiencyComputation.consumedMechanicEnergyComp.use_reset",\
 "=true, if reset port enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.consumedMechanicEnergyComp.use_set",\
 "=true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.consumedMechanicEnergyComp.initType",\
 "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,2565)
DeclareParameter("machineEfficiencyComputation.consumedMechanicEnergyComp.y_start",\
 "Initial or guess value of output (= state)", 136, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("machineEfficiencyComputation.consumedMechanicEnergyComp.u", \
"Connector of Real input signal", "machineEfficiencyComputation.consumedMechanicPower.y", 1,\
 5, 751, 1024)
DeclareState("machineEfficiencyComputation.consumedMechanicEnergyComp.y", \
"Connector of Real output signal", 10, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("machineEfficiencyComputation.consumedMechanicEnergyComp.der(y)",\
 "der(Connector of Real output signal)", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("machineEfficiencyComputation.consumedMechanicEnergyComp.local_reset",\
 "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.consumedMechanicEnergyComp.local_set",\
 "", 0, 0.0,0.0,0.0,0,1537)
DeclareParameter("machineEfficiencyComputation.generatedMechanicEnergyComp.k", \
"Integrator gain [1]", 137, 1, 0.0,0.0,0.0,0,2608)
DeclareVariable("machineEfficiencyComputation.generatedMechanicEnergyComp.use_reset",\
 "=true, if reset port enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.generatedMechanicEnergyComp.use_set",\
 "=true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.generatedMechanicEnergyComp.initType",\
 "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,2565)
DeclareParameter("machineEfficiencyComputation.generatedMechanicEnergyComp.y_start",\
 "Initial or guess value of output (= state)", 138, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("machineEfficiencyComputation.generatedMechanicEnergyComp.u", \
"Connector of Real input signal", "machineEfficiencyComputation.motorLosses.u2", 1,\
 5, 752, 1024)
DeclareState("machineEfficiencyComputation.generatedMechanicEnergyComp.y", \
"Connector of Real output signal", 11, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("machineEfficiencyComputation.generatedMechanicEnergyComp.der(y)",\
 "der(Connector of Real output signal)", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("machineEfficiencyComputation.generatedMechanicEnergyComp.local_reset",\
 "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.generatedMechanicEnergyComp.local_set",\
 "", 0, 0.0,0.0,0.0,0,1537)
DeclareParameter("machineEfficiencyComputation.lossEnergyComp.k", \
"Integrator gain [1]", 139, 1, 0.0,0.0,0.0,0,2608)
DeclareVariable("machineEfficiencyComputation.lossEnergyComp.use_reset", \
"=true, if reset port enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.lossEnergyComp.use_set", \
"=true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.lossEnergyComp.initType", \
"Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,2565)
DeclareParameter("machineEfficiencyComputation.lossEnergyComp.y_start", \
"Initial or guess value of output (= state)", 140, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("machineEfficiencyComputation.lossEnergyComp.u", "Connector of Real input signal",\
 "machineEfficiencyComputation.losses.y", 1, 5, 769, 1024)
DeclareState("machineEfficiencyComputation.lossEnergyComp.y", "Connector of Real output signal",\
 12, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("machineEfficiencyComputation.lossEnergyComp.der(y)", \
"der(Connector of Real output signal)", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("machineEfficiencyComputation.lossEnergyComp.local_reset", \
"[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.lossEnergyComp.local_set", "", 0, \
0.0,0.0,0.0,0,1537)
DeclareVariable("machineEfficiencyComputation.powerEfficiencyComp.u1", \
"Connector of Real input signal 1", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("machineEfficiencyComputation.powerEfficiencyComp.u2", \
"Connector of Real input signal 2", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("machineEfficiencyComputation.powerEfficiencyComp.y", \
"Connector of Real output signal", "machineEfficiencyComputation.powerEfficiency", 1,\
 5, 744, 1024)
DeclareVariable("machineEfficiencyComputation.powerEfficiencyComp.eps", \
"Smallest value used for division", 1E-60, 1E-60,1E+100,0.0,0,2561)
DeclareVariable("machineEfficiencyComputation.powerEfficiencyComp.considerSign",\
 "True: sign is considered in case of 'b' < 'eps' [:#(type=Boolean)]", true, \
0.0,0.0,0.0,0,2563)
DeclareVariable("machineEfficiencyComputation.powerEfficiencyComp.action", \
"Optionally inform about divisions by zero with asserts [:#(type=DymolaModels.Blocks.Choices.AssertActions)]",\
 1, 1.0,3.0,0.0,0,2565)
DeclareAlias2("machineEfficiencyComputation.consumedPower.u1", "Connector of Real input signal 1",\
 "machine.innerPower.y", 1, 5, 397, 1024)
DeclareAlias2("machineEfficiencyComputation.consumedPower.u2", "Connector of Real input signal 2",\
 "machine.quasiPowerSensor.P", 1, 5, 449, 1024)
DeclareVariable("machineEfficiencyComputation.consumedPower.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("machineEfficiencyComputation.generatedPower.u1", "Connector of Real input signal 1",\
 "machine.innerPower.y", 1, 5, 397, 1024)
DeclareAlias2("machineEfficiencyComputation.generatedPower.u2", "Connector of Real input signal 2",\
 "machine.quasiPowerSensor.P", 1, 5, 449, 1024)
DeclareVariable("machineEfficiencyComputation.generatedPower.y", \
"Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,2560)
DeclareParameter("machineEfficiencyComputation.generatedEnergyComp.k", \
"Integrator gain [1]", 141, 1, 0.0,0.0,0.0,0,2608)
DeclareVariable("machineEfficiencyComputation.generatedEnergyComp.use_reset", \
"=true, if reset port enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.generatedEnergyComp.use_set", \
"=true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.generatedEnergyComp.initType", \
"Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,2565)
DeclareParameter("machineEfficiencyComputation.generatedEnergyComp.y_start", \
"Initial or guess value of output (= state)", 142, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("machineEfficiencyComputation.generatedEnergyComp.u", \
"Connector of Real input signal", "machineEfficiencyComputation.powerEfficiencyComp.u1", 1,\
 5, 795, 1024)
DeclareState("machineEfficiencyComputation.generatedEnergyComp.y", \
"Connector of Real output signal", 13, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("machineEfficiencyComputation.generatedEnergyComp.der(y)", \
"der(Connector of Real output signal)", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("machineEfficiencyComputation.generatedEnergyComp.local_reset", \
"[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.generatedEnergyComp.local_set", "",\
 0, 0.0,0.0,0.0,0,1537)
DeclareParameter("machineEfficiencyComputation.consumedEnergyComp.k", \
"Integrator gain [1]", 143, 1, 0.0,0.0,0.0,0,2608)
DeclareVariable("machineEfficiencyComputation.consumedEnergyComp.use_reset", \
"=true, if reset port enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.consumedEnergyComp.use_set", \
"=true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.consumedEnergyComp.initType", \
"Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,2565)
DeclareParameter("machineEfficiencyComputation.consumedEnergyComp.y_start", \
"Initial or guess value of output (= state)", 144, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("machineEfficiencyComputation.consumedEnergyComp.u", \
"Connector of Real input signal", "machineEfficiencyComputation.powerEfficiencyComp.u2", 1,\
 5, 796, 1024)
DeclareState("machineEfficiencyComputation.consumedEnergyComp.y", \
"Connector of Real output signal", 14, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("machineEfficiencyComputation.consumedEnergyComp.der(y)", \
"der(Connector of Real output signal)", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("machineEfficiencyComputation.consumedEnergyComp.local_reset", \
"[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machineEfficiencyComputation.consumedEnergyComp.local_set", "",\
 0, 0.0,0.0,0.0,0,1537)
DeclareAlias2("machineEfficiencyComputation.energyEfficiencyComp.u1", \
"Connector of Real input signal 1", "machineEfficiencyComputation.generatedEnergyComp.y", 1,\
 1, 13, 1024)
DeclareAlias2("machineEfficiencyComputation.energyEfficiencyComp.u2", \
"Connector of Real input signal 2", "machineEfficiencyComputation.consumedEnergyComp.y", 1,\
 1, 14, 1024)
DeclareAlias2("machineEfficiencyComputation.energyEfficiencyComp.y", \
"Connector of Real output signal", "machineEfficiencyComputation.energyEfficiency", 1,\
 5, 745, 1024)
DeclareVariable("machineEfficiencyComputation.energyEfficiencyComp.eps", \
"Smallest value used for division", 1E-60, 1E-60,1E+100,0.0,0,2561)
DeclareVariable("machineEfficiencyComputation.energyEfficiencyComp.considerSign",\
 "True: sign is considered in case of 'b' < 'eps' [:#(type=Boolean)]", true, \
0.0,0.0,0.0,0,2563)
DeclareVariable("machineEfficiencyComputation.energyEfficiencyComp.action", \
"Optionally inform about divisions by zero with asserts [:#(type=DymolaModels.Blocks.Choices.AssertActions)]",\
 1, 1.0,3.0,0.0,0,2565)
DeclareAlias2("machineEfficiencyComputation.motorEnergyEfficiencyComp.u1", \
"Connector of Real input signal 1", "machineEfficiencyComputation.generatedMechanicEnergyComp.y", 1,\
 1, 11, 1024)
DeclareAlias2("machineEfficiencyComputation.motorEnergyEfficiencyComp.u2", \
"Connector of Real input signal 2", "machineEfficiencyComputation.consumedElectricEnergyComp.y", 1,\
 1, 8, 1024)
DeclareAlias2("machineEfficiencyComputation.motorEnergyEfficiencyComp.y", \
"Connector of Real output signal", "machineEfficiencyComputation.motorEnergyEfficiency", 1,\
 5, 746, 1024)
DeclareVariable("machineEfficiencyComputation.motorEnergyEfficiencyComp.eps", \
"Smallest value used for division", 1E-60, 1E-60,1E+100,0.0,0,2561)
DeclareVariable("machineEfficiencyComputation.motorEnergyEfficiencyComp.considerSign",\
 "True: sign is considered in case of 'b' < 'eps' [:#(type=Boolean)]", true, \
0.0,0.0,0.0,0,2563)
DeclareVariable("machineEfficiencyComputation.motorEnergyEfficiencyComp.action",\
 "Optionally inform about divisions by zero with asserts [:#(type=DymolaModels.Blocks.Choices.AssertActions)]",\
 1, 1.0,3.0,0.0,0,2565)
DeclareAlias2("machineEfficiencyComputation.generatorEnergyEfficiencyComp.u1", \
"Connector of Real input signal 1", "machineEfficiencyComputation.generatedElectricEnergyComp.y", 1,\
 1, 9, 1024)
DeclareAlias2("machineEfficiencyComputation.generatorEnergyEfficiencyComp.u2", \
"Connector of Real input signal 2", "machineEfficiencyComputation.consumedMechanicEnergyComp.y", 1,\
 1, 10, 1024)
DeclareAlias2("machineEfficiencyComputation.generatorEnergyEfficiencyComp.y", \
"Connector of Real output signal", "machineEfficiencyComputation.generatorEnergyEfficiency", 1,\
 5, 747, 1024)
DeclareVariable("machineEfficiencyComputation.generatorEnergyEfficiencyComp.eps",\
 "Smallest value used for division", 1E-60, 1E-60,1E+100,0.0,0,2561)
DeclareVariable("machineEfficiencyComputation.generatorEnergyEfficiencyComp.considerSign",\
 "True: sign is considered in case of 'b' < 'eps' [:#(type=Boolean)]", true, \
0.0,0.0,0.0,0,2563)
DeclareVariable("machineEfficiencyComputation.generatorEnergyEfficiencyComp.action",\
 "Optionally inform about divisions by zero with asserts [:#(type=DymolaModels.Blocks.Choices.AssertActions)]",\
 1, 1.0,3.0,0.0,0,2565)
DeclareParameter("machineEfficiencyComputation.signChange.k", "Gain value multiplied with input signal [1]",\
 145, -1, 0.0,0.0,0.0,0,2608)
DeclareVariable("machineEfficiencyComputation.signChange.u", "Input signal connector",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("machineEfficiencyComputation.signChange.y", "Output signal connector",\
 "machineEfficiencyComputation.powerEfficiencyComp.u1", 1, 5, 795, 1024)
DeclareParameter("machineEfficiencyComputation.signChangeElectric.k", \
"Gain value multiplied with input signal [1]", 146, -1, 0.0,0.0,0.0,0,2608)
DeclareAlias2("machineEfficiencyComputation.signChangeElectric.u", \
"Input signal connector", "machineEfficiencyComputation.generatedElectricPower.y", 1,\
 5, 748, 1024)
DeclareAlias2("machineEfficiencyComputation.signChangeElectric.y", \
"Output signal connector", "machineEfficiencyComputation.generatorLosses.u1", 1,\
 5, 754, 1024)
DeclareParameter("machineEfficiencyComputation.signChangeMechanic.k", \
"Gain value multiplied with input signal [1]", 147, -1, 0.0,0.0,0.0,0,2608)
DeclareAlias2("machineEfficiencyComputation.signChangeMechanic.u", \
"Input signal connector", "machineEfficiencyComputation.generatedMechanicPower.y", 1,\
 5, 750, 1024)
DeclareAlias2("machineEfficiencyComputation.signChangeMechanic.y", \
"Output signal connector", "machineEfficiencyComputation.motorLosses.u2", 1, 5, 752,\
 1024)
DeclareAlias2("machineEfficiencyComputation.noNegativeGeneratedPower.u1", \
"Connector of Real input signal 1", "machineEfficiencyComputation.generatedPower.y", 1,\
 5, 801, 1024)
DeclareAlias2("machineEfficiencyComputation.noNegativeGeneratedPower.u2", \
"Connector of Real input signal 2", "machineEfficiencyComputation.zero2.k", 1, 7,\
 152, 1024)
DeclareAlias2("machineEfficiencyComputation.noNegativeGeneratedPower.y", \
"Connector of Real output signal", "machineEfficiencyComputation.signChange.u", 1,\
 5, 821, 1024)
DeclareAlias2("machineEfficiencyComputation.additionalConsumedPower.u1", \
"Connector of Real input signal 1", "machineEfficiencyComputation.signChange.u", 1,\
 5, 821, 1024)
DeclareAlias2("machineEfficiencyComputation.additionalConsumedPower.u2", \
"Connector of Real input signal 2", "machineEfficiencyComputation.generatedPower.y", 1,\
 5, 801, 1024)
DeclareVariable("machineEfficiencyComputation.additionalConsumedPower.y", \
"Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,2560)
DeclareParameter("machineEfficiencyComputation.additionalConsumedPower.k1", \
"Gain of input signal 1", 148, -1, 0.0,0.0,0.0,0,2608)
DeclareParameter("machineEfficiencyComputation.additionalConsumedPower.k2", \
"Gain of input signal 2", 149, 1, 0.0,0.0,0.0,0,2608)
DeclareAlias2("machineEfficiencyComputation.overallConsumedPower.u1", \
"Connector of Real input signal 1", "machineEfficiencyComputation.additionalConsumedPower.y", 1,\
 5, 822, 1024)
DeclareAlias2("machineEfficiencyComputation.overallConsumedPower.u2", \
"Connector of Real input signal 2", "machineEfficiencyComputation.consumedPower.y", 1,\
 5, 800, 1024)
DeclareAlias2("machineEfficiencyComputation.overallConsumedPower.y", \
"Connector of Real output signal", "machineEfficiencyComputation.powerEfficiencyComp.u2", 1,\
 5, 796, 1024)
DeclareParameter("machineEfficiencyComputation.overallConsumedPower.k1", \
"Gain of input signal 1", 150, 1, 0.0,0.0,0.0,0,2608)
DeclareParameter("machineEfficiencyComputation.overallConsumedPower.k2", \
"Gain of input signal 2", 151, 1, 0.0,0.0,0.0,0,2608)
DeclareParameter("machineEfficiencyComputation.zero2.k", "Constant output value",\
 152, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("machineEfficiencyComputation.zero2.y", "Connector of Real output signal",\
 "machineEfficiencyComputation.zero2.k", 1, 7, 152, 1024)
DeclareParameter("machineEfficiencyComputation.zero3.k", "Constant output value",\
 153, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("machineEfficiencyComputation.zero3.y", "Connector of Real output signal",\
 "machineEfficiencyComputation.zero3.k", 1, 7, 153, 1024)
DeclareParameter("machineEfficiencyComputation.zero4.k", "Constant output value",\
 154, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("machineEfficiencyComputation.zero4.y", "Connector of Real output signal",\
 "machineEfficiencyComputation.zero4.k", 1, 7, 154, 1024)
DeclareVariable("machineEfficiencyComputation.withBus", "[:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,2563)
DeclareVariable("machineEfficiencyComputation.useBusConnector", "True: Bus connector will be active, false: real inputs will be active [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.y", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 0)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.y", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 0)
DeclareVariable("signals.terminalConnection", "Choose if the machine is Y=star or /D=delta wired [:#(type=DymolaModels.Electrical.MultiPhase.Choices.Wiring)]",\
 1, 1.0,2.0,0.0,0,517)
DeclareVariable("signals.i_line_peak", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signals.i_line_rms", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("signals.i_phase_peak", "[A]", "signals.i_line_peak", 1, 5, 826, 0)
DeclareVariable("signals.i_phase_rms", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signals.u_s_set_magnitude", "[V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signals.u_s_set_rms", "[V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signals.u_line_peak", "[V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signals.u_line_rms", "[V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signals.u_phase_peak", "[V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signals.u_phase_rms", "[V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("signals.lineCurrents.y[1]", "Vector with the currents in the three supply lines [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 0)
DeclareAlias2("signals.lineCurrents.y[2]", "Vector with the currents in the three supply lines [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 0)
DeclareAlias2("signals.lineCurrents.y[3]", "Vector with the currents in the three supply lines [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 0)
DeclareAlias2("signals.lineVoltages.y[1]", "Vector with the voltages across the three supply lines [V]",\
 "machine.voltageSensor.v[1]", 1, 5, 422, 0)
DeclareAlias2("signals.lineVoltages.y[2]", "Vector with the voltages across the three supply lines [V]",\
 "machine.voltageSensor.v[2]", 1, 5, 423, 0)
DeclareAlias2("signals.lineVoltages.y[3]", "Vector with the voltages across the three supply lines [V]",\
 "machine.voltageSensor.v[3]", 1, 5, 424, 0)
DeclareAlias2("signals.setVoltageUdUq.y[1]", "Output signal connector [V]", \
"controller.coreElement.actuatingVoltages_dq[1]", 1, 5, 675, 0)
DeclareAlias2("signals.setVoltageUdUq.y[2]", "Output signal connector [V]", \
"controller.coreElement.actuatingVoltages_dq[2]", 1, 5, 676, 0)
DeclareVariable("signals.clarkeTransform.alpha", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signals.clarkeTransform.beta", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("signals.clarkeTransform.u[1]", "", "machine.plug_p.pin[1].i", 1, 5,\
 35, 0)
DeclareAlias2("signals.clarkeTransform.u[2]", "", "machine.plug_p.pin[2].i", 1, 5,\
 37, 0)
DeclareAlias2("signals.clarkeTransform.u[3]", "", "machine.plug_p.pin[3].i", 1, 5,\
 39, 0)
DeclareAlias2("signals.rectangularToPolar.u_re", "Real part of rectangular representation",\
 "signals.clarkeTransform.alpha", 1, 5, 835, 0)
DeclareAlias2("signals.rectangularToPolar.u_im", "Imaginary part of rectangular representation",\
 "signals.clarkeTransform.beta", 1, 5, 836, 0)
DeclareAlias2("signals.rectangularToPolar.y_abs", "Length of polar representation",\
 "signals.i_line_peak", 1, 5, 826, 0)
DeclareVariable("signals.rectangularToPolar.y_arg", "Angle of polar representation [rad]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("signals.gain_i_L.k", "Gain value multiplied with input signal [1]",\
 155, 0.7071067811865475, 0.0,0.0,0.0,0,560)
DeclareAlias2("signals.gain_i_L.u", "Input signal connector", "signals.i_line_peak", 1,\
 5, 826, 0)
DeclareAlias2("signals.gain_i_L.y", "Output signal connector", "signals.i_line_rms", 1,\
 5, 827, 0)
DeclareVariable("signals.clarkeTransform1.alpha", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("signals.clarkeTransform1.beta", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("signals.clarkeTransform1.u[1]", "", "machine.voltageSensor.v[1]", 1,\
 5, 422, 0)
DeclareAlias2("signals.clarkeTransform1.u[2]", "", "machine.voltageSensor.v[2]", 1,\
 5, 423, 0)
DeclareAlias2("signals.clarkeTransform1.u[3]", "", "machine.voltageSensor.v[3]", 1,\
 5, 424, 0)
DeclareAlias2("signals.rectangularToPolar1.u_re", "Real part of rectangular representation",\
 "signals.clarkeTransform1.alpha", 1, 5, 838, 0)
DeclareAlias2("signals.rectangularToPolar1.u_im", "Imaginary part of rectangular representation",\
 "signals.clarkeTransform1.beta", 1, 5, 839, 0)
DeclareAlias2("signals.rectangularToPolar1.y_abs", "Length of polar representation",\
 "signals.u_line_peak", 1, 5, 831, 0)
DeclareVariable("signals.rectangularToPolar1.y_arg", "Angle of polar representation [rad]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("signals.gain_u_LL.k", "Gain value multiplied with input signal [1]",\
 156, 0.7071067811865475, 0.0,0.0,0.0,0,560)
DeclareAlias2("signals.gain_u_LL.u", "Input signal connector", "signals.u_line_peak", 1,\
 5, 831, 0)
DeclareAlias2("signals.gain_u_LL.y", "Output signal connector", "signals.u_line_rms", 1,\
 5, 832, 0)
DeclareVariable("signals.gain_u_phase.k", "Gain value multiplied with input signal [1]",\
 0.5773502691896258, 0.0,0.0,0.0,0,513)
DeclareAlias2("signals.gain_u_phase.u", "Input signal connector", \
"signals.u_line_peak", 1, 5, 831, 0)
DeclareAlias2("signals.gain_u_phase.y", "Output signal connector", \
"signals.u_phase_peak", 1, 5, 833, 0)
DeclareAlias2("signals.rectangularToPolar2.u_re", "Real part of rectangular representation",\
 "controller.coreElement.actuatingVoltages_dq[1]", 1, 5, 675, 0)
DeclareAlias2("signals.rectangularToPolar2.u_im", "Imaginary part of rectangular representation",\
 "controller.coreElement.actuatingVoltages_dq[2]", 1, 5, 676, 0)
DeclareAlias2("signals.rectangularToPolar2.y_abs", "Length of polar representation",\
 "signals.u_s_set_magnitude", 1, 5, 829, 0)
DeclareVariable("signals.rectangularToPolar2.y_arg", "Angle of polar representation [rad]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("signals.gain_u_s_set_rms.k", "Gain value multiplied with input signal [1]",\
 157, 0.7071067811865475, 0.0,0.0,0.0,0,560)
DeclareAlias2("signals.gain_u_s_set_rms.u", "Input signal connector", \
"signals.u_s_set_magnitude", 1, 5, 829, 0)
DeclareAlias2("signals.gain_u_s_set_rms.y", "Output signal connector", \
"signals.u_s_set_rms", 1, 5, 830, 0)
DeclareVariable("signals.gain_i_phase.k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("signals.gain_i_phase.u", "Input signal connector", \
"signals.i_line_peak", 1, 5, 826, 0)
DeclareAlias2("signals.gain_i_phase.y", "Output signal connector", \
"signals.i_line_peak", 1, 5, 826, 0)
DeclareParameter("signals.gain_i_phase2.k", "Gain value multiplied with input signal [1]",\
 158, 0.7071067811865475, 0.0,0.0,0.0,0,560)
DeclareAlias2("signals.gain_i_phase2.u", "Input signal connector", \
"signals.i_line_peak", 1, 5, 826, 0)
DeclareAlias2("signals.gain_i_phase2.y", "Output signal connector", \
"signals.i_phase_rms", 1, 5, 828, 0)
DeclareParameter("signals.gain_u_phase2.k", "Gain value multiplied with input signal [1]",\
 159, 0.7071067811865475, 0.0,0.0,0.0,0,560)
DeclareAlias2("signals.gain_u_phase2.u", "Input signal connector", \
"signals.u_phase_peak", 1, 5, 833, 0)
DeclareAlias2("signals.gain_u_phase2.y", "Output signal connector", \
"signals.u_phase_rms", 1, 5, 834, 0)
DeclareAlias2("inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "multiSensor.flange_a.phi", 1, 1, 2, 4)
DeclareAlias2("inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
"machine.flange.tau", -1, 5, 40, 132)
DeclareAlias2("inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "multiSensor.flange_a.phi", 1, 1, 2, 4)
DeclareAlias2("inertia.flange_b.tau", "Cut torque in the flange [N.m]", \
"load.flange.tau", -1, 5, 491, 132)
DeclareParameter("inertia.J", "Moment of inertia [kg.m2]", 160, 0.25, 0.0,1E+100,\
0.0,0,560)
DeclareVariable("inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("inertia.phi", "Absolute rotation angle of component [rad|deg]", \
"multiSensor.flange_a.phi", 1, 1, 2, 0)
DeclareAlias2("inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "inertia.w", 1, 1, 15, 0)
DeclareState("inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 15, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "inertia.der(w)", 1, 6, 15, 0)
DeclareVariable("machine.coreElement.thermalAmbient.constTr.k", "Constant output value",\
 293.15, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.coreElement.thermalAmbient.constTr.y", "Connector of Real output signal",\
 293.15, 0.0,0.0,0.0,0,513)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addP.u1",\
 "Connector of Real input signal 1", "controller.coreElement.fieldWeakeningController.fieldWeakeningController.u_s", 1,\
 5, 628, 0)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addP.u2",\
 "Connector of Real input signal 2", "controller.coreElement.fieldWeakeningController.firstOrder.y", 1,\
 1, 5, 0)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addP.y",\
 "Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addP.k1",\
 "Gain of input signal 1", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addP.k2",\
 "Gain of input signal 2", 161, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.coreElement.fieldWeakeningController.fieldWeakeningController.P.k",\
 "Gain value multiplied with input signal [1]", 162, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.P.u",\
 "Input signal connector", "controller.coreElement.fieldWeakeningController.fieldWeakeningController.addP.y", 1,\
 5, 847, 0)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.P.y",\
 "Output signal connector", "controller.coreElement.fieldWeakeningController.fieldWeakeningController.addPI.u1", 1,\
 5, 641, 0)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.I.k",\
 "Integrator gain [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.I.use_reset",\
 "=true, if reset port enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.I.use_set",\
 "=true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.I.initType",\
 "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.I.y_start",\
 "Initial or guess value of output (= state)", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.I.u",\
 "Connector of Real input signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("controller.coreElement.fieldWeakeningController.fieldWeakeningController.I.y",\
 "Connector of Real output signal", 16, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("controller.coreElement.fieldWeakeningController.fieldWeakeningController.I.der(y)",\
 "der(Connector of Real output signal)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.I.local_reset",\
 "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.I.local_set",\
 "", 0, 0.0,0.0,0.0,0,1537)
DeclareParameter("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addI.k1",\
 "Gain of input signal 1", 163, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addI.k2",\
 "Gain of input signal 2", 164, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addI.k3",\
 "Gain of input signal 3", 165, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addI.u1",\
 "Connector of Real input signal 1", "controller.coreElement.fieldWeakeningController.fieldWeakeningController.u_s", 1,\
 5, 628, 0)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addI.u2",\
 "Connector of Real input signal 2", "controller.coreElement.fieldWeakeningController.firstOrder.y", 1,\
 1, 5, 0)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addI.u3",\
 "Connector of Real input signal 3", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addI.y",\
 "Connector of Real output signal", "controller.coreElement.fieldWeakeningController.fieldWeakeningController.I.u", 1,\
 5, 854, 0)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addSat.u1",\
 "Connector of Real input signal 1", "controller.coreElement.fieldWeakeningController.delta_i_d", 1,\
 5, 626, 0)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addSat.u2",\
 "Connector of Real input signal 2", "controller.coreElement.fieldWeakeningController.fieldWeakeningController.gainPI.y", 1,\
 5, 640, 0)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addSat.y",\
 "Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addSat.k1",\
 "Gain of input signal 1", 166, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.coreElement.fieldWeakeningController.fieldWeakeningController.addSat.k2",\
 "Gain of input signal 2", 167, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("controller.coreElement.fieldWeakeningController.fieldWeakeningController.gainTrack.k",\
 "Gain value multiplied with input signal [1]", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.gainTrack.u",\
 "Input signal connector", "controller.coreElement.fieldWeakeningController.fieldWeakeningController.addSat.y", 1,\
 5, 858, 0)
DeclareAlias2("controller.coreElement.fieldWeakeningController.fieldWeakeningController.gainTrack.y",\
 "Output signal connector", "controller.coreElement.fieldWeakeningController.fieldWeakeningController.addI.u3", 1,\
 5, 857, 0)
DeclareAlias2("controller.coreElement.speedController.addP.u1", "Connector of Real input signal 1",\
 "controller.desiredSpeed", 1, 5, 496, 0)
DeclareAlias2("controller.coreElement.speedController.addP.u2", "Connector of Real input signal 2",\
 "inertia.w", 1, 1, 15, 0)
DeclareVariable("controller.coreElement.speedController.addP.y", \
"Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.speedController.addP.k1", \
"Gain of input signal 1", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("controller.coreElement.speedController.addP.k2", \
"Gain of input signal 2", 168, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.coreElement.speedController.P.k", "Gain value multiplied with input signal [1]",\
 169, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.coreElement.speedController.P.u", "Input signal connector",\
 "controller.coreElement.speedController.addP.y", 1, 5, 860, 0)
DeclareAlias2("controller.coreElement.speedController.P.y", "Output signal connector",\
 "controller.coreElement.speedController.addPI.u1", 1, 5, 715, 0)
DeclareVariable("controller.coreElement.speedController.I.k", "Integrator gain [1]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.speedController.I.use_reset", \
"=true, if reset port enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("controller.coreElement.speedController.I.use_set", \
"=true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("controller.coreElement.speedController.I.initType", \
"Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("controller.coreElement.speedController.I.y_start", \
"Initial or guess value of output (= state)", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("controller.coreElement.speedController.I.u", "Connector of Real input signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("controller.coreElement.speedController.I.y", "Connector of Real output signal",\
 17, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("controller.coreElement.speedController.I.der(y)", \
"der(Connector of Real output signal)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("controller.coreElement.speedController.I.local_reset", \
"[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("controller.coreElement.speedController.I.local_set", "", 0, \
0.0,0.0,0.0,0,1537)
DeclareParameter("controller.coreElement.speedController.addI.k1", \
"Gain of input signal 1", 170, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.coreElement.speedController.addI.k2", \
"Gain of input signal 2", 171, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.coreElement.speedController.addI.k3", \
"Gain of input signal 3", 172, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("controller.coreElement.speedController.addI.u1", "Connector of Real input signal 1",\
 "controller.desiredSpeed", 1, 5, 496, 0)
DeclareAlias2("controller.coreElement.speedController.addI.u2", "Connector of Real input signal 2",\
 "inertia.w", 1, 1, 15, 0)
DeclareVariable("controller.coreElement.speedController.addI.u3", \
"Connector of Real input signal 3", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("controller.coreElement.speedController.addI.y", "Connector of Real output signal",\
 "controller.coreElement.speedController.I.u", 1, 5, 867, 0)
DeclareAlias2("controller.coreElement.speedController.addSat.u1", \
"Connector of Real input signal 1", "controller.coreElement.MTPA.i_s_ref", 1, 5,\
 659, 0)
DeclareAlias2("controller.coreElement.speedController.addSat.u2", \
"Connector of Real input signal 2", "controller.coreElement.speedController.gainPI.y", 1,\
 5, 714, 0)
DeclareVariable("controller.coreElement.speedController.addSat.y", \
"Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("controller.coreElement.speedController.addSat.k1", \
"Gain of input signal 1", 173, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("controller.coreElement.speedController.addSat.k2", \
"Gain of input signal 2", 174, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("controller.coreElement.speedController.gainTrack.k", \
"Gain value multiplied with input signal [1]", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("controller.coreElement.speedController.gainTrack.u", \
"Input signal connector", "controller.coreElement.speedController.addSat.y", 1, 5,\
 871, 0)
DeclareAlias2("controller.coreElement.speedController.gainTrack.y", \
"Output signal connector", "controller.coreElement.speedController.addI.u3", 1, 5,\
 870, 0)
DeclareVariable("machine.toBus_temperatures.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_temperatures.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_temperatures.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("machine.toBus_temperatures.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.mechanicPower", \
"Mechanic power at the machine's shaft [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.cosPhi", "Mechanic rotational speed of machine's shaft [1]",\
 "machine.quasiPowerSensor.cosphi", 1, 5, 448, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.lineCurrents[1]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.lineCurrents[2]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.lineCurrents[3]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.lineVoltages[1]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.lineVoltages[2]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.lineVoltages[3]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.electricPower", \
"Electric power of the machine [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("threePhaseIdealInverter.toBus_maxStatorVoltage.electricDriveBus.maxLineVoltage",\
 "Maximum voltage that is possible at the machine's terminal [V]", \
"threePhaseIdealInverter.const.k", 1, 5, 488, 4)
DeclareAlias2("threePhaseIdealInverter.toBus_SwitchingFrequency.electricDriveBus.switchingFrequency",\
 "Connector of Real output signal", "threePhaseIdealInverter.switchingFrequency.k", 1,\
 7, 30, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.lineCurrents[1]",\
 "Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.lineCurrents[2]",\
 "Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.lineCurrents[3]",\
 "Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.rotorSpeed", \
"Output signal connector [rad/s|1/min]", "inertia.w", 1, 1, 15, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.phasors.u_s_set_dq[1]",\
 "Output values for voltage driven inverters in d/q coordinates [V]", \
"controller.coreElement.actuatingVoltages_dq[1]", 1, 5, 675, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.phasors.u_s_set_dq[2]",\
 "Output values for voltage driven inverters in d/q coordinates [V]", \
"controller.coreElement.actuatingVoltages_dq[2]", 1, 5, 676, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.setVoltageUs[1]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.setVoltageUs[2]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.setVoltageUs[3]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.maxLineVoltage",\
 "Output signal connector [V]", "toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.rotorAngle", \
"Output signal connector [rad|deg]", "machine.angleSensor.phi_rel", 1, 5, 392, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.maxLineVoltage", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.electricPower",\
 "Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.mechanicPower",\
 "Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.lineCurrents[1]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.lineCurrents[2]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.lineCurrents[3]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.lineVoltages[1]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.lineVoltages[2]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.lineVoltages[3]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.phasors.u_s_set_dq[1]", \
"Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.phasors.u_s_set_dq[2]", \
"Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("controller.electricDriveBus.phasors.u_s_set_dq[1]", \
"Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("controller.electricDriveBus.phasors.u_s_set_dq[2]", \
"Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.phasors.u_s_set_dq[1]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.phasors.u_s_set_dq[2]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.phasors.u_s_set_dq[1]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.phasors.u_s_set_dq[2]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.phasors.u_s_set_dq[1]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.phasors.u_s_set_dq[2]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.phasors.u_s_set_dq[1]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.phasors.u_s_set_dq[2]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.phasors.u_s_set_dq[1]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.phasors.u_s_set_dq[2]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.phasors.u_s_set_dq[1]", \
"Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.phasors.u_s_set_dq[2]", \
"Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("machine.electricDriveBus.phasors.u_s_set_dq[1]", "Output signal connector [V]",\
 "controller.coreElement.actuatingVoltages_dq[1]", 1, 5, 675, 4)
DeclareAlias2("machine.electricDriveBus.phasors.u_s_set_dq[2]", "Output signal connector [V]",\
 "controller.coreElement.actuatingVoltages_dq[2]", 1, 5, 676, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.phasors.u_s_set_dq[1]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.phasors.u_s_set_dq[2]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.phasors.u_s_set_dq[1]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.phasors.u_s_set_dq[2]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.phasors.u_s_set_dq[1]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.phasors.u_s_set_dq[2]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.phasors.u_s_set_dq[1]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.phasors.u_s_set_dq[2]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.phasors.u_s_set_dq[1]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.phasors.u_s_set_dq[2]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.phasors.u_s_set_dq[1]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.phasors.u_s_set_dq[2]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.phasors.u_s_set_dq[1]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.phasors.u_s_set_dq[2]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.phasors.u_s_set_dq[1]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.phasors.u_s_set_dq[2]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.phasors.u_s_set_dq[1]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.phasors.u_s_set_dq[2]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.phasors.u_s_set_dq[1]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.phasors.u_s_set_dq[2]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.phasors.u_s_set_dq[1]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.phasors.u_s_set_dq[2]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.phasors.u_s_set_dq[1]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.phasors.u_s_set_dq[2]",\
 "Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("signals.electricDriveBus.phasors.u_s_set_dq[1]", "Output signal connector [V]",\
 "controller.coreElement.actuatingVoltages_dq[1]", 1, 5, 675, 4)
DeclareAlias2("signals.electricDriveBus.phasors.u_s_set_dq[2]", "Output signal connector [V]",\
 "controller.coreElement.actuatingVoltages_dq[2]", 1, 5, 676, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.phasors.u_s_set_dq[1]", \
"Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.phasors.u_s_set_dq[2]", \
"Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.phasors.u_s_set_dq[1]", \
"Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.phasors.u_s_set_dq[2]", \
"Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.phasors.u_s_set_dq[1]", \
"Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[1]", 1,\
 5, 675, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.phasors.u_s_set_dq[2]", \
"Output signal connector [V]", "controller.coreElement.actuatingVoltages_dq[2]", 1,\
 5, 676, 4)
DeclareAlias2("controller.electricDriveBus.cosPhi", "Mechanic rotational speed of machine's shaft [1]",\
 "machine.quasiPowerSensor.cosphi", 1, 5, 448, 4)
DeclareAlias2("controller.electricDriveBus.electricPower", "Output signal [W]", \
"machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("controller.electricDriveBus.innerTorque", "Electrical torque inside the machine [N.m]",\
 "machine.coreElement.innerTorque", 1, 5, 362, 4)
DeclareAlias2("controller.electricDriveBus.lineCurrents[1]", "Vector with the currents in the three supply lines [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 4)
DeclareAlias2("controller.electricDriveBus.lineCurrents[2]", "Vector with the currents in the three supply lines [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 4)
DeclareAlias2("controller.electricDriveBus.lineCurrents[3]", "Vector with the currents in the three supply lines [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 4)
DeclareAlias2("controller.electricDriveBus.lineVoltages[1]", "Vector with the voltages across the three supply lines [V]",\
 "machine.voltageSensor.v[1]", 1, 5, 422, 4)
DeclareAlias2("controller.electricDriveBus.lineVoltages[2]", "Vector with the voltages across the three supply lines [V]",\
 "machine.voltageSensor.v[2]", 1, 5, 423, 4)
DeclareAlias2("controller.electricDriveBus.lineVoltages[3]", "Vector with the voltages across the three supply lines [V]",\
 "machine.voltageSensor.v[3]", 1, 5, 424, 4)
DeclareVariable("controller.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("controller.electricDriveBus.machineTemperatures.rotorCore", \
"[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("controller.electricDriveBus.machineTemperatures.statorCore", \
"[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("controller.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("controller.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("controller.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("controller.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("controller.electricDriveBus.maxLineVoltage", "Maximum voltage that is possible at the machine's terminal [V]",\
 "toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("controller.electricDriveBus.mechanicPower", "Output signal [W]", \
"machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("controller.electricDriveBus.outerTorque", "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("controller.electricDriveBus.rotorAngle", "Mechanic angle of machine's shaft [rad|deg]",\
 "machine.angleSensor.phi_rel", 1, 5, 392, 4)
DeclareAlias2("controller.electricDriveBus.rotorSpeed", "Mechanic rotational speed of machine's shaft [rad/s|1/min]",\
 "inertia.w", 1, 1, 15, 4)
DeclareAlias2("controller.electricDriveBus.setVoltageUs[1]", "Output values for voltage driven inverters as phase voltages [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("controller.electricDriveBus.setVoltageUs[2]", "Output values for voltage driven inverters as phase voltages [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("controller.electricDriveBus.setVoltageUs[3]", "Output values for voltage driven inverters as phase voltages [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.cosPhi", \
"Mechanic rotational speed of machine's shaft [1]", "machine.quasiPowerSensor.cosphi", 1,\
 5, 448, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.electricPower", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.lineVoltages[1]",\
 "Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.lineVoltages[2]",\
 "Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.lineVoltages[3]",\
 "Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("controller.fromBus_lineCurrents.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("controller.fromBus_lineCurrents.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("controller.fromBus_lineCurrents.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("controller.fromBus_lineCurrents.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.maxLineVoltage",\
 "Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.mechanicPower", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.setVoltageUs[1]",\
 "Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.setVoltageUs[2]",\
 "Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("controller.fromBus_lineCurrents.electricDriveBus.setVoltageUs[3]",\
 "Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.cosPhi", \
"Mechanic rotational speed of machine's shaft [1]", "machine.quasiPowerSensor.cosphi", 1,\
 5, 448, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.electricPower",\
 "Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.lineCurrents[1]",\
 "Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.lineCurrents[2]",\
 "Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.lineCurrents[3]",\
 "Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.lineVoltages[1]",\
 "Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.lineVoltages[2]",\
 "Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.lineVoltages[3]",\
 "Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("controller.fromBus_maxLineVoltage.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("controller.fromBus_maxLineVoltage.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("controller.fromBus_maxLineVoltage.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("controller.fromBus_maxLineVoltage.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.mechanicPower",\
 "Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.setVoltageUs[1]",\
 "Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.setVoltageUs[2]",\
 "Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("controller.fromBus_maxLineVoltage.electricDriveBus.setVoltageUs[3]",\
 "Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.cosPhi", \
"Mechanic rotational speed of machine's shaft [1]", "machine.quasiPowerSensor.cosphi", 1,\
 5, 448, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.electricPower", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.lineCurrents[1]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.lineCurrents[2]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.lineCurrents[3]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.lineVoltages[1]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
EndNonAlias(0)
PreNonAliasNew(1)
StartNonAlias(1)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.lineVoltages[2]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.lineVoltages[3]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("controller.fromBus_shaftAngle.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("controller.fromBus_shaftAngle.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("controller.fromBus_shaftAngle.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("controller.fromBus_shaftAngle.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.maxLineVoltage", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.mechanicPower", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.setVoltageUs[1]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.setVoltageUs[2]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("controller.fromBus_shaftAngle.electricDriveBus.setVoltageUs[3]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.cosPhi", \
"Mechanic rotational speed of machine's shaft [1]", "machine.quasiPowerSensor.cosphi", 1,\
 5, 448, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.electricPower", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.lineCurrents[1]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.lineCurrents[2]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.lineCurrents[3]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.lineVoltages[1]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.lineVoltages[2]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.lineVoltages[3]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("controller.fromBus_shaftSpeed.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("controller.fromBus_shaftSpeed.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("controller.fromBus_shaftSpeed.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("controller.fromBus_shaftSpeed.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.maxLineVoltage", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.mechanicPower", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.setVoltageUs[1]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.setVoltageUs[2]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("controller.fromBus_shaftSpeed.electricDriveBus.setVoltageUs[3]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.cosPhi", \
"Mechanic rotational speed of machine's shaft [1]", "machine.quasiPowerSensor.cosphi", 1,\
 5, 448, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.electricPower", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.lineCurrents[1]",\
 "Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.lineCurrents[2]",\
 "Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.lineCurrents[3]",\
 "Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.lineVoltages[1]",\
 "Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.lineVoltages[2]",\
 "Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.lineVoltages[3]",\
 "Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("controller.toBus_setVoltageUdUq.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("controller.toBus_setVoltageUdUq.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("controller.toBus_setVoltageUdUq.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("controller.toBus_setVoltageUdUq.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.maxLineVoltage",\
 "Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.mechanicPower", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.setVoltageUs[1]",\
 "Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.setVoltageUs[2]",\
 "Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("controller.toBus_setVoltageUdUq.electricDriveBus.setVoltageUs[3]",\
 "Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.cosPhi", \
"Mechanic rotational speed of machine's shaft [1]", "machine.quasiPowerSensor.cosphi", 1,\
 5, 448, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.electricPower", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.lineCurrents[1]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.lineCurrents[2]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.lineCurrents[3]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.lineVoltages[1]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.lineVoltages[2]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.lineVoltages[3]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("controller.toBus_setVoltageUs.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("controller.toBus_setVoltageUs.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("controller.toBus_setVoltageUs.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("controller.toBus_setVoltageUs.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.maxLineVoltage", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.mechanicPower", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("controller.toBus_setVoltageUs.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.electricPower", "Output signal [W]",\
 "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.innerTorque", "Electrical torque inside the machine [N.m]",\
 "machine.coreElement.innerTorque", 1, 5, 362, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.lineCurrents[1]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.lineCurrents[2]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.lineCurrents[3]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.lineVoltages[1]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.lineVoltages[2]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.lineVoltages[3]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("machine.cosPhi.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.cosPhi.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.cosPhi.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.cosPhi.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("machine.cosPhi.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("machine.cosPhi.electricDriveBus.maxLineVoltage", "Maximum voltage that is possible at the machine's terminal [V]",\
 "toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.mechanicPower", "Output signal [W]",\
 "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.outerTorque", "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.rotorAngle", "Mechanic angle of machine's shaft [rad|deg]",\
 "machine.angleSensor.phi_rel", 1, 5, 392, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.rotorSpeed", "Mechanic rotational speed of machine's shaft [rad/s|1/min]",\
 "inertia.w", 1, 1, 15, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.setVoltageUs[1]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.setVoltageUs[2]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.cosPhi.electricDriveBus.setVoltageUs[3]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.electricDriveBus.cosPhi", "Mechanic rotational speed of machine's shaft [1]",\
 "machine.quasiPowerSensor.cosphi", 1, 5, 448, 4)
DeclareAlias2("machine.electricDriveBus.electricPower", "Output signal [W]", \
"machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("machine.electricDriveBus.innerTorque", "Electrical torque inside the machine [N.m]",\
 "machine.coreElement.innerTorque", 1, 5, 362, 4)
DeclareAlias2("machine.electricDriveBus.lineCurrents[1]", "Vector with the currents in the three supply lines [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 4)
DeclareAlias2("machine.electricDriveBus.lineCurrents[2]", "Vector with the currents in the three supply lines [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 4)
DeclareAlias2("machine.electricDriveBus.lineCurrents[3]", "Vector with the currents in the three supply lines [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 4)
DeclareAlias2("machine.electricDriveBus.lineVoltages[1]", "Vector with the voltages across the three supply lines [V]",\
 "machine.voltageSensor.v[1]", 1, 5, 422, 4)
DeclareAlias2("machine.electricDriveBus.lineVoltages[2]", "Vector with the voltages across the three supply lines [V]",\
 "machine.voltageSensor.v[2]", 1, 5, 423, 4)
DeclareAlias2("machine.electricDriveBus.lineVoltages[3]", "Vector with the voltages across the three supply lines [V]",\
 "machine.voltageSensor.v[3]", 1, 5, 424, 4)
DeclareVariable("machine.electricDriveBus.machineTemperatures.permanentMagnet", \
"[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.electricDriveBus.machineTemperatures.rotorCore", \
"[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.electricDriveBus.machineTemperatures.statorCore", \
"[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.electricDriveBus.machineTemperatures.statorWindings[1]", \
"[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.electricDriveBus.machineTemperatures.statorWindings[2]", \
"[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.electricDriveBus.machineTemperatures.statorWindings[3]", \
"[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("machine.electricDriveBus.machineTemperatures.useDamperCage", \
"Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("machine.electricDriveBus.maxLineVoltage", "Maximum voltage that is possible at the machine's terminal [V]",\
 "toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("machine.electricDriveBus.mechanicPower", "Output signal [W]", \
"machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("machine.electricDriveBus.outerTorque", "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("machine.electricDriveBus.rotorAngle", "Mechanic angle of machine's shaft [rad|deg]",\
 "machine.angleSensor.phi_rel", 1, 5, 392, 4)
DeclareAlias2("machine.electricDriveBus.rotorSpeed", "Mechanic rotational speed of machine's shaft [rad/s|1/min]",\
 "inertia.w", 1, 1, 15, 4)
DeclareAlias2("machine.electricDriveBus.setVoltageUs[1]", "Output values for voltage driven inverters as phase voltages [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.electricDriveBus.setVoltageUs[2]", "Output values for voltage driven inverters as phase voltages [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.electricDriveBus.setVoltageUs[3]", "Output values for voltage driven inverters as phase voltages [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.cosPhi", \
"Mechanic rotational speed of machine's shaft [1]", "machine.quasiPowerSensor.cosphi", 1,\
 5, 448, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.lineCurrents[1]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.lineCurrents[2]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.lineCurrents[3]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.lineVoltages[1]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.lineVoltages[2]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.lineVoltages[3]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("machine.toBus_electricPower.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_electricPower.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_electricPower.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("machine.toBus_electricPower.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.maxLineVoltage", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.mechanicPower", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.setVoltageUs[1]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.setVoltageUs[2]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.toBus_electricPower.electricDriveBus.setVoltageUs[3]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.cosPhi", \
"Mechanic rotational speed of machine's shaft [1]", "machine.quasiPowerSensor.cosphi", 1,\
 5, 448, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.electricPower", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.lineCurrents[1]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.lineCurrents[2]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.lineCurrents[3]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.lineVoltages[1]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.lineVoltages[2]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.lineVoltages[3]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("machine.toBus_innerTorque.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_innerTorque.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_innerTorque.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("machine.toBus_innerTorque.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.maxLineVoltage", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.mechanicPower", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.setVoltageUs[1]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.setVoltageUs[2]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.toBus_innerTorque.electricDriveBus.setVoltageUs[3]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.cosPhi", \
"Mechanic rotational speed of machine's shaft [1]", "machine.quasiPowerSensor.cosphi", 1,\
 5, 448, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.electricPower", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.lineVoltages[1]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.lineVoltages[2]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.lineVoltages[3]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("machine.toBus_lineCurrents.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_lineCurrents.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_lineCurrents.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("machine.toBus_lineCurrents.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.maxLineVoltage", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.mechanicPower", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.setVoltageUs[1]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.setVoltageUs[2]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.toBus_lineCurrents.electricDriveBus.setVoltageUs[3]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.cosPhi", \
"Mechanic rotational speed of machine's shaft [1]", "machine.quasiPowerSensor.cosphi", 1,\
 5, 448, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.electricPower", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.lineCurrents[1]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.lineCurrents[2]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.lineCurrents[3]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareVariable("machine.toBus_lineVoltages.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_lineVoltages.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_lineVoltages.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("machine.toBus_lineVoltages.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.maxLineVoltage", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.mechanicPower", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.setVoltageUs[1]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.setVoltageUs[2]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.toBus_lineVoltages.electricDriveBus.setVoltageUs[3]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.cosPhi", \
"Mechanic rotational speed of machine's shaft [1]", "machine.quasiPowerSensor.cosphi", 1,\
 5, 448, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.electricPower", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.lineCurrents[1]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.lineCurrents[2]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.lineCurrents[3]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.lineVoltages[1]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.lineVoltages[2]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.lineVoltages[3]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("machine.toBus_mechanicPower.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_mechanicPower.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_mechanicPower.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("machine.toBus_mechanicPower.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.maxLineVoltage", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.setVoltageUs[1]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.setVoltageUs[2]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.toBus_mechanicPower.electricDriveBus.setVoltageUs[3]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.cosPhi", \
"Mechanic rotational speed of machine's shaft [1]", "machine.quasiPowerSensor.cosphi", 1,\
 5, 448, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.electricPower", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.lineCurrents[1]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.lineCurrents[2]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.lineCurrents[3]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.lineVoltages[1]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.lineVoltages[2]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.lineVoltages[3]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("machine.toBus_outerTorque.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_outerTorque.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_outerTorque.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("machine.toBus_outerTorque.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.maxLineVoltage", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.mechanicPower", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.setVoltageUs[1]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.setVoltageUs[2]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.toBus_outerTorque.electricDriveBus.setVoltageUs[3]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.cosPhi", \
"Mechanic rotational speed of machine's shaft [1]", "machine.quasiPowerSensor.cosphi", 1,\
 5, 448, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.electricPower", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.lineCurrents[1]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.lineCurrents[2]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.lineCurrents[3]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.lineVoltages[1]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.lineVoltages[2]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.lineVoltages[3]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("machine.toBus_shaftAngle.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_shaftAngle.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_shaftAngle.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("machine.toBus_shaftAngle.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.maxLineVoltage", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.mechanicPower", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.setVoltageUs[1]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.setVoltageUs[2]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.toBus_shaftAngle.electricDriveBus.setVoltageUs[3]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.cosPhi", \
"Mechanic rotational speed of machine's shaft [1]", "machine.quasiPowerSensor.cosphi", 1,\
 5, 448, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.electricPower", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.lineCurrents[1]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.lineCurrents[2]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.lineCurrents[3]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.lineVoltages[1]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.lineVoltages[2]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.lineVoltages[3]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("machine.toBus_shaftSpeed.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_shaftSpeed.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machine.toBus_shaftSpeed.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("machine.toBus_shaftSpeed.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.maxLineVoltage", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.mechanicPower", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.setVoltageUs[1]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.setVoltageUs[2]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.toBus_shaftSpeed.electricDriveBus.setVoltageUs[3]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.cosPhi", \
"Mechanic rotational speed of machine's shaft [1]", "machine.quasiPowerSensor.cosphi", 1,\
 5, 448, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.electricPower", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.lineCurrents[1]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.lineCurrents[2]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.lineCurrents[3]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.lineVoltages[1]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.lineVoltages[2]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.lineVoltages[3]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.maxLineVoltage", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.mechanicPower", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.setVoltageUs[1]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.setVoltageUs[2]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machine.toBus_temperatures.electricDriveBus.setVoltageUs[3]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.cosPhi", \
"Mechanic rotational speed of machine's shaft [1]", "machine.quasiPowerSensor.cosphi", 1,\
 5, 448, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.electricPower", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.lineCurrents[1]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.lineCurrents[2]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.lineCurrents[3]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.lineVoltages[1]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.lineVoltages[2]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.lineVoltages[3]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("machineEfficiencyComputation.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machineEfficiencyComputation.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machineEfficiencyComputation.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("machineEfficiencyComputation.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.maxLineVoltage", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.mechanicPower", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.setVoltageUs[1]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.setVoltageUs[2]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machineEfficiencyComputation.electricDriveBus.setVoltageUs[3]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.cosPhi",\
 "Mechanic rotational speed of machine's shaft [1]", "machine.quasiPowerSensor.cosphi", 1,\
 5, 448, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.innerTorque",\
 "Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.lineCurrents[1]",\
 "Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.lineCurrents[2]",\
 "Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.lineCurrents[3]",\
 "Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.lineVoltages[1]",\
 "Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.lineVoltages[2]",\
 "Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.lineVoltages[3]",\
 "Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.maxLineVoltage",\
 "Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.mechanicPower",\
 "Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.outerTorque",\
 "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.rotorAngle",\
 "Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.rotorSpeed",\
 "Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.setVoltageUs[1]",\
 "Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.setVoltageUs[2]",\
 "Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machineEfficiencyComputation.electricPowerFromBus.electricDriveBus.setVoltageUs[3]",\
 "Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.cosPhi",\
 "Mechanic rotational speed of machine's shaft [1]", "machine.quasiPowerSensor.cosphi", 1,\
 5, 448, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.electricPower",\
 "Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.innerTorque",\
 "Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.lineCurrents[1]",\
 "Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.lineCurrents[2]",\
 "Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.lineCurrents[3]",\
 "Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.lineVoltages[1]",\
 "Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.lineVoltages[2]",\
 "Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.lineVoltages[3]",\
 "Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.maxLineVoltage",\
 "Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.outerTorque",\
 "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.rotorAngle",\
 "Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.rotorSpeed",\
 "Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.setVoltageUs[1]",\
 "Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.setVoltageUs[2]",\
 "Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("machineEfficiencyComputation.mechanicPowerFromBus.electricDriveBus.setVoltageUs[3]",\
 "Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("signals.electricDriveBus.cosPhi", "Mechanic rotational speed of machine's shaft [1]",\
 "machine.quasiPowerSensor.cosphi", 1, 5, 448, 4)
DeclareAlias2("signals.electricDriveBus.electricPower", "Output signal [W]", \
"machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("signals.electricDriveBus.innerTorque", "Electrical torque inside the machine [N.m]",\
 "machine.coreElement.innerTorque", 1, 5, 362, 4)
DeclareAlias2("signals.electricDriveBus.lineCurrents[1]", "Vector with the currents in the three supply lines [A]",\
 "machine.plug_p.pin[1].i", 1, 5, 35, 4)
DeclareAlias2("signals.electricDriveBus.lineCurrents[2]", "Vector with the currents in the three supply lines [A]",\
 "machine.plug_p.pin[2].i", 1, 5, 37, 4)
DeclareAlias2("signals.electricDriveBus.lineCurrents[3]", "Vector with the currents in the three supply lines [A]",\
 "machine.plug_p.pin[3].i", 1, 5, 39, 4)
DeclareAlias2("signals.electricDriveBus.lineVoltages[1]", "Vector with the voltages across the three supply lines [V]",\
 "machine.voltageSensor.v[1]", 1, 5, 422, 4)
DeclareAlias2("signals.electricDriveBus.lineVoltages[2]", "Vector with the voltages across the three supply lines [V]",\
 "machine.voltageSensor.v[2]", 1, 5, 423, 4)
DeclareAlias2("signals.electricDriveBus.lineVoltages[3]", "Vector with the voltages across the three supply lines [V]",\
 "machine.voltageSensor.v[3]", 1, 5, 424, 4)
DeclareVariable("signals.electricDriveBus.machineTemperatures.permanentMagnet", \
"[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("signals.electricDriveBus.machineTemperatures.rotorCore", \
"[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("signals.electricDriveBus.machineTemperatures.statorCore", \
"[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("signals.electricDriveBus.machineTemperatures.statorWindings[1]", \
"[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("signals.electricDriveBus.machineTemperatures.statorWindings[2]", \
"[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("signals.electricDriveBus.machineTemperatures.statorWindings[3]", \
"[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("signals.electricDriveBus.machineTemperatures.useDamperCage", \
"Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("signals.electricDriveBus.maxLineVoltage", "Maximum voltage that is possible at the machine's terminal [V]",\
 "toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("signals.electricDriveBus.mechanicPower", "Output signal [W]", \
"machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("signals.electricDriveBus.outerTorque", "Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("signals.electricDriveBus.rotorAngle", "Mechanic angle of machine's shaft [rad|deg]",\
 "machine.angleSensor.phi_rel", 1, 5, 392, 4)
DeclareAlias2("signals.electricDriveBus.rotorSpeed", "Mechanic rotational speed of machine's shaft [rad/s|1/min]",\
 "inertia.w", 1, 1, 15, 4)
DeclareAlias2("signals.electricDriveBus.setVoltageUs[1]", "Output values for voltage driven inverters as phase voltages [V]",\
 "machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("signals.electricDriveBus.setVoltageUs[2]", "Output values for voltage driven inverters as phase voltages [V]",\
 "machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("signals.electricDriveBus.setVoltageUs[3]", "Output values for voltage driven inverters as phase voltages [V]",\
 "machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.cosPhi", "Mechanic rotational speed of machine's shaft [1]",\
 "machine.quasiPowerSensor.cosphi", 1, 5, 448, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.electricPower", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.lineVoltages[1]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.lineVoltages[2]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.lineVoltages[3]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("signals.lineCurrents.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("signals.lineCurrents.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("signals.lineCurrents.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("signals.lineCurrents.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("signals.lineCurrents.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("signals.lineCurrents.electricDriveBus.maxLineVoltage", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.mechanicPower", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.setVoltageUs[1]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.setVoltageUs[2]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("signals.lineCurrents.electricDriveBus.setVoltageUs[3]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.cosPhi", "Mechanic rotational speed of machine's shaft [1]",\
 "machine.quasiPowerSensor.cosphi", 1, 5, 448, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.electricPower", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.lineCurrents[1]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.lineCurrents[2]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.lineCurrents[3]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareVariable("signals.lineVoltages.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("signals.lineVoltages.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("signals.lineVoltages.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("signals.lineVoltages.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("signals.lineVoltages.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("signals.lineVoltages.electricDriveBus.maxLineVoltage", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.mechanicPower", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.setVoltageUs[1]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.setVoltageUs[2]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("signals.lineVoltages.electricDriveBus.setVoltageUs[3]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.cosPhi", "Mechanic rotational speed of machine's shaft [1]",\
 "machine.quasiPowerSensor.cosphi", 1, 5, 448, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.electricPower", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.lineCurrents[1]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.lineCurrents[2]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.lineCurrents[3]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.lineVoltages[1]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.lineVoltages[2]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.lineVoltages[3]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("signals.setVoltageUdUq.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("signals.setVoltageUdUq.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("signals.setVoltageUdUq.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("signals.setVoltageUdUq.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.maxLineVoltage", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"toBus_maxLineVoltage.u", 1, 5, 738, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.mechanicPower", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.setVoltageUs[1]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.setVoltageUs[2]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("signals.setVoltageUdUq.electricDriveBus.setVoltageUs[3]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.cosPhi", "Mechanic rotational speed of machine's shaft [1]",\
 "machine.quasiPowerSensor.cosphi", 1, 5, 448, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.electricPower", \
"Output signal [W]", "machine.quasiPowerSensor.P", 1, 5, 449, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.innerTorque", \
"Electrical torque inside the machine [N.m]", "machine.coreElement.innerTorque", 1,\
 5, 362, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.lineCurrents[1]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[1].i", 1,\
 5, 35, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.lineCurrents[2]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[2].i", 1,\
 5, 37, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.lineCurrents[3]", \
"Vector with the currents in the three supply lines [A]", "machine.plug_p.pin[3].i", 1,\
 5, 39, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.lineVoltages[1]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[1]", 1,\
 5, 422, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.lineVoltages[2]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[2]", 1,\
 5, 423, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.lineVoltages[3]", \
"Vector with the voltages across the three supply lines [V]", "machine.voltageSensor.v[3]", 1,\
 5, 424, 4)
DeclareVariable("toBus_maxLineVoltage.electricDriveBus.machineTemperatures.permanentMagnet",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("toBus_maxLineVoltage.electricDriveBus.machineTemperatures.rotorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("toBus_maxLineVoltage.electricDriveBus.machineTemperatures.statorCore",\
 "[K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.machineTemperatures.statorWindings[1]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.machineTemperatures.statorWindings[2]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.machineTemperatures.statorWindings[3]",\
 "[K|degC]", "machine.coreElement.thermalAmbient.constTs.k", 1, 5, 268, 4)
DeclareVariable("toBus_maxLineVoltage.electricDriveBus.machineTemperatures.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.mechanicPower", \
"Output signal [W]", "machine.innerPower.y", 1, 5, 397, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.outerTorque", \
"Outer mechnical torque at the shaft of the machine considering inner inertia [N.m]",\
 "machine.flange.tau", -1, 5, 40, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.rotorAngle", \
"Mechanic angle of machine's shaft [rad|deg]", "machine.angleSensor.phi_rel", 1,\
 5, 392, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.rotorSpeed", \
"Mechanic rotational speed of machine's shaft [rad/s|1/min]", "inertia.w", 1, 1,\
 15, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.setVoltageUs[1]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[1].v", 1, 5, 34, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.setVoltageUs[2]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[2].v", 1, 5, 36, 4)
DeclareAlias2("toBus_maxLineVoltage.electricDriveBus.setVoltageUs[3]", \
"Output values for voltage driven inverters as phase voltages [V]", \
"machine.plug_p.pin[3].v", 1, 5, 38, 4)
DeclareAlias2("threePhaseIdealInverter.electricDriveBus.maxLineVoltage", \
"Maximum voltage that is possible at the machine's terminal [V]", \
"threePhaseIdealInverter.const.k", 1, 5, 488, 4)
DeclareAlias2("threePhaseIdealInverter.electricDriveBus.switchingFrequency", \
"Connector of Real output signal", "threePhaseIdealInverter.switchingFrequency.k", 1,\
 7, 30, 4)
DeclareAlias2("threePhaseIdealInverter.toBus_SwitchingFrequency.electricDriveBus.maxLineVoltage",\
 "Maximum voltage that is possible at the machine's terminal [V]", \
"threePhaseIdealInverter.const.k", 1, 5, 488, 4)
DeclareAlias2("threePhaseIdealInverter.toBus_maxStatorVoltage.electricDriveBus.switchingFrequency",\
 "Connector of Real output signal", "threePhaseIdealInverter.switchingFrequency.k", 1,\
 7, 30, 4)
EndNonAlias(1)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
if (initialCall) DYNX(did_->xInitial_var, 0)=DYNX(W_,686);
else if (DYNHReject) DYNX(W_,686)=did_->xInitial_var2[0]; else did_->xInitial_var2[0]=
  DYNX(W_,686);
if (initialCall) DYNX(did_->xInitial_var, 1)=DYNX(W_,695);
else if (DYNHReject) DYNX(W_,695)=did_->xInitial_var2[1]; else did_->xInitial_var2[1]=
  DYNX(W_,695);
}
StartDataBlock
StartEqBlock
DoRemember_(DYNX(W_,686), DYNX(W_,691), 1);
DoRemember_(DYNX(W_,695), DYNX(W_,691), 0);
DoRemember_(DYNX(F_,15), 0.0, 8);
DoRemember_(DYNX(F_,0), 0.0, 6);
DoRemember_(DYNX(F_,1), 0.0, 7);
DoRemember_(DYNX(W_,206), 0.0, 4);
DoRemember_(DYNX(W_,207), 0.0, 3);
DoRemember_(DYNX(W_,37), 0.0, 5);
DoRemember_(DYNX(W_,39), 0.0, 2);
EndEqBlock
EndDataBlock
  BreakSectionStart(3);
  DYNX(W_,659) = DYNX(W_,714);
  DYNX(W_,696) = IF (IF DYNX(W_,659) > 0 THEN 1 ELSE IF DYNX(W_,659) < 0 THEN -1
     ELSE 0) == (IF DYNX(W_,678) > 0 THEN 1 ELSE IF DYNX(W_,678) < 0 THEN -1
     ELSE 0) THEN 1 ELSE 0;
  DYNX(W_,627) = DYNX(W_,692)*DYNX(W_,685)-DYNX(W_,696)*fabs(DYNX(W_,659))*
    DYNX(W_,689);
  DYNX(W_,698) = (PushModelContext(1,"DymolaModels.Functions.Math.divNoZero(controller.coreElement.fieldWeakeningController.u_s_max, controller.coreElement.mechanicalToElectricSpeed.y, 1, true)")
    DymolaModels_Functions_Math_divNoZero(DYNX(W_,627), DYNX(W_,678), 1, true));
  PopModelContext();
  DYNX(W_,697) = (-1666.6666666666667)*(0.0003*DYNX(W_,690)-sqrtGuarded(sqr(
    0.0003*DYNX(W_,690))+1.7999999999999997E-07*sqr(DYNX(W_,698)),
    "(0.0003*controller.coreElement.currentLimits.withReluctance.psi_PM)^2+1.7999999999999997E-07*controller.coreElement.currentLimits.withReluctance.psi_MTPV^2"));
  DYNX(W_,694) = 3333.3333333333335*sqrtGuarded(RealBmax(0, sqr(DYNX(W_,698))-
    sqr(DYNX(W_,697))),"max(0, controller.coreElement.currentLimits.withReluctance.psi_MTPV^2-controller.coreElement.currentLimits.withReluctance.delta_psi^2)");
  DYNX(W_,693) = (-6666.666666666667)*(DYNX(W_,690)+DYNX(W_,697));
  DYNX(W_,695) = powIntExp_inverse(sqr(DYNX(W_,693))+sqr(DYNX(W_,694)), 2, 
    DYNX(W_,695), "controller.coreElement.currentLimits.withReluctance.i_s_max_MTPV^2");

    DYNX(W_,660) = 1666.6666666666667*(DYNX(W_,658)-sqrtGuarded(sqr(DYNX(W_,658))
      +1.7999999999999997E-07*sqr(DYNX(W_,659)),"controller.coreElement.MTPA.psi_PM^2+1.7999999999999997E-07*controller.coreElement.MTPA.i_s_ref^2"));
    DYNX(W_,661) = IF sqr(DYNX(W_,659))-sqr(DYNX(W_,660)) <= 0 THEN 0 ELSE (IF 
      DYNX(W_,659) > 0 THEN 1 ELSE IF DYNX(W_,659) < 0 THEN -1 ELSE 0)*
      sqrtGuarded(sqr(DYNX(W_,659))-sqr(DYNX(W_,660)),"controller.coreElement.MTPA.i_s_ref^2-controller.coreElement.MTPA.i_d_mtpa^2");
  DYNX(W_,654) = IF LessS(fabs(DYNX(W_,695)),"abs(controller.coreElement.currentLimits.withReluctance.i_s_max_MTPV)",
     DYNX(W_,691),"controller.coreElement.currentLimits.withReluctance.i_s_peak",
     0) THEN DYNX(W_,693)-DYNX(W_,660) ELSE  -(DYNX(W_,691)+DYNX(W_,660));
  DYNX(W_,674) = IF LessS(fabs(DYNX(W_,695)),"abs(controller.coreElement.currentLimits.withReluctance.i_s_max_MTPV)",
     DYNX(W_,691),"controller.coreElement.currentLimits.withReluctance.i_s_peak",
     0) THEN DYNX(W_,694) ELSE DYNX(W_,691);
  DYNX(W_,686) = RealBmin(DYNX(W_,691), sqrtGuarded(sqr(DYNX(W_,654)+
    DYNX(W_,660))+sqr(DYNX(W_,674)),"(controller.coreElement.fieldWeakeningController.i_d_min+controller.coreElement.MTPA.i_d_mtpa)^2+controller.coreElement.limit_i_q.i_q_max^2"));
  DYNX(W_,720) = IF DYNX(W_,686) >= 0 THEN DYNX(W_,686) ELSE  -DYNX(W_,686);
  DYNX(W_,719) = DYNX(DP_,107)*DYNX(W_,720);
  BreakSectionEnd()

BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionCallNew(2);
BreakSectionFunctionCallNew(4);
BreakSectionFunctionCallNew(5);
BreakSectionFunctionCallNew(6);
BreakSectionFunctionEnd()
